var documenterSearchIndex = {"docs":
[{"location":"description.html#Description","page":"Description","title":"Description","text":"","category":"section"},{"location":"description.html#Index","page":"Description","title":"Index","text":"","category":"section"},{"location":"description.html","page":"Description","title":"Description","text":"Pages   = [\"description.md\"]\nModules = [CTBase]\nOrder = [:module, :constant, :type, :function, :macro]","category":"page"},{"location":"description.html","page":"Description","title":"Description","text":"warning: Warning\nIn the examples in the documentation below, the methods are not prefixed by the module name even if they are private. julia> using CTBase\njulia> x = 1\njulia> private_fun(x) # throw an errormust be replaced byjulia> using CTBase\njulia> x = 1\njulia> CTBase.private_fun(x)However, if the method is reexported by another package, then, there is no need of prefixing.julia> module OptimalControl\n           import CTBase: private_fun\n           export private_fun\n       end\njulia> using OptimalControl\njulia> x = 1\njulia> private_fun(x)","category":"page"},{"location":"description.html#Documentation","page":"Description","title":"Documentation","text":"","category":"section"},{"location":"description.html#CTBase.DescVarArg","page":"Description","title":"CTBase.DescVarArg","text":"DescVarArg is a Vararg of symbols. DescVarArg is a type alias for a Vararg of symbols.\n\njulia> const DescVarArg = Vararg{Symbol}\n\nSee also: Description.\n\n\n\n\n\n","category":"constant"},{"location":"description.html#CTBase.Description","page":"Description","title":"CTBase.Description","text":"A description is a tuple of symbols. Description is a type alias for a tuple of symbols.\n\njulia> const Description = Tuple{DescVarArg}\n\nSee also: DescVarArg.\n\nExample\n\nBase.show is overloaded for descriptions, that is tuple of descriptions are printed as follows:\n\njulia> display( ( (:a, :b), (:b, :c) ) )\n(:a, :b)\n(:b, :c)\n\n\n\n\n\n","category":"type"},{"location":"description.html#Base.show-Tuple{IO, MIME{Symbol(\"text/plain\")}, Tuple{Vararg{Tuple{Vararg{Symbol}}}}}","page":"Description","title":"Base.show","text":"show(\n    io::IO,\n    _::MIME{Symbol(\"text/plain\")},\n    descriptions::Tuple{Vararg{Tuple{Vararg{Symbol}}}}\n)\n\n\nPrint a tuple of descriptions.\n\nExample\n\njulia> display( ( (:a, :b), (:b, :c) ) )\n(:a, :b)\n(:b, :c)\n\n\n\n\n\n","category":"method"},{"location":"description.html#CTBase.add-Tuple{Tuple{Vararg{Tuple{Vararg{Symbol}}}}, Tuple{Vararg{Symbol}}}","page":"Description","title":"CTBase.add","text":"add(\n    x::Tuple{Vararg{Tuple{Vararg{Symbol}}}},\n    y::Tuple{Vararg{Symbol}}\n) -> Tuple{Tuple{Vararg{Symbol}}}\n\n\nAdd the description y to the tuple of descriptions x if x does not contain y and return the new tuple of descriptions. \n\nThrow an exception (IncorrectArgument) if the description y is already contained in x.\n\nExample\n\njulia> descriptions = ()\njulia> descriptions = add(descriptions, (:a,))\n(:a,)\njulia> descriptions = add(descriptions, (:b,))\n(:a,)\n(:b,)\njulia> descriptions = add(descriptions, (:b,))\nERROR: IncorrectArgument: the description (:b,) is already in ((:a,), (:b,))\n\n\n\n\n\n","category":"method"},{"location":"description.html#CTBase.add-Tuple{Tuple{}, Tuple{Vararg{Symbol}}}","page":"Description","title":"CTBase.add","text":"add(\n    _::Tuple{},\n    y::Tuple{Vararg{Symbol}}\n) -> Tuple{Tuple{Vararg{Symbol}}}\n\n\nReturn a tuple containing only the description y.\n\nExample\n\njulia> descriptions = ()\njulia> descriptions = add(descriptions, (:a,))\n(:a,)\njulia> print(descriptions)\n((:a,),)\njulia> descriptions[1]\n(:a,)\n\n\n\n\n\n","category":"method"},{"location":"description.html#CTBase.complete-Tuple{Vararg{Symbol}}","page":"Description","title":"CTBase.complete","text":"complete(list::Symbol...; descriptions)\n\n\nReturn one description from a list of Symbols list and a set of descriptions D.  If multiple descriptions are possible, then the first one is selected.\n\nIf the list is not contained in any of the descriptions, then an exception is thrown.\n\nExample\n\njulia> D = ((:a, :b), (:a, :b, :c), (:b, :c), (:a, :c))\n(:a, :b)\n(:b, :c)\n(:a, :c)\njulia> complete(:a; descriptions=D)\n(:a, :b)\njulia> complete(:a, :c; descriptions=D)\n(:a, :b, :c)\njulia> complete((:a, :c); descriptions=D)\n(:a, :b, :c)\njulia> complete(:f; descriptions=D)\nERROR: AmbiguousDescription: the description (:f,) is ambiguous / incorrect\n\n\n\n\n\n","category":"method"},{"location":"description.html#CTBase.remove-Tuple{Tuple{Vararg{Symbol}}, Tuple{Vararg{Symbol}}}","page":"Description","title":"CTBase.remove","text":"remove(\n    x::Tuple{Vararg{Symbol}},\n    y::Tuple{Vararg{Symbol}}\n) -> Tuple{Vararg{Symbol}}\n\n\nReturn the difference between the description x and the description y.\n\nExample\n\njulia> remove((:a, :b), (:a,))\n(:b,)\n\n\n\n\n\n","category":"method"},{"location":"description.html","page":"Description","title":"Description","text":"","category":"page"},{"location":"exception.html#Exception","page":"Exception","title":"Exception","text":"","category":"section"},{"location":"exception.html#Index","page":"Exception","title":"Index","text":"","category":"section"},{"location":"exception.html","page":"Exception","title":"Exception","text":"Pages   = [\"exception.md\"]\nModules = [CTBase, Base]\nOrder = [:module, :constant, :type, :function, :macro]","category":"page"},{"location":"exception.html","page":"Exception","title":"Exception","text":"warning: Warning\nIn the examples in the documentation below, the methods are not prefixed by the module name even if they are private. julia> using CTBase\njulia> x = 1\njulia> private_fun(x) # throw an errormust be replaced byjulia> using CTBase\njulia> x = 1\njulia> CTBase.private_fun(x)However, if the method is reexported by another package, then, there is no need of prefixing.julia> module OptimalControl\n           import CTBase: private_fun\n           export private_fun\n       end\njulia> using OptimalControl\njulia> x = 1\njulia> private_fun(x)","category":"page"},{"location":"exception.html#Documentation","page":"Exception","title":"Documentation","text":"","category":"section"},{"location":"exception.html#CTBase.AmbiguousDescription","page":"Exception","title":"CTBase.AmbiguousDescription","text":"struct AmbiguousDescription <: CTBase.CTException\n\nException thrown when a description is ambiguous or does not match any known descriptions.\n\nFields\n\nvar::Tuple{Vararg{Symbol}}: The ambiguous or incorrect description tuple that caused the error.\n\nExample\n\njulia> complete(:f; descriptions=((:a, :b), (:a, :b, :c)))\nERROR: AmbiguousDescription: the description (:f,) is ambiguous / incorrect\n\nThis error is useful to signal when a user provides a description that cannot be matched to any known valid descriptions.\n\n\n\n\n\n","category":"type"},{"location":"exception.html#CTBase.CTException","page":"Exception","title":"CTBase.CTException","text":"abstract type CTException <: Exception\n\nAbstract supertype for all custom exceptions in this module.\n\nUse this as the common ancestor for all domain-specific errors to allow catching all exceptions of this family via catch e::CTException.\n\nNo fields.\n\nExample\n\njulia> try\n           throw(IncorrectArgument(\"invalid input\"))\n       catch e::CTException\n           println(\"Caught a domain-specific exception: \", e)\n       end\nCaught a domain-specific exception: IncorrectArgument: invalid input\n\n\n\n\n\n","category":"type"},{"location":"exception.html#CTBase.ExtensionError","page":"Exception","title":"CTBase.ExtensionError","text":"struct ExtensionError <: CTBase.CTException\n\nException thrown when an extension or optional dependency is not loaded but a function requiring it is called.\n\nFields\n\nweakdeps::Tuple{Vararg{Symbol}}: The tuple of symbols representing the missing dependencies.\n\nConstructor\n\nThrows UnauthorizedCall if no weak dependencies are provided.\n\nExample\n\njulia> throw(ExtensionError(:MyExtension))\nERROR: ExtensionError. Please make: julia> using MyExtension\n\n\n\n\n\n","category":"type"},{"location":"exception.html#CTBase.IncorrectArgument","page":"Exception","title":"CTBase.IncorrectArgument","text":"struct IncorrectArgument <: CTBase.CTException\n\nException thrown when an argument passed to a function or constructor is inconsistent, invalid, or does not satisfy preconditions.\n\nFields\n\nvar::String: A descriptive message explaining the nature of the incorrect argument.\n\nExample\n\njulia> throw(IncorrectArgument(\"the argument must be a non-empty tuple\"))\nERROR: IncorrectArgument: the argument must be a non-empty tuple\n\n\n\n\n\n","category":"type"},{"location":"exception.html#CTBase.IncorrectMethod","page":"Exception","title":"CTBase.IncorrectMethod","text":"struct IncorrectMethod <: CTBase.CTException\n\nException thrown when a specified method name or function symbol does not exist.\n\nFields\n\nvar::Symbol: The method or function symbol that was expected but not found.\n\nExample\n\njulia> throw(IncorrectMethod(:nonexistent_func))\nERROR: IncorrectMethod: nonexistent_func is not an existing method\n\n\n\n\n\n","category":"type"},{"location":"exception.html#CTBase.IncorrectOutput","page":"Exception","title":"CTBase.IncorrectOutput","text":"struct IncorrectOutput <: CTBase.CTException\n\nException thrown when the output produced by a function is incorrect or inconsistent with expected results.\n\nFields\n\nvar::String: A descriptive message explaining the incorrect output.\n\nExample\n\njulia> throw(IncorrectOutput(\"the function returned NaN\"))\nERROR: IncorrectOutput: the function returned NaN\n\n\n\n\n\n","category":"type"},{"location":"exception.html#CTBase.NotImplemented","page":"Exception","title":"CTBase.NotImplemented","text":"struct NotImplemented <: CTBase.CTException\n\nException thrown when a method or function has not been implemented yet.\n\nFields\n\nvar::String: A message indicating what functionality is not yet implemented.\n\nExample\n\njulia> throw(NotImplemented(\"feature X is not implemented\"))\nERROR: NotImplemented: feature X is not implemented\n\n\n\n\n\n","category":"type"},{"location":"exception.html#CTBase.ParsingError","page":"Exception","title":"CTBase.ParsingError","text":"struct ParsingError <: CTBase.CTException\n\nException thrown during parsing when a syntax error or invalid structure is detected.\n\nFields\n\nvar::String: A message describing the parsing error.\n\nExample\n\njulia> throw(ParsingError(\"unexpected token\"))\nERROR: ParsingError: unexpected token\n\n\n\n\n\n","category":"type"},{"location":"exception.html#CTBase.UnauthorizedCall","page":"Exception","title":"CTBase.UnauthorizedCall","text":"struct UnauthorizedCall <: CTBase.CTException\n\nException thrown when a function call is not authorized in the current context or with the given arguments.\n\nFields\n\nvar::String: A message explaining why the call is unauthorized.\n\nExample\n\njulia> throw(UnauthorizedCall(\"user does not have permission\"))\nERROR: UnauthorizedCall: user does not have permission\n\n\n\n\n\n","category":"type"},{"location":"exception.html#Base.showerror-Tuple{IO, CTBase.AmbiguousDescription}","page":"Exception","title":"Base.showerror","text":"showerror(io::IO, e::CTBase.AmbiguousDescription)\n\n\nCustomizes the printed message of the exception.\n\nExample\n\njulia> throw(AmbiguousDescription((:x, :y)))\nERROR: AmbiguousDescription: the description (:x, :y) is ambiguous / incorrect\n\n\n\n\n\n","category":"method"},{"location":"exception.html#Base.showerror-Tuple{IO, CTBase.ExtensionError}","page":"Exception","title":"Base.showerror","text":"showerror(io::IO, e::CTBase.ExtensionError)\n\n\nCustomizes the printed message of the exception, prompting the user to load the required extensions.\n\nExample\n\njulia> e = ExtensionError(:MyExtension, :AnotherDep)\njulia> showerror(stdout, e)\nERROR: ExtensionError. Please make: julia> using MyExtension, AnotherDep\n\n\n\n\n\n","category":"method"},{"location":"exception.html#Base.showerror-Tuple{IO, CTBase.IncorrectArgument}","page":"Exception","title":"Base.showerror","text":"showerror(io::IO, e::CTBase.IncorrectArgument)\n\n\nCustomizes the printed message of the exception.\n\n\n\n\n\n","category":"method"},{"location":"exception.html#Base.showerror-Tuple{IO, CTBase.IncorrectMethod}","page":"Exception","title":"Base.showerror","text":"showerror(io::IO, e::CTBase.IncorrectMethod)\n\n\nCustomizes the printed message of the exception.\n\n\n\n\n\n","category":"method"},{"location":"exception.html#Base.showerror-Tuple{IO, CTBase.IncorrectOutput}","page":"Exception","title":"Base.showerror","text":"showerror(io::IO, e::CTBase.IncorrectOutput)\n\n\nCustomizes the printed message of the exception.\n\n\n\n\n\n","category":"method"},{"location":"exception.html#Base.showerror-Tuple{IO, CTBase.NotImplemented}","page":"Exception","title":"Base.showerror","text":"showerror(io::IO, e::CTBase.NotImplemented)\n\n\nCustomizes the printed message of the exception.\n\n\n\n\n\n","category":"method"},{"location":"exception.html#Base.showerror-Tuple{IO, CTBase.ParsingError}","page":"Exception","title":"Base.showerror","text":"showerror(io::IO, e::CTBase.ParsingError)\n\n\nCustomizes the printed message of the exception.\n\n\n\n\n\n","category":"method"},{"location":"exception.html#Base.showerror-Tuple{IO, CTBase.UnauthorizedCall}","page":"Exception","title":"Base.showerror","text":"showerror(io::IO, e::CTBase.UnauthorizedCall)\n\n\nCustomizes the printed message of the exception.\n\n\n\n\n\n","category":"method"},{"location":"exception.html","page":"Exception","title":"Exception","text":"","category":"page"},{"location":"ctbase.html#CTBase","page":"CTBase","title":"CTBase","text":"","category":"section"},{"location":"ctbase.html#Index","page":"CTBase","title":"Index","text":"","category":"section"},{"location":"ctbase.html","page":"CTBase","title":"CTBase","text":"Pages   = [\"ctbase.md\"]\nModules = [CTBase]\nOrder = [:module, :constant, :type, :function, :macro]","category":"page"},{"location":"ctbase.html#Documentation","page":"CTBase","title":"Documentation","text":"","category":"section"},{"location":"ctbase.html#CTBase.ctNumber","page":"CTBase","title":"CTBase.ctNumber","text":"Type alias for a real number.\n\njulia> const ctNumber = Real\n\n\n\n\n\n","category":"type"},{"location":"ctbase.html","page":"CTBase","title":"CTBase","text":"","category":"page"},{"location":"default.html#Default","page":"Default","title":"Default","text":"","category":"section"},{"location":"default.html#Index","page":"Default","title":"Index","text":"","category":"section"},{"location":"default.html","page":"Default","title":"Default","text":"Pages   = [\"default.md\"]\nModules = [CTBase]\nOrder = [:module, :constant, :type, :function, :macro]","category":"page"},{"location":"default.html#Documentation","page":"Default","title":"Documentation","text":"","category":"section"},{"location":"default.html#CTBase.__display-Tuple{}","page":"Default","title":"CTBase.__display","text":"__display() -> Bool\n\n\nUsed to set the default value of the display argument. The default value is true, which means that the output is printed during execution.\n\n\n\n\n\n","category":"method"},{"location":"default.html","page":"Default","title":"Default","text":"","category":"page"},{"location":"index.html#CTBase.jl","page":"Introduction","title":"CTBase.jl","text":"","category":"section"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"The CTBase.jl package is part of the control-toolbox ecosystem.","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"The root package is OptimalControl.jl which aims to provide tools to model and solve optimal control problems with ordinary differential equations by direct and indirect methods.","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"API Documentation","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"Pages = Main.API_PAGES\nDepth = 1","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"","category":"page"}]
}

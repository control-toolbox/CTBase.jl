var documenterSearchIndex = {"docs":
[{"location":"description.html#Description","page":"Description","title":"Description","text":"","category":"section"},{"location":"description.html#Index","page":"Description","title":"Index","text":"","category":"section"},{"location":"description.html","page":"Description","title":"Description","text":"Pages   = [\"description.md\"]\nModules = [CTBase]\nOrder = [:module, :constant, :type, :function, :macro]","category":"page"},{"location":"description.html","page":"Description","title":"Description","text":"warning: Warning\nIn the examples in the documentation below, the methods are not prefixed by the module name even if they are private. julia> using CTBase\njulia> x = 1\njulia> private_fun(x) # throw an errormust be replaced byjulia> using CTBase\njulia> x = 1\njulia> CTBase.private_fun(x)However, if the method is reexported by another package, then, there is no need of prefixing.julia> module OptimalControl\n           import CTBase: private_fun\n           export private_fun\n       end\njulia> using OptimalControl\njulia> x = 1\njulia> private_fun(x)","category":"page"},{"location":"description.html#Documentation","page":"Description","title":"Documentation","text":"","category":"section"},{"location":"description.html#CTBase.DescVarArg","page":"Description","title":"CTBase.DescVarArg","text":"DescVarArg is a Vararg of symbols. DescVarArg is a type alias for a Vararg of symbols.\n\njulia> const DescVarArg = Vararg{Symbol}\n\nSee also: Description.\n\n\n\n\n\n","category":"constant"},{"location":"description.html#CTBase.Description","page":"Description","title":"CTBase.Description","text":"A description is a tuple of symbols. Description is a type alias for a tuple of symbols.\n\njulia> const Description = Tuple{DescVarArg}\n\nSee also: DescVarArg.\n\nExample\n\nBase.show is overloaded for descriptions, that is tuple of descriptions are printed as follows:\n\njulia> display( ( (:a, :b), (:b, :c) ) )\n(:a, :b)\n(:b, :c)\n\n\n\n\n\n","category":"type"},{"location":"description.html#Base.show-Tuple{IO, MIME{Symbol(\"text/plain\")}, Tuple{Vararg{Tuple{Vararg{Symbol}}}}}","page":"Description","title":"Base.show","text":"show(\n    io::IO,\n    _::MIME{Symbol(\"text/plain\")},\n    descriptions::Tuple{Vararg{Tuple{Vararg{Symbol}}}}\n)\n\n\nPrint a tuple of descriptions.\n\nExample\n\njulia> display( ( (:a, :b), (:b, :c) ) )\n(:a, :b)\n(:b, :c)\n\n\n\n\n\n","category":"method"},{"location":"description.html#CTBase.add-Tuple{Tuple{Vararg{Tuple{Vararg{Symbol}}}}, Tuple{Vararg{Symbol}}}","page":"Description","title":"CTBase.add","text":"add(\n    x::Tuple{Vararg{Tuple{Vararg{Symbol}}}},\n    y::Tuple{Vararg{Symbol}}\n) -> Tuple{Tuple{Vararg{Symbol}}}\n\n\nAdd the description y to the tuple of descriptions x if x does not contain y and return the new tuple of descriptions. \n\nThrow an exception (IncorrectArgument) if the description y is already contained in x.\n\nExample\n\njulia> descriptions = ()\njulia> descriptions = add(descriptions, (:a,))\n(:a,)\njulia> descriptions = add(descriptions, (:b,))\n(:a,)\n(:b,)\njulia> descriptions = add(descriptions, (:b,))\nERROR: IncorrectArgument: the description (:b,) is already in ((:a,), (:b,))\n\n\n\n\n\n","category":"method"},{"location":"description.html#CTBase.add-Tuple{Tuple{}, Tuple{Vararg{Symbol}}}","page":"Description","title":"CTBase.add","text":"add(\n    _::Tuple{},\n    y::Tuple{Vararg{Symbol}}\n) -> Tuple{Tuple{Vararg{Symbol}}}\n\n\nReturn a tuple containing only the description y.\n\nExample\n\njulia> descriptions = ()\njulia> descriptions = add(descriptions, (:a,))\n(:a,)\njulia> print(descriptions)\n((:a,),)\njulia> descriptions[1]\n(:a,)\n\n\n\n\n\n","category":"method"},{"location":"description.html#CTBase.complete-Tuple{Vararg{Symbol}}","page":"Description","title":"CTBase.complete","text":"complete(list::Symbol...; descriptions)\n\n\nReturn one description from a list of Symbols list and a set of descriptions D.  If multiple descriptions are possible, then the first one is selected.\n\nIf the list is not contained in any of the descriptions, then an exception is thrown.\n\nExample\n\njulia> D = ((:a, :b), (:a, :b, :c), (:b, :c), (:a, :c))\n(:a, :b)\n(:b, :c)\n(:a, :c)\njulia> complete(:a; descriptions=D)\n(:a, :b)\njulia> complete(:a, :c; descriptions=D)\n(:a, :b, :c)\njulia> complete((:a, :c); descriptions=D)\n(:a, :b, :c)\njulia> complete(:f; descriptions=D)\nERROR: AmbiguousDescription: the description (:f,) is ambiguous / incorrect\n\n\n\n\n\n","category":"method"},{"location":"description.html#CTBase.remove-Tuple{Tuple{Vararg{Symbol}}, Tuple{Vararg{Symbol}}}","page":"Description","title":"CTBase.remove","text":"remove(\n    x::Tuple{Vararg{Symbol}},\n    y::Tuple{Vararg{Symbol}}\n) -> Tuple{Vararg{Symbol}}\n\n\nReturn the difference between the description x and the description y.\n\nExample\n\njulia> remove((:a, :b), (:a,))\n(:b,)\n\n\n\n\n\n","category":"method"},{"location":"description.html","page":"Description","title":"Description","text":"","category":"page"},{"location":"exception.html#Exception","page":"Exception","title":"Exception","text":"","category":"section"},{"location":"exception.html#Index","page":"Exception","title":"Index","text":"","category":"section"},{"location":"exception.html","page":"Exception","title":"Exception","text":"Pages   = [\"exception.md\"]\nModules = [CTBase, Base]\nOrder = [:module, :constant, :type, :function, :macro]","category":"page"},{"location":"exception.html","page":"Exception","title":"Exception","text":"warning: Warning\nIn the examples in the documentation below, the methods are not prefixed by the module name even if they are private. julia> using CTBase\njulia> x = 1\njulia> private_fun(x) # throw an errormust be replaced byjulia> using CTBase\njulia> x = 1\njulia> CTBase.private_fun(x)However, if the method is reexported by another package, then, there is no need of prefixing.julia> module OptimalControl\n           import CTBase: private_fun\n           export private_fun\n       end\njulia> using OptimalControl\njulia> x = 1\njulia> private_fun(x)","category":"page"},{"location":"exception.html#Documentation","page":"Exception","title":"Documentation","text":"","category":"section"},{"location":"exception.html#CTBase.AmbiguousDescription","page":"Exception","title":"CTBase.AmbiguousDescription","text":"struct AmbiguousDescription <: CTBase.CTException\n\nException thrown when a description is ambiguous or does not match any known descriptions.\n\nFields\n\nvar::Tuple{Vararg{Symbol}}: The ambiguous or incorrect description tuple that caused the error.\n\nExample\n\njulia> complete(:f; descriptions=((:a, :b), (:a, :b, :c)))\nERROR: AmbiguousDescription: the description (:f,) is ambiguous / incorrect\n\nThis error is useful to signal when a user provides a description that cannot be matched to any known valid descriptions.\n\n\n\n\n\n","category":"type"},{"location":"exception.html#CTBase.CTException","page":"Exception","title":"CTBase.CTException","text":"abstract type CTException <: Exception\n\nAbstract supertype for all custom exceptions in this module.\n\nUse this as the common ancestor for all domain-specific errors to allow catching all exceptions of this family via catch e::CTException.\n\nNo fields.\n\nExample\n\njulia> try\n           throw(IncorrectArgument(\"invalid input\"))\n       catch e::CTException\n           println(\"Caught a domain-specific exception: \", e)\n       end\nCaught a domain-specific exception: IncorrectArgument: invalid input\n\n\n\n\n\n","category":"type"},{"location":"exception.html#CTBase.ExtensionError","page":"Exception","title":"CTBase.ExtensionError","text":"struct ExtensionError <: CTBase.CTException\n\nException thrown when an extension or optional dependency is not loaded but a function requiring it is called.\n\nFields\n\nweakdeps::Tuple{Vararg{Symbol}}: The tuple of symbols representing the missing dependencies.\n\nConstructor\n\nThrows UnauthorizedCall if no weak dependencies are provided.\n\nExample\n\njulia> throw(ExtensionError(:MyExtension))\nERROR: ExtensionError. Please make: julia> using MyExtension\n\n\n\n\n\n","category":"type"},{"location":"exception.html#CTBase.IncorrectArgument","page":"Exception","title":"CTBase.IncorrectArgument","text":"struct IncorrectArgument <: CTBase.CTException\n\nException thrown when an argument passed to a function or constructor is inconsistent, invalid, or does not satisfy preconditions.\n\nFields\n\nvar::String: A descriptive message explaining the nature of the incorrect argument.\n\nExample\n\njulia> throw(IncorrectArgument(\"the argument must be a non-empty tuple\"))\nERROR: IncorrectArgument: the argument must be a non-empty tuple\n\n\n\n\n\n","category":"type"},{"location":"exception.html#CTBase.IncorrectMethod","page":"Exception","title":"CTBase.IncorrectMethod","text":"struct IncorrectMethod <: CTBase.CTException\n\nException thrown when a specified method name or function symbol does not exist.\n\nFields\n\nvar::Symbol: The method or function symbol that was expected but not found.\n\nExample\n\njulia> throw(IncorrectMethod(:nonexistent_func))\nERROR: IncorrectMethod: nonexistent_func is not an existing method\n\n\n\n\n\n","category":"type"},{"location":"exception.html#CTBase.IncorrectOutput","page":"Exception","title":"CTBase.IncorrectOutput","text":"struct IncorrectOutput <: CTBase.CTException\n\nException thrown when the output produced by a function is incorrect or inconsistent with expected results.\n\nFields\n\nvar::String: A descriptive message explaining the incorrect output.\n\nExample\n\njulia> throw(IncorrectOutput(\"the function returned NaN\"))\nERROR: IncorrectOutput: the function returned NaN\n\n\n\n\n\n","category":"type"},{"location":"exception.html#CTBase.NotImplemented","page":"Exception","title":"CTBase.NotImplemented","text":"struct NotImplemented <: CTBase.CTException\n\nException thrown when a method or function has not been implemented yet.\n\nFields\n\nvar::String: A message indicating what functionality is not yet implemented.\n\nExample\n\njulia> throw(NotImplemented(\"feature X is not implemented\"))\nERROR: NotImplemented: feature X is not implemented\n\n\n\n\n\n","category":"type"},{"location":"exception.html#CTBase.ParsingError","page":"Exception","title":"CTBase.ParsingError","text":"struct ParsingError <: CTBase.CTException\n\nException thrown during parsing when a syntax error or invalid structure is detected.\n\nFields\n\nvar::String: A message describing the parsing error.\n\nExample\n\njulia> throw(ParsingError(\"unexpected token\"))\nERROR: ParsingError: unexpected token\n\n\n\n\n\n","category":"type"},{"location":"exception.html#CTBase.UnauthorizedCall","page":"Exception","title":"CTBase.UnauthorizedCall","text":"struct UnauthorizedCall <: CTBase.CTException\n\nException thrown when a function call is not authorized in the current context or with the given arguments.\n\nFields\n\nvar::String: A message explaining why the call is unauthorized.\n\nExample\n\njulia> throw(UnauthorizedCall(\"user does not have permission\"))\nERROR: UnauthorizedCall: user does not have permission\n\n\n\n\n\n","category":"type"},{"location":"exception.html#Base.showerror-Tuple{IO, CTBase.AmbiguousDescription}","page":"Exception","title":"Base.showerror","text":"showerror(io::IO, e::CTBase.AmbiguousDescription)\n\n\nCustomizes the printed message of the exception.\n\nExample\n\njulia> throw(AmbiguousDescription((:x, :y)))\nERROR: AmbiguousDescription: the description (:x, :y) is ambiguous / incorrect\n\n\n\n\n\n","category":"method"},{"location":"exception.html#Base.showerror-Tuple{IO, CTBase.ExtensionError}","page":"Exception","title":"Base.showerror","text":"showerror(io::IO, e::CTBase.ExtensionError)\n\n\nCustomizes the printed message of the exception, prompting the user to load the required extensions.\n\nExample\n\njulia> e = ExtensionError(:MyExtension, :AnotherDep)\njulia> showerror(stdout, e)\nERROR: ExtensionError. Please make: julia> using MyExtension, AnotherDep\n\n\n\n\n\n","category":"method"},{"location":"exception.html#Base.showerror-Tuple{IO, CTBase.IncorrectArgument}","page":"Exception","title":"Base.showerror","text":"showerror(io::IO, e::CTBase.IncorrectArgument)\n\n\nCustomizes the printed message of the exception.\n\n\n\n\n\n","category":"method"},{"location":"exception.html#Base.showerror-Tuple{IO, CTBase.IncorrectMethod}","page":"Exception","title":"Base.showerror","text":"showerror(io::IO, e::CTBase.IncorrectMethod)\n\n\nCustomizes the printed message of the exception.\n\n\n\n\n\n","category":"method"},{"location":"exception.html#Base.showerror-Tuple{IO, CTBase.IncorrectOutput}","page":"Exception","title":"Base.showerror","text":"showerror(io::IO, e::CTBase.IncorrectOutput)\n\n\nCustomizes the printed message of the exception.\n\n\n\n\n\n","category":"method"},{"location":"exception.html#Base.showerror-Tuple{IO, CTBase.NotImplemented}","page":"Exception","title":"Base.showerror","text":"showerror(io::IO, e::CTBase.NotImplemented)\n\n\nCustomizes the printed message of the exception.\n\n\n\n\n\n","category":"method"},{"location":"exception.html#Base.showerror-Tuple{IO, CTBase.ParsingError}","page":"Exception","title":"Base.showerror","text":"showerror(io::IO, e::CTBase.ParsingError)\n\n\nCustomizes the printed message of the exception.\n\n\n\n\n\n","category":"method"},{"location":"exception.html#Base.showerror-Tuple{IO, CTBase.UnauthorizedCall}","page":"Exception","title":"Base.showerror","text":"showerror(io::IO, e::CTBase.UnauthorizedCall)\n\n\nCustomizes the printed message of the exception.\n\n\n\n\n\n","category":"method"},{"location":"exception.html","page":"Exception","title":"Exception","text":"","category":"page"},{"location":"ctbase.html#CTBase","page":"CTBase","title":"CTBase","text":"","category":"section"},{"location":"ctbase.html#Index","page":"CTBase","title":"Index","text":"","category":"section"},{"location":"ctbase.html","page":"CTBase","title":"CTBase","text":"Pages   = [\"ctbase.md\"]\nModules = [CTBase]\nOrder = [:module, :constant, :type, :function, :macro]","category":"page"},{"location":"ctbase.html#Documentation","page":"CTBase","title":"Documentation","text":"","category":"section"},{"location":"ctbase.html#CTBase.AbstractDocstringsAppTag","page":"CTBase","title":"CTBase.AbstractDocstringsAppTag","text":"abstract type AbstractDocstringsAppTag\n\nAbstract supertype for identifying different kinds of docstring application tags.\n\nUsed as a dispatch mechanism to select the appropriate implementation for a docstrings-related application.\n\nExample\n\njulia> CTBase.AbstractDocstringsAppTag <: AbstractDocstringsAppTag\ntrue\n\n\n\n\n\n","category":"type"},{"location":"ctbase.html#CTBase.DocstringsAppTag","page":"CTBase","title":"CTBase.DocstringsAppTag","text":"struct DocstringsAppTag <: CTBase.AbstractDocstringsAppTag\n\nConcrete tag type used to identify the Julia Docstrings Generator application.\n\nFields\n\nThis struct has no fields.\n\nExample\n\njulia> tag = DocstringsAppTag()\nDocstringsAppTag()\n\n\n\n\n\n","category":"type"},{"location":"ctbase.html#CTBase.ctNumber","page":"CTBase","title":"CTBase.ctNumber","text":"Type alias for a real number.\n\njulia> const ctNumber = Real\n\n\n\n\n\n","category":"type"},{"location":"ctbase.html","page":"CTBase","title":"CTBase","text":"","category":"page"},{"location":"default.html#Default","page":"Default","title":"Default","text":"","category":"section"},{"location":"default.html#Index","page":"Default","title":"Index","text":"","category":"section"},{"location":"default.html","page":"Default","title":"Default","text":"Pages   = [\"default.md\"]\nModules = [CTBase]\nOrder = [:module, :constant, :type, :function, :macro]","category":"page"},{"location":"default.html#Documentation","page":"Default","title":"Documentation","text":"","category":"section"},{"location":"default.html#CTBase.__display-Tuple{}","page":"Default","title":"CTBase.__display","text":"__display() -> Bool\n\n\nReturns the default value for the display flag.\n\nThis function is used internally to determine whether output should be printed during execution.\n\nReturns\n\n::Bool: The default value true, indicating that output is displayed.\n\nExample\n\njulia> __display()\ntrue\n\n\n\n\n\n","category":"method"},{"location":"default.html","page":"Default","title":"Default","text":"","category":"page"},{"location":"index.html#CTBase.jl","page":"Introduction","title":"CTBase.jl","text":"","category":"section"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"The CTBase.jl package is part of the control-toolbox ecosystem.","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"The root package is OptimalControl.jl which aims to provide tools to model and solve optimal control problems with ordinary differential equations by direct and indirect methods, both on CPU and GPU.","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"API Documentation","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"Pages = Main.API_PAGES\nDepth = 1","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"","category":"page"},{"location":"docstrings.html#Docstrings-generation","page":"Docstrings generation","title":"Docstrings generation","text":"","category":"section"},{"location":"docstrings.html#Index","page":"Docstrings generation","title":"Index","text":"","category":"section"},{"location":"docstrings.html","page":"Docstrings generation","title":"Docstrings generation","text":"Pages   = [\"docstrings.md\"]\nModules = [CTBaseDocstrings]\nOrder = [:module, :constant, :type, :function, :macro]","category":"page"},{"location":"docstrings.html","page":"Docstrings generation","title":"Docstrings generation","text":"warning: Warning\nIn the examples in the documentation below, the methods are not prefixed by the module name even if they are private. julia> using CTBase\njulia> x = 1\njulia> private_fun(x) # throw an errormust be replaced byjulia> using CTBase\njulia> x = 1\njulia> CTBase.private_fun(x)However, if the method is reexported by another package, then, there is no need of prefixing.julia> module OptimalControl\n           import CTBase: private_fun\n           export private_fun\n       end\njulia> using OptimalControl\njulia> x = 1\njulia> private_fun(x)","category":"page"},{"location":"docstrings.html#Documentation","page":"Docstrings generation","title":"Documentation","text":"","category":"section"},{"location":"docstrings.html#CTBase.doc_app-Tuple{CTBase.DocstringsAppTag}","page":"Docstrings generation","title":"CTBase.doc_app","text":"doc_app(_::CTBase.DocstringsAppTag)\n\n\nLaunches the Julia Docstrings Generator web app on localhost.\n\nStarts an HTTP server on port 8080 and prints the local URL for access.\n\nArguments\n\n::CTBase.DocstringsAppTag: A dispatch tag used to identify this application.\n\nReturns\n\nnothing: This function runs the server and does not return a result.\n\nExample\n\njulia> CTBase.doc_app(CTBase.DocstringsAppTag())\nOpen http://localhost:8080 in your browser.\n\n\n\n\n\n","category":"method"},{"location":"docstrings.html#CTBaseDocstrings.handled_doc_app-Tuple{Any}","page":"Docstrings generation","title":"CTBaseDocstrings.handled_doc_app","text":"handled_doc_app(req) -> HTTP.Messages.Response\n\n\nHandles HTTP requests to serve the web app interface, process user-submitted code, and shut down the server.\n\nArguments\n\nreq: An HTTP request object representing an incoming request to the server.\n\nReturns\n\nresponse::HTTP.Response: An appropriate HTTP response depending on the request path and method.\n\nExample\n\njulia> using HTTP\njulia> req = HTTP.Request(\"GET\", \"/\");\njulia> resp = handled_doc_app(req)\nHTTP.Response(200 OK)\n\n\n\n\n\n","category":"method"},{"location":"docstrings.html#CTBaseDocstrings.html_code_doc_app-Tuple{}","page":"Docstrings generation","title":"CTBaseDocstrings.html_code_doc_app","text":"html_code_doc_app() -> String\n\n\nReturns the HTML string for the Julia Docstrings Prompt Generator web app.\n\nThis HTML includes the structure, layout, and style definitions required for a client-side interface with dark/light mode support, tabs for input areas, and interactive elements.\n\nReturns\n\nhtml::String: A complete HTML string to be served as the main page of the application.\n\nExample\n\njulia> html = html_code_doc_app();\njulia> occursin(\"DOCTYPE html\", html)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"docstrings.html#CTBase.docstrings-Tuple{String}","page":"Docstrings generation","title":"CTBase.docstrings","text":"docstrings(\n    path::String;\n    tests,\n    context,\n    apikey\n) -> Tuple{Vector{Any}, String}\n\n\nSends code and optional context to the Mistral API and extracts generated docstrings.\n\nArguments\n\npath::String: Path to the Julia source file.\ntests: Optional path to a test file (default nothing).\ncontext: Optional path to a context file for better generation (default nothing).\napikey::String: Mistral API key (default empty).\n\nReturns\n\n(pairs, response)::Tuple{Vector{Tuple{String, String}}, String}: A tuple containing extracted docstring-code pairs and a reconstructed version of the code with inserted docstrings.\n\nExample\n\njulia> CTBase.docstrings(\"example.jl\", apikey=\"sk-...\")\n([(\"Docstring\", \"function f(x) ... end\")], \"...full reconstructed text...\")\n\n\n\n\n\n","category":"method"},{"location":"docstrings.html#CTBaseDocstrings.code_unchanged_check-Tuple{Any, String}","page":"Docstrings generation","title":"CTBaseDocstrings.code_unchanged_check","text":"code_unchanged_check(\n    pairs,\n    original_code::String;\n    display\n) -> Int64\n\n\nChecks whether the generated docstring/code blocks altered the original code.\n\nArguments\n\npairs: A vector of (docstring, code) pairs.\noriginal_code::String: The original source code as a string.\ndisplay::Bool: Whether to display line-by-line differences if any (default true).\n\nReturns\n\ncode_changed::Int: Returns 1 if the code was changed, 0 otherwise.\n\nExample\n\njulia> code_unchanged_check([(\"doc\", \"function f() end\")], \"function f() end\")\n0\n\n\n\n\n\n","category":"method"},{"location":"docstrings.html#CTBaseDocstrings.docstrings_file-Tuple{Any}","page":"Docstrings generation","title":"CTBaseDocstrings.docstrings_file","text":"docstrings_file(path; tests, context, apikey) -> String\n\n\nGenerates a new file with inserted docstrings and saves it to disk.\n\nArguments\n\npath: Path to the source Julia file.\ntests: Optional path to test file (default nothing).\ncontext: Optional path to context file (default nothing).\napikey: API key for Mistral (default empty string).\n\nReturns\n\noutpath::String: Path to the new file with _docstrings appended to the original filename.\n\nExample\n\njulia> docstrings_file(\"myfile.jl\", apikey=\"sk-...\")\n\"myfile_docstrings.jl\"\n\n\n\n\n\n","category":"method"},{"location":"docstrings.html#CTBaseDocstrings.extract_docstring_code_pairs-Tuple{String}","page":"Docstrings generation","title":"CTBaseDocstrings.extract_docstring_code_pairs","text":"extract_docstring_code_pairs(\n    ai_text::String\n) -> Tuple{Vector{Any}, String}\n\n\nExtracts pairs of docstrings and code blocks from the given AI-generated text.\n\nArguments\n\nai_text::String: The full string response from the AI, possibly containing multiple docstring-code pairs.\n\nReturns\n\n(pairs, reponse)::Tuple{Vector{Tuple{String,String}}, String}: A tuple containing a vector of (docstring, code) pairs and a string reconstruction with triple-quoted docstrings prepended.\n\nExample\n\njulia> text = \"\"\"\"Docstring\"\"\"\nfunction f(x)\n  x + 1\nend\n\";\njulia> extract_docstring_code_pairs(text)\n((\"Docstring\", \"function f(x)\n  x + 1\nend\"), ...)\n\n\n\n\n\n","category":"method"},{"location":"docstrings.html#CTBase.generate_prompt-Tuple{String, String, String}","page":"Docstrings generation","title":"CTBase.generate_prompt","text":"generate_prompt(\n    code_text::String,\n    tests_text::String,\n    context_text::String\n) -> String\n\n\nGenerates a well-structured and precise prompt to produce Julia docstrings in the Documenter.jl style, using provided code, tests, and context.\n\nArguments\n\ncode_text::String: The Julia code (structs and functions) to document.\ntests_text::String: Optional related tests for improving examples.\ncontext_text::String: Additional domain knowledge or technical explanation to improve doc quality.\n\nReturns\n\nprompt::String: A clear prompt ready for use with a language model like ChatGPT or Mistral.\n\nExample\n\njulia> code = \"function square(x); x^2; end\"\njulia> CTBase.generate_prompt(code, \"\", \"\")\n\"Your task is to write docstrings for the following Julia code...\"\n\n\n\n\n\n","category":"method"},{"location":"docstrings.html","page":"Docstrings generation","title":"Docstrings generation","text":"","category":"page"}]
}

var documenterSearchIndex = {"docs":
[{"location":"coverage_postprocessing.html#Private-API","page":"CoveragePostprocessing","title":"Private API","text":"This page lists non-exported (internal) symbols of CoveragePostprocessing.\n\n","category":"section"},{"location":"coverage_postprocessing.html#From-CoveragePostprocessing","page":"CoveragePostprocessing","title":"From CoveragePostprocessing","text":"","category":"section"},{"location":"coverage_postprocessing.html#_clean_stale_cov_files!","page":"CoveragePostprocessing","title":"_clean_stale_cov_files!","text":"","category":"section"},{"location":"coverage_postprocessing.html#_collect_and_move_cov_files!","page":"CoveragePostprocessing","title":"_collect_and_move_cov_files!","text":"","category":"section"},{"location":"coverage_postprocessing.html#_count_cov_files","page":"CoveragePostprocessing","title":"_count_cov_files","text":"","category":"section"},{"location":"coverage_postprocessing.html#_generate_coverage_reports!","page":"CoveragePostprocessing","title":"_generate_coverage_reports!","text":"","category":"section"},{"location":"coverage_postprocessing.html#_reset_coverage_dir","page":"CoveragePostprocessing","title":"_reset_coverage_dir","text":"","category":"section"},{"location":"coverage_postprocessing.html#CTBase.postprocess_coverage","page":"CoveragePostprocessing","title":"CTBase.postprocess_coverage","text":"","category":"section"},{"location":"coverage_postprocessing.html#CoveragePostprocessing._clean_stale_cov_files!","page":"CoveragePostprocessing","title":"CoveragePostprocessing._clean_stale_cov_files!","text":"_clean_stale_cov_files!(source_dirs)\n\nInternal helper that removes stale .cov files from source_dirs.\n\nIf multiple runs are detected (PID suffix in filenames), this function keeps the PID with the largest number of .cov files and removes the others.\n\n\n\n\n\n","category":"function"},{"location":"coverage_postprocessing.html#CoveragePostprocessing._collect_and_move_cov_files!","page":"CoveragePostprocessing","title":"CoveragePostprocessing._collect_and_move_cov_files!","text":"_collect_and_move_cov_files!(source_dirs, dest_dir) -> Vector{String}\n\nInternal helper that moves all .cov files from source_dirs into dest_dir.\n\nReturns a vector of destination paths for the moved files.\n\n\n\n\n\n","category":"function"},{"location":"coverage_postprocessing.html#CoveragePostprocessing._count_cov_files","page":"CoveragePostprocessing","title":"CoveragePostprocessing._count_cov_files","text":"_count_cov_files(source_dirs) -> Int\n\nInternal helper that counts the number of .cov files in the provided directories.\n\n\n\n\n\n","category":"function"},{"location":"coverage_postprocessing.html#CoveragePostprocessing._generate_coverage_reports!","page":"CoveragePostprocessing","title":"CoveragePostprocessing._generate_coverage_reports!","text":"_generate_coverage_reports!(source_dirs, coverage_dir, root_dir)\n\nInternal helper that generates coverage reports from .cov files.\n\nWrites:\n\ncoverage/lcov.info\ncoverage/cov_report.md\n\n\n\n\n\n","category":"function"},{"location":"coverage_postprocessing.html#CoveragePostprocessing._reset_coverage_dir","page":"CoveragePostprocessing","title":"CoveragePostprocessing._reset_coverage_dir","text":"_reset_coverage_dir(coverage_dir, cov_storage_dir)\n\nInternal helper that recreates the coverage/ directory structure.\n\nThis function removes coverage_dir (recursively) if it already exists, then creates cov_storage_dir.\n\n\n\n\n\n","category":"function"},{"location":"coverage_postprocessing.html#CTBase.postprocess_coverage-Tuple{CTBase.CoveragePostprocessingTag}","page":"CoveragePostprocessing","title":"CTBase.postprocess_coverage","text":"CTBase.postprocess_coverage(::CTBase.CoveragePostprocessingTag; generate_report::Bool=true, root_dir::String=pwd())\n\nPost-process coverage artifacts produced by Pkg.test(; coverage=true).\n\nThis implementation:\n\nCollects coverage source directories under root_dir (src/, test/, ext/ when present)\nResets the coverage/ directory\nRemoves stale .cov files (keeping the most complete PID suffix when multiple runs exist)\nOptionally generates reports (LCOV + markdown report)\nMoves .cov files into coverage/cov/ (recursively from source dirs)\n\nKeyword Arguments\n\ngenerate_report::Bool=true: If true, write coverage/lcov.info and coverage/cov_report.md.\nroot_dir::String=pwd(): Root directory of the project.\n\nReturns\n\nNothing\n\nNotes\n\nThis function creates/removes/moves files and directories under root_dir.\n\nUsage sketch (non-executed)\n\nusing CTBase\n\n# CTBase.postprocess_coverage(; generate_report=true, root_dir=pwd())\n\n\n\n\n\n","category":"method"},{"location":"description.html#Private-API","page":"Description","title":"Private API","text":"This page lists non-exported (internal) symbols of CTBase.\n\n","category":"section"},{"location":"description.html#From-CTBase","page":"Description","title":"From CTBase","text":"","category":"section"},{"location":"description.html#DescVarArg","page":"Description","title":"DescVarArg","text":"","category":"section"},{"location":"description.html#Description","page":"Description","title":"Description","text":"","category":"section"},{"location":"description.html#add","page":"Description","title":"add","text":"","category":"section"},{"location":"description.html#complete","page":"Description","title":"complete","text":"","category":"section"},{"location":"description.html#remove","page":"Description","title":"remove","text":"","category":"section"},{"location":"description.html#CTBase.DescVarArg","page":"Description","title":"CTBase.DescVarArg","text":"DescVarArg is a type alias representing a variable number of Symbols.\n\njulia> using CTBase\n\njulia> CTBase.DescVarArg\nVararg{Symbol}\n\nSee also: CTBase.Description.\n\n\n\n\n\n","category":"constant"},{"location":"description.html#CTBase.Description","page":"Description","title":"CTBase.Description","text":"A description is a tuple of symbols. Description is a type alias for a tuple of symbols.\n\nSee also: DescVarArg.\n\nExample\n\nBase.show is overloaded for descriptions, so tuples of descriptions are printed one per line:\n\njulia> using CTBase\n\njulia> display(((:a, :b), (:b, :c)))\n(:a, :b)\n(:b, :c)\n\n\n\n\n\n","category":"type"},{"location":"description.html#CTBase.add","page":"Description","title":"CTBase.add","text":"add(\n    _::Tuple{},\n    y::Tuple{Vararg{Symbol}}\n) -> Tuple{Tuple{Vararg{Symbol}}}\n\n\nReturn a tuple containing only the description y.\n\nExample\n\njulia> using CTBase\n\njulia> descriptions = ()\njulia> descriptions = CTBase.add(descriptions, (:a,))\n(:a,)\njulia> print(descriptions)\n((:a,),)\njulia> descriptions[1]\n(:a,)\n\n\n\n\n\nadd(\n    x::Tuple{Vararg{Tuple{Vararg{Symbol}}}},\n    y::Tuple{Vararg{Symbol}}\n) -> Tuple{Tuple{Vararg{Symbol}}}\n\n\nAdd the description y to the tuple of descriptions x if x does not contain y and return the new tuple of descriptions. \n\nThrow an exception (IncorrectArgument) if the description y is already contained in x.\n\nExample\n\njulia> using CTBase\n\njulia> descriptions = ()\njulia> descriptions = CTBase.add(descriptions, (:a,))\n(:a,)\njulia> descriptions = CTBase.add(descriptions, (:b,))\n(:a,)\n(:b,)\njulia> descriptions = CTBase.add(descriptions, (:b,))\nERROR: IncorrectArgument: the description (:b,) is already in ((:a,), (:b,))\n\n\n\n\n\n","category":"function"},{"location":"description.html#CTBase.complete","page":"Description","title":"CTBase.complete","text":"complete(list::Symbol...; descriptions)\n\n\nReturn one description from a list of Symbols list and a set of descriptions D.  If multiple descriptions are possible, then the first one is selected.\n\nIf the list is not contained in any of the descriptions, then an exception is thrown.\n\nExample\n\njulia> using CTBase\n\njulia> D = ((:a, :b), (:a, :b, :c), (:b, :c), (:a, :c))\n(:a, :b)\n(:b, :c)\n(:a, :c)\njulia> CTBase.complete(:a; descriptions=D)\n(:a, :b)\njulia> CTBase.complete(:a, :c; descriptions=D)\n(:a, :b, :c)\njulia> CTBase.complete((:a, :c); descriptions=D)\n(:a, :b, :c)\njulia> CTBase.complete(:f; descriptions=D)\nERROR: AmbiguousDescription: the description (:f,) is ambiguous / incorrect\n\n\n\n\n\ncomplete(list::Tuple{Vararg{Symbol}}; descriptions)\n\n\nConvenience overload of complete for tuple inputs.\n\nThis method is equivalent to complete(list...; descriptions=descriptions).\n\nArguments\n\nlist::Tuple{Vararg{Symbol}}: A tuple of symbols representing a partial description.\n\nKeyword Arguments\n\ndescriptions::Tuple{Vararg{Description}}: Candidate descriptions used for completion.\n\nReturns\n\nDescription: A description from descriptions that contains all symbols in list.\n\nThrows\n\nAmbiguousDescription: If descriptions is empty, or if list is not contained in any candidate description.\n\n\n\n\n\n","category":"function"},{"location":"description.html#CTBase.remove","page":"Description","title":"CTBase.remove","text":"remove(\n    x::Tuple{Vararg{Symbol}},\n    y::Tuple{Vararg{Symbol}}\n) -> Tuple{Vararg{Symbol}}\n\n\nReturn the difference between the description x and the description y.\n\nExample\n\njulia> using CTBase\n\njulia> CTBase.remove((:a, :b), (:a,))\n(:b,)\n\n\n\n\n\n","category":"function"},{"location":"exception.html#Private-API","page":"Exception","title":"Private API","text":"This page lists non-exported (internal) symbols of CTBase.\n\n","category":"section"},{"location":"exception.html#From-CTBase","page":"Exception","title":"From CTBase","text":"","category":"section"},{"location":"exception.html#AmbiguousDescription","page":"Exception","title":"AmbiguousDescription","text":"","category":"section"},{"location":"exception.html#CTException","page":"Exception","title":"CTException","text":"","category":"section"},{"location":"exception.html#ExtensionError","page":"Exception","title":"ExtensionError","text":"","category":"section"},{"location":"exception.html#IncorrectArgument","page":"Exception","title":"IncorrectArgument","text":"","category":"section"},{"location":"exception.html#NotImplemented","page":"Exception","title":"NotImplemented","text":"","category":"section"},{"location":"exception.html#ParsingError","page":"Exception","title":"ParsingError","text":"","category":"section"},{"location":"exception.html#UnauthorizedCall","page":"Exception","title":"UnauthorizedCall","text":"","category":"section"},{"location":"exception.html#Base.showerror","page":"Exception","title":"Base.showerror","text":"","category":"section"},{"location":"exception.html#Base.showerror-2","page":"Exception","title":"Base.showerror","text":"","category":"section"},{"location":"exception.html#Base.showerror-3","page":"Exception","title":"Base.showerror","text":"","category":"section"},{"location":"exception.html#Base.showerror-4","page":"Exception","title":"Base.showerror","text":"","category":"section"},{"location":"exception.html#Base.showerror-5","page":"Exception","title":"Base.showerror","text":"","category":"section"},{"location":"exception.html#Base.showerror-6","page":"Exception","title":"Base.showerror","text":"","category":"section"},{"location":"exception.html#CTBase.AmbiguousDescription","page":"Exception","title":"CTBase.AmbiguousDescription","text":"struct AmbiguousDescription <: CTBase.CTException\n\nException thrown when a description is ambiguous or does not match any known descriptions.\n\nFields\n\nvar::Tuple{Vararg{Symbol}}: The ambiguous or incorrect description tuple that caused the error.\n\nExample\n\njulia> using CTBase\n\njulia> CTBase.complete(:f; descriptions=((:a, :b), (:a, :b, :c)))\nERROR: AmbiguousDescription: the description (:f,) is ambiguous / incorrect\n\nThis error is useful to signal when a user provides a description that cannot be matched to any known valid descriptions.\n\n\n\n\n\n","category":"type"},{"location":"exception.html#CTBase.CTException","page":"Exception","title":"CTBase.CTException","text":"abstract type CTException <: Exception\n\nAbstract supertype for all custom exceptions in this module.\n\nUse this as the common ancestor for all domain-specific errors to allow catching all exceptions of this family via catch e::CTException.\n\nNo fields.\n\nExample\n\njulia> using CTBase\n\njulia> try\n           throw(CTBase.IncorrectArgument(\"invalid input\"))\n       catch e::CTBase.CTException\n           println(\"Caught a domain-specific exception: \", e)\n       end\nCaught a domain-specific exception: IncorrectArgument: invalid input\n\n\n\n\n\n","category":"type"},{"location":"exception.html#CTBase.ExtensionError","page":"Exception","title":"CTBase.ExtensionError","text":"struct ExtensionError <: CTBase.CTException\n\nException thrown when an extension or optional dependency is not loaded but a function requiring it is called.\n\nFields\n\nweakdeps::Tuple{Vararg{Symbol}}: The tuple of symbols representing the missing dependencies.\n\nConstructor\n\nThrows UnauthorizedCall if no weak dependencies are provided.\n\nExample\n\njulia> using CTBase\n\njulia> throw(CTBase.ExtensionError(:MyExtension))\nERROR: ExtensionError. Please make: julia> using MyExtension\n\n\n\n\n\n","category":"type"},{"location":"exception.html#CTBase.IncorrectArgument","page":"Exception","title":"CTBase.IncorrectArgument","text":"struct IncorrectArgument <: CTBase.CTException\n\nException thrown when an argument passed to a function or constructor is inconsistent, invalid, or does not satisfy preconditions.\n\nFields\n\nvar::String: A descriptive message explaining the nature of the incorrect argument.\n\nExample\n\njulia> using CTBase\n\njulia> throw(CTBase.IncorrectArgument(\"the argument must be a non-empty tuple\"))\nERROR: IncorrectArgument: the argument must be a non-empty tuple\n\n\n\n\n\n","category":"type"},{"location":"exception.html#CTBase.NotImplemented","page":"Exception","title":"CTBase.NotImplemented","text":"struct NotImplemented <: CTBase.CTException\n\nException thrown when a method or function has not been implemented yet.\n\nFields\n\nvar::String: A message indicating what functionality is not yet implemented.\n\nExample\n\njulia> using CTBase\n\njulia> throw(CTBase.NotImplemented(\"feature X is not implemented\"))\nERROR: NotImplemented: feature X is not implemented\n\n\n\n\n\n","category":"type"},{"location":"exception.html#CTBase.ParsingError","page":"Exception","title":"CTBase.ParsingError","text":"struct ParsingError <: CTBase.CTException\n\nException thrown during parsing when a syntax error or invalid structure is detected.\n\nFields\n\nvar::String: A message describing the parsing error.\n\nExample\n\njulia> using CTBase\n\njulia> throw(CTBase.ParsingError(\"unexpected token\"))\nERROR: ParsingError: unexpected token\n\n\n\n\n\n","category":"type"},{"location":"exception.html#CTBase.UnauthorizedCall","page":"Exception","title":"CTBase.UnauthorizedCall","text":"struct UnauthorizedCall <: CTBase.CTException\n\nException thrown when a function call is not authorized in the current context or with the given arguments.\n\nFields\n\nvar::String: A message explaining why the call is unauthorized.\n\nExample\n\njulia> using CTBase\n\njulia> throw(CTBase.UnauthorizedCall(\"user does not have permission\"))\nERROR: UnauthorizedCall: user does not have permission\n\n\n\n\n\n","category":"type"},{"location":"exception.html#Base.showerror-Tuple{IO, CTBase.ParsingError}","page":"Exception","title":"Base.showerror","text":"showerror(io::IO, e::CTBase.ParsingError)\n\n\nCustomizes the printed message of the exception.\n\n\n\n\n\n","category":"method"},{"location":"exception.html#Base.showerror-Tuple{IO, CTBase.UnauthorizedCall}","page":"Exception","title":"Base.showerror","text":"showerror(io::IO, e::CTBase.UnauthorizedCall)\n\n\nCustomizes the printed message of the exception.\n\n\n\n\n\n","category":"method"},{"location":"exception.html#Base.showerror-Tuple{IO, CTBase.AmbiguousDescription}","page":"Exception","title":"Base.showerror","text":"showerror(io::IO, e::CTBase.AmbiguousDescription)\n\n\nCustomizes the printed message of the exception.\n\nExample\n\njulia> using CTBase\n\njulia> throw(CTBase.AmbiguousDescription((:x, :y)))\nERROR: AmbiguousDescription: the description (:x, :y) is ambiguous / incorrect\n\n\n\n\n\n","category":"method"},{"location":"exception.html#Base.showerror-Tuple{IO, CTBase.NotImplemented}","page":"Exception","title":"Base.showerror","text":"showerror(io::IO, e::CTBase.NotImplemented)\n\n\nCustomizes the printed message of the exception.\n\n\n\n\n\n","category":"method"},{"location":"exception.html#Base.showerror-Tuple{IO, CTBase.IncorrectArgument}","page":"Exception","title":"Base.showerror","text":"showerror(io::IO, e::CTBase.IncorrectArgument)\n\n\nCustomizes the printed message of the exception.\n\n\n\n\n\n","category":"method"},{"location":"exception.html#Base.showerror-Tuple{IO, CTBase.ExtensionError}","page":"Exception","title":"Base.showerror","text":"showerror(io::IO, e::CTBase.ExtensionError)\n\n\nCustomizes the printed message of the exception, prompting the user to load the required extensions.\n\nExample\n\njulia> using CTBase\n\njulia> e = CTBase.ExtensionError(:MyExtension, :AnotherDep)\njulia> showerror(stdout, e)\nERROR: ExtensionError. Please make: julia> using MyExtension, AnotherDep\n\n\n\n\n\n","category":"method"},{"location":"documenter_reference.html#Private-API","page":"DocumenterReference","title":"Private API","text":"This page lists non-exported (internal) symbols of DocumenterReference.\n\n","category":"section"},{"location":"documenter_reference.html#From-DocumenterReference","page":"DocumenterReference","title":"From DocumenterReference","text":"","category":"section"},{"location":"documenter_reference.html#APIBuilder","page":"DocumenterReference","title":"APIBuilder","text":"","category":"section"},{"location":"documenter_reference.html#CONFIG","page":"DocumenterReference","title":"CONFIG","text":"","category":"section"},{"location":"documenter_reference.html#DOCTYPE_NAMES","page":"DocumenterReference","title":"DOCTYPE_NAMES","text":"","category":"section"},{"location":"documenter_reference.html#DOCTYPE_ORDER","page":"DocumenterReference","title":"DOCTYPE_ORDER","text":"","category":"section"},{"location":"documenter_reference.html#DocType","page":"DocumenterReference","title":"DocType","text":"","category":"section"},{"location":"documenter_reference.html#PAGE_CONTENT_ACCUMULATOR","page":"DocumenterReference","title":"PAGE_CONTENT_ACCUMULATOR","text":"","category":"section"},{"location":"documenter_reference.html#_Config","page":"DocumenterReference","title":"_Config","text":"","category":"section"},{"location":"documenter_reference.html#_build_api_page","page":"DocumenterReference","title":"_build_api_page","text":"","category":"section"},{"location":"documenter_reference.html#_build_page_path","page":"DocumenterReference","title":"_build_page_path","text":"","category":"section"},{"location":"documenter_reference.html#_build_page_return_structure","page":"DocumenterReference","title":"_build_page_return_structure","text":"","category":"section"},{"location":"documenter_reference.html#_build_private_page_content","page":"DocumenterReference","title":"_build_private_page_content","text":"","category":"section"},{"location":"documenter_reference.html#_build_public_page_content","page":"DocumenterReference","title":"_build_public_page_content","text":"","category":"section"},{"location":"documenter_reference.html#_classify_symbol","page":"DocumenterReference","title":"_classify_symbol","text":"","category":"section"},{"location":"documenter_reference.html#_collect_external_module_docstrings","page":"DocumenterReference","title":"_collect_external_module_docstrings","text":"","category":"section"},{"location":"documenter_reference.html#_collect_methods_from_source_files","page":"DocumenterReference","title":"_collect_methods_from_source_files","text":"","category":"section"},{"location":"documenter_reference.html#_collect_module_docstrings","page":"DocumenterReference","title":"_collect_module_docstrings","text":"","category":"section"},{"location":"documenter_reference.html#_collect_private_docstrings","page":"DocumenterReference","title":"_collect_private_docstrings","text":"","category":"section"},{"location":"documenter_reference.html#_default_basename","page":"DocumenterReference","title":"_default_basename","text":"","category":"section"},{"location":"documenter_reference.html#_default_title","page":"DocumenterReference","title":"_default_title","text":"","category":"section"},{"location":"documenter_reference.html#_exported_symbols","page":"DocumenterReference","title":"_exported_symbols","text":"","category":"section"},{"location":"documenter_reference.html#_finalize_api_pages","page":"DocumenterReference","title":"_finalize_api_pages","text":"","category":"section"},{"location":"documenter_reference.html#_format_datatype_for_docs","page":"DocumenterReference","title":"_format_datatype_for_docs","text":"","category":"section"},{"location":"documenter_reference.html#_format_type_for_docs","page":"DocumenterReference","title":"_format_type_for_docs","text":"","category":"section"},{"location":"documenter_reference.html#_format_type_param","page":"DocumenterReference","title":"_format_type_param","text":"","category":"section"},{"location":"documenter_reference.html#_get_effective_source_files","page":"DocumenterReference","title":"_get_effective_source_files","text":"","category":"section"},{"location":"documenter_reference.html#_get_source_file","page":"DocumenterReference","title":"_get_source_file","text":"","category":"section"},{"location":"documenter_reference.html#_get_source_from_docstring","page":"DocumenterReference","title":"_get_source_from_docstring","text":"","category":"section"},{"location":"documenter_reference.html#_get_source_from_methods","page":"DocumenterReference","title":"_get_source_from_methods","text":"","category":"section"},{"location":"documenter_reference.html#_has_documentation","page":"DocumenterReference","title":"_has_documentation","text":"","category":"section"},{"location":"documenter_reference.html#_iterate_over_symbols","page":"DocumenterReference","title":"_iterate_over_symbols","text":"","category":"section"},{"location":"documenter_reference.html#_method_signature_string","page":"DocumenterReference","title":"_method_signature_string","text":"","category":"section"},{"location":"documenter_reference.html#_normalize_paths","page":"DocumenterReference","title":"_normalize_paths","text":"","category":"section"},{"location":"documenter_reference.html#_parse_primary_modules","page":"DocumenterReference","title":"_parse_primary_modules","text":"","category":"section"},{"location":"documenter_reference.html#_passes_source_filter","page":"DocumenterReference","title":"_passes_source_filter","text":"","category":"section"},{"location":"documenter_reference.html#_register_config","page":"DocumenterReference","title":"_register_config","text":"","category":"section"},{"location":"documenter_reference.html#_to_string","page":"DocumenterReference","title":"_to_string","text":"","category":"section"},{"location":"documenter_reference.html#reset_config!","page":"DocumenterReference","title":"reset_config!","text":"","category":"section"},{"location":"documenter_reference.html#CTBase.automatic_reference_documentation","page":"DocumenterReference","title":"CTBase.automatic_reference_documentation","text":"","category":"section"},{"location":"documenter_reference.html#DocumenterReference.APIBuilder","page":"DocumenterReference","title":"DocumenterReference.APIBuilder","text":"APIBuilder <: Documenter.Builder.DocumentPipeline\n\nCustom Documenter pipeline stage for automatic API reference generation.\n\nThis builder is inserted into the Documenter pipeline at order 0.0 (before most other stages) to generate API reference pages from the configurations stored in CONFIG.\n\n\n\n\n\n","category":"type"},{"location":"documenter_reference.html#DocumenterReference.CONFIG","page":"DocumenterReference","title":"DocumenterReference.CONFIG","text":"CONFIG::Vector{_Config}\n\nGlobal configuration storage for API reference generation.\n\nEach call to automatic_reference_documentation appends a new _Config entry to this vector. Use reset_config! to clear it between builds.\n\n\n\n\n\n","category":"constant"},{"location":"documenter_reference.html#DocumenterReference.DOCTYPE_NAMES","page":"DocumenterReference","title":"DocumenterReference.DOCTYPE_NAMES","text":"DOCTYPE_NAMES::Dict{DocType, String}\n\nMapping from DocType enum values to their human-readable string representations.\n\n\n\n\n\n","category":"constant"},{"location":"documenter_reference.html#DocumenterReference.DOCTYPE_ORDER","page":"DocumenterReference","title":"DocumenterReference.DOCTYPE_ORDER","text":"DOCTYPE_ORDER::Dict{DocType, Int}\n\nOrdering for DocType values used when sorting symbols for display. Lower values appear first.\n\n\n\n\n\n","category":"constant"},{"location":"documenter_reference.html#DocumenterReference.DocType","page":"DocumenterReference","title":"DocumenterReference.DocType","text":"DocType\n\nEnumeration of documentation element types recognized by the API reference generator.\n\nValues\n\nDOCTYPE_ABSTRACT_TYPE: An abstract type declaration\nDOCTYPE_CONSTANT: A constant binding (including non-function, non-type values)\nDOCTYPE_FUNCTION: A function or callable\nDOCTYPE_MACRO: A macro (name starts with @)\nDOCTYPE_MODULE: A submodule\nDOCTYPE_STRUCT: A concrete struct type\n\n\n\n\n\n","category":"type"},{"location":"documenter_reference.html#DocumenterReference.PAGE_CONTENT_ACCUMULATOR","page":"DocumenterReference","title":"DocumenterReference.PAGE_CONTENT_ACCUMULATOR","text":"PAGE_CONTENT_ACCUMULATOR::Dict{String, Vector{Tuple{Module, Vector{String}, Vector{String}}}}\n\nGlobal accumulator for multi-module combined pages. Maps output filename to a list of (module, publicdocstrings, privatedocstrings) tuples.\n\n\n\n\n\n","category":"constant"},{"location":"documenter_reference.html#DocumenterReference._Config","page":"DocumenterReference","title":"DocumenterReference._Config","text":"_Config\n\nInternal configuration for API reference generation.\n\nFields\n\ncurrent_module::Module: The module being documented.\nsubdirectory::String: Output directory for generated API pages.\nmodules::Dict{Module,Vector{String}}: Mapping of modules to their source files. When a module is specified as Module => files, the files are stored here.\nsort_by::Function: Custom sort function for symbols.\nexclude::Set{Symbol}: Symbol names to exclude from documentation.\npublic::Bool: Flag to generate public API page.\nprivate::Bool: Flag to generate private API page.\ntitle::String: Title displayed at the top of the generated page.\ntitle_in_menu::String: Title displayed in the navigation menu.\nsource_files::Vector{String}: Global source file paths (fallback if no module-specific files).\nfilename::String: Base filename (without extension) for the markdown file.\ninclude_without_source::Bool: If true, include symbols whose source file cannot be determined.\nexternal_modules_to_document::Vector{Module}: Additional modules to search for docstrings.\n\n\n\n\n\n","category":"type"},{"location":"documenter_reference.html#DocumenterReference._build_api_page","page":"DocumenterReference","title":"DocumenterReference._build_api_page","text":"_build_api_page(document::Documenter.Document, config::_Config)\n\nGenerate public and/or private API reference pages for a module. Accumulates content in PAGE_CONTENT_ACCUMULATOR for later finalization.\n\n\n\n\n\n","category":"function"},{"location":"documenter_reference.html#DocumenterReference._build_page_path","page":"DocumenterReference","title":"DocumenterReference._build_page_path","text":"_build_page_path(subdirectory::String, filename::String) -> String\n\nBuild the page path by joining subdirectory and filename. Handles special cases where subdirectory is \".\" or empty.\n\n\n\n\n\n","category":"function"},{"location":"documenter_reference.html#DocumenterReference._build_page_return_structure","page":"DocumenterReference","title":"DocumenterReference._build_page_return_structure","text":"_build_page_return_structure(title_in_menu, subdirectory, filename, public, private) -> Pair\n\nBuild the return structure for automatic_reference_documentation.\n\n\n\n\n\n","category":"function"},{"location":"documenter_reference.html#DocumenterReference._build_private_page_content","page":"DocumenterReference","title":"DocumenterReference._build_private_page_content","text":"_build_private_page_content(modules_str, module_contents) -> Tuple{String, Vector{String}}\n\nBuild the overview and docstrings for a private API page.\n\n\n\n\n\n","category":"function"},{"location":"documenter_reference.html#DocumenterReference._build_public_page_content","page":"DocumenterReference","title":"DocumenterReference._build_public_page_content","text":"_build_public_page_content(modules_str, module_contents) -> Tuple{String, Vector{String}}\n\nBuild the overview and docstrings for a public API page.\n\n\n\n\n\n","category":"function"},{"location":"documenter_reference.html#DocumenterReference._classify_symbol","page":"DocumenterReference","title":"DocumenterReference._classify_symbol","text":"_classify_symbol(obj, name_str::String) -> DocType\n\nClassify a symbol by its type (function, macro, struct, constant, module, abstract type).\n\n\n\n\n\n","category":"function"},{"location":"documenter_reference.html#DocumenterReference._collect_external_module_docstrings","page":"DocumenterReference","title":"DocumenterReference._collect_external_module_docstrings","text":"_collect_external_module_docstrings(config::_Config) -> Vector{String}\n\nCollect docstrings for methods from external modules defined in source files.\n\n\n\n\n\n","category":"function"},{"location":"documenter_reference.html#DocumenterReference._collect_methods_from_source_files","page":"DocumenterReference","title":"DocumenterReference._collect_methods_from_source_files","text":"_collect_methods_from_source_files(mod::Module, source_files::Vector{String}) -> Dict{Symbol, Vector{Method}}\n\nCollect all methods from a module that are defined in the given source files.\n\n\n\n\n\n","category":"function"},{"location":"documenter_reference.html#DocumenterReference._collect_module_docstrings","page":"DocumenterReference","title":"DocumenterReference._collect_module_docstrings","text":"_collect_module_docstrings(config::_Config, symbol_list) -> Vector{String}\n\nCollect docstring blocks for symbols from the current module.\n\n\n\n\n\n","category":"function"},{"location":"documenter_reference.html#DocumenterReference._collect_private_docstrings","page":"DocumenterReference","title":"DocumenterReference._collect_private_docstrings","text":"_collect_private_docstrings(config::_Config, symbol_list) -> Vector{String}\n\nCollect docstring blocks for private symbols, including external module methods.\n\n\n\n\n\n","category":"function"},{"location":"documenter_reference.html#DocumenterReference._default_basename","page":"DocumenterReference","title":"DocumenterReference._default_basename","text":"_default_basename(filename::String, public::Bool, private::Bool) -> String\n\nCompute the default base filename for the generated markdown file.\n\n\n\n\n\n","category":"function"},{"location":"documenter_reference.html#DocumenterReference._default_title","page":"DocumenterReference","title":"DocumenterReference._default_title","text":"_default_title(public::Bool, private::Bool) -> String\n\nCompute the default title based on public/private flags.\n\n\n\n\n\n","category":"function"},{"location":"documenter_reference.html#DocumenterReference._exported_symbols","page":"DocumenterReference","title":"DocumenterReference._exported_symbols","text":"_exported_symbols(mod::Module) -> NamedTuple\n\nClassify all symbols in a module into exported and private categories. Returns a NamedTuple with exported and private fields, each containing sorted lists of (Symbol, DocType) pairs.\n\n\n\n\n\n","category":"function"},{"location":"documenter_reference.html#DocumenterReference._finalize_api_pages","page":"DocumenterReference","title":"DocumenterReference._finalize_api_pages","text":"_finalize_api_pages(document::Documenter.Document)\n\nFinalize all accumulated API pages by combining content from multiple modules.\n\n\n\n\n\n","category":"function"},{"location":"documenter_reference.html#DocumenterReference._format_datatype_for_docs","page":"DocumenterReference","title":"DocumenterReference._format_datatype_for_docs","text":"_format_datatype_for_docs(T::DataType) -> String\n\nFormat a DataType for use in @docs blocks.\n\n\n\n\n\n","category":"function"},{"location":"documenter_reference.html#DocumenterReference._format_type_for_docs","page":"DocumenterReference","title":"DocumenterReference._format_type_for_docs","text":"_format_type_for_docs(T) -> String\n\nFormat a type for use in Documenter's @docs block. Always fully qualifies types to avoid UndefVarError when Documenter evaluates in Main.\n\n\n\n\n\n","category":"function"},{"location":"documenter_reference.html#DocumenterReference._format_type_param","page":"DocumenterReference","title":"DocumenterReference._format_type_param","text":"_format_type_param(p) -> String\n\nFormat a type parameter (can be a type or a value like an integer).\n\n\n\n\n\n","category":"function"},{"location":"documenter_reference.html#DocumenterReference._get_effective_source_files","page":"DocumenterReference","title":"DocumenterReference._get_effective_source_files","text":"_get_effective_source_files(config::_Config) -> Vector{String}\n\nDetermine the effective source files for filtering symbols. Priority: module-specific files > global source_files > empty (no filtering).\n\n\n\n\n\n","category":"function"},{"location":"documenter_reference.html#DocumenterReference._get_source_file","page":"DocumenterReference","title":"DocumenterReference._get_source_file","text":"_get_source_file(mod::Module, key::Symbol, type::DocType) -> Union{String, Nothing}\n\nDetermine the source file path where a symbol is defined. Returns nothing if the source file cannot be determined.\n\n\n\n\n\n","category":"function"},{"location":"documenter_reference.html#DocumenterReference._get_source_from_docstring","page":"DocumenterReference","title":"DocumenterReference._get_source_from_docstring","text":"_get_source_from_docstring(mod::Module, key::Symbol) -> Union{String, Nothing}\n\nTry to get source file path from docstring metadata.\n\n\n\n\n\n","category":"function"},{"location":"documenter_reference.html#DocumenterReference._get_source_from_methods","page":"DocumenterReference","title":"DocumenterReference._get_source_from_methods","text":"_get_source_from_methods(obj) -> Union{String, Nothing}\n\nTry to get source file path from method definitions.\n\n\n\n\n\n","category":"function"},{"location":"documenter_reference.html#DocumenterReference._has_documentation","page":"DocumenterReference","title":"DocumenterReference._has_documentation","text":"_has_documentation(mod::Module, key::Symbol, type::DocType, modules::Dict) -> Bool\n\nCheck if a symbol has documentation. Logs a warning if not.\n\n\n\n\n\n","category":"function"},{"location":"documenter_reference.html#DocumenterReference._iterate_over_symbols","page":"DocumenterReference","title":"DocumenterReference._iterate_over_symbols","text":"_iterate_over_symbols(f, config, symbol_list)\n\nIterate over symbols, applying a function to each documented symbol. Filters symbols based on exclusion list, documentation presence, and source files.\n\n\n\n\n\n","category":"function"},{"location":"documenter_reference.html#DocumenterReference._method_signature_string","page":"DocumenterReference","title":"DocumenterReference._method_signature_string","text":"_method_signature_string(m::Method, mod::Module, key::Symbol) -> String\n\nGenerate a Documenter-compatible signature string for a method. Returns a string like Module.func(::Type1, ::Type2) for use in @docs blocks.\n\n\n\n\n\n","category":"function"},{"location":"documenter_reference.html#DocumenterReference._normalize_paths","page":"DocumenterReference","title":"DocumenterReference._normalize_paths","text":"_normalize_paths(paths) -> Vector{String}\n\nNormalize a collection of paths to absolute paths.\n\n\n\n\n\n","category":"function"},{"location":"documenter_reference.html#DocumenterReference._parse_primary_modules","page":"DocumenterReference","title":"DocumenterReference._parse_primary_modules","text":"_parse_primary_modules(primary_modules::Vector) -> Dict{Module, Vector{String}}\n\nParse the primary_modules argument into a dictionary mapping modules to their source files. Handles both plain modules and Module => files pairs.\n\n\n\n\n\n","category":"function"},{"location":"documenter_reference.html#DocumenterReference._passes_source_filter","page":"DocumenterReference","title":"DocumenterReference._passes_source_filter","text":"_passes_source_filter(mod, key, type, source_files, include_without_source) -> Bool\n\nCheck if a symbol passes the source file filter.\n\n\n\n\n\n","category":"function"},{"location":"documenter_reference.html#DocumenterReference._register_config","page":"DocumenterReference","title":"DocumenterReference._register_config","text":"_register_config(current_module, subdirectory, modules, sort_by, exclude, public, private, \n                 title, title_in_menu, source_files, filename, include_without_source, \n                 external_modules_to_document)\n\nCreate and register a _Config in the global CONFIG vector.\n\n\n\n\n\n","category":"function"},{"location":"documenter_reference.html#DocumenterReference._to_string","page":"DocumenterReference","title":"DocumenterReference._to_string","text":"_to_string(x::DocType) -> String\n\nConvert a DocType enumeration value to its string representation.\n\n\n\n\n\n","category":"function"},{"location":"documenter_reference.html#DocumenterReference.reset_config!","page":"DocumenterReference","title":"DocumenterReference.reset_config!","text":"reset_config!()\n\nClear the global CONFIG vector and PAGE_CONTENT_ACCUMULATOR. Useful between documentation builds or for testing.\n\n\n\n\n\n","category":"function"},{"location":"documenter_reference.html#CTBase.automatic_reference_documentation-Tuple{CTBase.DocumenterReferenceTag}","page":"DocumenterReference","title":"CTBase.automatic_reference_documentation","text":"automatic_reference_documentation(;\n    subdirectory::String,\n    primary_modules,\n    sort_by::Function = identity,\n    exclude::Vector{Symbol} = Symbol[],\n    public::Bool = true,\n    private::Bool = true,\n    title::String = \"API Reference\",\n    title_in_menu::String = \"\",\n    filename::String = \"\",\n    source_files::Vector{String} = String[],\n    include_without_source::Bool = false,\n    external_modules_to_document::Vector{Module} = Module[],\n)\n\nAutomatically creates the API reference documentation for one or more modules and returns a structure which can be used in the pages argument of Documenter.makedocs.\n\nArguments\n\nsubdirectory: the directory relative to the documentation root in which to write the API files.\nprimary_modules: a vector of modules or Module => source_files pairs to document. When source files are provided, only symbols defined in those files are documented.\nsort_by: a custom sort function applied to symbol lists.\nexclude: vector of symbol names to skip from the generated API.\npublic: flag to generate public API page (default: true).\nprivate: flag to generate private API page (default: true).\ntitle: title displayed at the top of the generated page.\ntitle_in_menu: title displayed in the navigation menu (default: same as title).\nfilename: base filename (without extension) for the markdown file.\nsource_files: global source file paths (fallback if no module-specific files). Deprecated: prefer using primary_modules=[Module => files] instead.\ninclude_without_source: if true, include symbols whose source file cannot be determined. Default: false.\nexternal_modules_to_document: additional modules to search for docstrings (e.g., [Plots] to include Plots.plot methods defined in your source files).\n\nMultiple instances\n\nEach time you call this function, a new object is added to the global variable DocumenterReference.CONFIG. Use reset_config!() to clear it between builds.\n\n\n\n\n\n","category":"method"},{"location":"ctbase.html#Private-API","page":"CTBase","title":"Private API","text":"This page lists non-exported (internal) symbols of CTBase.\n\n","category":"section"},{"location":"ctbase.html#From-CTBase","page":"CTBase","title":"From CTBase","text":"","category":"section"},{"location":"ctbase.html#AbstractCoveragePostprocessingTag","page":"CTBase","title":"AbstractCoveragePostprocessingTag","text":"","category":"section"},{"location":"ctbase.html#AbstractDocumenterReferenceTag","page":"CTBase","title":"AbstractDocumenterReferenceTag","text":"","category":"section"},{"location":"ctbase.html#AbstractTestRunnerTag","page":"CTBase","title":"AbstractTestRunnerTag","text":"","category":"section"},{"location":"ctbase.html#CoveragePostprocessingTag","page":"CTBase","title":"CoveragePostprocessingTag","text":"","category":"section"},{"location":"ctbase.html#DocumenterReferenceTag","page":"CTBase","title":"DocumenterReferenceTag","text":"","category":"section"},{"location":"ctbase.html#TestRunnerTag","page":"CTBase","title":"TestRunnerTag","text":"","category":"section"},{"location":"ctbase.html#automatic_reference_documentation","page":"CTBase","title":"automatic_reference_documentation","text":"","category":"section"},{"location":"ctbase.html#ctNumber","page":"CTBase","title":"ctNumber","text":"","category":"section"},{"location":"ctbase.html#postprocess_coverage","page":"CTBase","title":"postprocess_coverage","text":"","category":"section"},{"location":"ctbase.html#run_tests","page":"CTBase","title":"run_tests","text":"","category":"section"},{"location":"ctbase.html#CTBase.AbstractCoveragePostprocessingTag","page":"CTBase","title":"CTBase.AbstractCoveragePostprocessingTag","text":"abstract type AbstractCoveragePostprocessingTag\n\nAbstract supertype for tags used to select a particular implementation of postprocess_coverage.\n\nConcrete subtypes identify a specific backend that provides the actual coverage post-processing logic.\n\nExample\n\njulia> using CTBase\n\njulia> CTBase.CoveragePostprocessingTag() isa CTBase.AbstractCoveragePostprocessingTag\ntrue\n\n\n\n\n\n","category":"type"},{"location":"ctbase.html#CTBase.AbstractDocumenterReferenceTag","page":"CTBase","title":"CTBase.AbstractDocumenterReferenceTag","text":"abstract type AbstractDocumenterReferenceTag\n\nAbstract supertype for tags used to select a particular implementation of automatic_reference_documentation.\n\nConcrete subtypes identify a specific backend that provides the actual documentation generation logic.\n\nExample\n\njulia> using CTBase\n\njulia> CTBase.DocumenterReferenceTag() isa CTBase.AbstractDocumenterReferenceTag\ntrue\n\n\n\n\n\n","category":"type"},{"location":"ctbase.html#CTBase.AbstractTestRunnerTag","page":"CTBase","title":"CTBase.AbstractTestRunnerTag","text":"abstract type AbstractTestRunnerTag\n\nAbstract supertype for tags used to select a particular implementation of run_tests.\n\nConcrete subtypes identify a specific backend that provides the actual test runner logic.\n\n\n\n\n\n","category":"type"},{"location":"ctbase.html#CTBase.CoveragePostprocessingTag","page":"CTBase","title":"CTBase.CoveragePostprocessingTag","text":"struct CoveragePostprocessingTag <: CTBase.AbstractCoveragePostprocessingTag\n\nConcrete tag type used to dispatch to the CoveragePostprocessing extension.\n\nInstances of this type are passed to postprocess_coverage to enable coverage post-processing when the extension is available.\n\n\n\n\n\n","category":"type"},{"location":"ctbase.html#CTBase.DocumenterReferenceTag","page":"CTBase","title":"CTBase.DocumenterReferenceTag","text":"struct DocumenterReferenceTag <: CTBase.AbstractDocumenterReferenceTag\n\nConcrete tag type used to dispatch to the DocumenterReference extension.\n\nInstances of this type are passed to automatic_reference_documentation to enable the integration with Documenter.jl when the DocumenterReference extension is available.\n\nExample\n\njulia> using CTBase\n\njulia> tag = CTBase.DocumenterReferenceTag()\nCTBase.DocumenterReferenceTag()\n\n\n\n\n\n","category":"type"},{"location":"ctbase.html#CTBase.TestRunnerTag","page":"CTBase","title":"CTBase.TestRunnerTag","text":"struct TestRunnerTag <: CTBase.AbstractTestRunnerTag\n\nConcrete tag type used to dispatch to the TestRunner extension.\n\nInstances of this type are passed to run_tests to enable the extension-based test runner when the extension is available.\n\n\n\n\n\n","category":"type"},{"location":"ctbase.html#CTBase.automatic_reference_documentation","page":"CTBase","title":"CTBase.automatic_reference_documentation","text":"automatic_reference_documentation(\n    ::CTBase.AbstractDocumenterReferenceTag;\n    kwargs...\n)\n\n\nGenerate API reference documentation pages for one or more modules.\n\nThis method is an extension point: the default implementation throws an ExtensionError unless a backend extension providing the actual implementation is loaded (e.g. the DocumenterReference extension).\n\nKeyword Arguments\n\nForwarded to the active backend implementation.\n\nThrows\n\nExtensionError: If no backend extension is loaded.\n\n\n\n\n\nautomatic_reference_documentation(; kwargs...)\n\n\nConvenience wrapper for automatic_reference_documentation using the default backend tag.\n\nKeyword Arguments\n\nForwarded to automatic_reference_documentation(DocumenterReferenceTag(); kwargs...).\n\nThrows\n\nExtensionError: If the required backend extension is not loaded.\n\n\n\n\n\nautomatic_reference_documentation(;\n    subdirectory::String,\n    primary_modules,\n    sort_by::Function = identity,\n    exclude::Vector{Symbol} = Symbol[],\n    public::Bool = true,\n    private::Bool = true,\n    title::String = \"API Reference\",\n    title_in_menu::String = \"\",\n    filename::String = \"\",\n    source_files::Vector{String} = String[],\n    include_without_source::Bool = false,\n    external_modules_to_document::Vector{Module} = Module[],\n)\n\nAutomatically creates the API reference documentation for one or more modules and returns a structure which can be used in the pages argument of Documenter.makedocs.\n\nArguments\n\nsubdirectory: the directory relative to the documentation root in which to write the API files.\nprimary_modules: a vector of modules or Module => source_files pairs to document. When source files are provided, only symbols defined in those files are documented.\nsort_by: a custom sort function applied to symbol lists.\nexclude: vector of symbol names to skip from the generated API.\npublic: flag to generate public API page (default: true).\nprivate: flag to generate private API page (default: true).\ntitle: title displayed at the top of the generated page.\ntitle_in_menu: title displayed in the navigation menu (default: same as title).\nfilename: base filename (without extension) for the markdown file.\nsource_files: global source file paths (fallback if no module-specific files). Deprecated: prefer using primary_modules=[Module => files] instead.\ninclude_without_source: if true, include symbols whose source file cannot be determined. Default: false.\nexternal_modules_to_document: additional modules to search for docstrings (e.g., [Plots] to include Plots.plot methods defined in your source files).\n\nMultiple instances\n\nEach time you call this function, a new object is added to the global variable DocumenterReference.CONFIG. Use reset_config!() to clear it between builds.\n\n\n\n\n\n","category":"function"},{"location":"ctbase.html#CTBase.ctNumber","page":"CTBase","title":"CTBase.ctNumber","text":"Type alias for a real number.\n\nThis constant is primarily meant as a short, semantic alias when writing APIs that accept real-valued quantities.\n\nExample\n\njulia> using CTBase\n\njulia> CTBase.ctNumber === Real\ntrue\n\n\n\n\n\n","category":"type"},{"location":"ctbase.html#CTBase.postprocess_coverage","page":"CTBase","title":"CTBase.postprocess_coverage","text":"postprocess_coverage(\n    ::CTBase.AbstractCoveragePostprocessingTag;\n    generate_report,\n    root_dir\n)\n\n\nPost-process coverage artifacts produced by Pkg.test(; coverage=true).\n\nThis is an extension point: the default implementation throws an ExtensionError unless a backend extension (e.g. CoveragePostprocessing) is loaded.\n\nKeyword Arguments\n\ngenerate_report::Bool=true: Whether to generate summary reports.\nroot_dir::String=pwd(): Project root directory used to locate coverage artifacts.\n\nThrows\n\nExtensionError: If the coverage post-processing extension is not loaded.\n\n\n\n\n\npostprocess_coverage(; kwargs...)\n\n\nConvenience wrapper for postprocess_coverage using the default backend tag.\n\nKeyword Arguments\n\nForwarded to postprocess_coverage(CoveragePostprocessingTag(); kwargs...).\n\nThrows\n\nExtensionError: If the coverage post-processing extension is not loaded.\n\n\n\n\n\nCTBase.postprocess_coverage(::CTBase.CoveragePostprocessingTag; generate_report::Bool=true, root_dir::String=pwd())\n\nPost-process coverage artifacts produced by Pkg.test(; coverage=true).\n\nThis implementation:\n\nCollects coverage source directories under root_dir (src/, test/, ext/ when present)\nResets the coverage/ directory\nRemoves stale .cov files (keeping the most complete PID suffix when multiple runs exist)\nOptionally generates reports (LCOV + markdown report)\nMoves .cov files into coverage/cov/ (recursively from source dirs)\n\nKeyword Arguments\n\ngenerate_report::Bool=true: If true, write coverage/lcov.info and coverage/cov_report.md.\nroot_dir::String=pwd(): Root directory of the project.\n\nReturns\n\nNothing\n\nNotes\n\nThis function creates/removes/moves files and directories under root_dir.\n\nUsage sketch (non-executed)\n\nusing CTBase\n\n# CTBase.postprocess_coverage(; generate_report=true, root_dir=pwd())\n\n\n\n\n\n","category":"function"},{"location":"ctbase.html#CTBase.run_tests","page":"CTBase","title":"CTBase.run_tests","text":"run_tests(\n    ::CTBase.AbstractTestRunnerTag;\n    kwargs...\n) -> Union{Nothing, Test.FallbackTestSet, Test.DefaultTestSet}\n\n\nRun the project test suite using an extension-provided test runner.\n\nThis is an extension point: the default implementation throws an ExtensionError unless a backend extension is loaded.\n\nKeyword Arguments\n\nForwarded to the active backend implementation.\n\nThrows\n\nExtensionError: If the test runner extension is not loaded.\n\n\n\n\n\nrun_tests(\n;\n    kwargs...\n) -> Union{Nothing, Test.FallbackTestSet, Test.DefaultTestSet}\n\n\nConvenience wrapper for run_tests using the default backend tag.\n\nKeyword Arguments\n\nForwarded to run_tests(TestRunnerTag(); kwargs...).\n\nThrows\n\nExtensionError: If the test runner extension is not loaded.\n\n\n\n\n\nrun_tests(::CTBase.TestRunnerTag; kwargs...)\n\nRun tests with configurable file/function name builders and optional available tests filter.\n\nKeyword Arguments\n\ntestset_name::String = \"Tests\"  name of the main testset\navailable_tests::Vector{Symbol} = Symbol[]  if non-empty, only these tests are allowed\nfilename_builder::Function = identity  Symbol  Symbol, builds the filename from the test name\nfuncname_builder::Function = identity  Symbol  Symbol|Nothing, builds the function name (or nothing to skip eval)\neval_mode::Bool = true  whether to eval the function after include\nverbose::Bool = true  verbose testset output\nshowtiming::Bool = true  show timing in testset output\n\nNotes\n\nTest selection is driven by Main.ARGS (coverage flags are ignored).\nSelection arguments are interpreted as glob patterns and matched against both the test name and the corresponding filename.\n\nUsage sketch (non-executed)\n\nusing CTBase\n\n# CTBase.run_tests(; testset_name=\"Tests\")\n\n\n\n\n\n","category":"function"},{"location":"default.html#Private-API","page":"Default","title":"Private API","text":"This page lists non-exported (internal) symbols of CTBase.\n\n","category":"section"},{"location":"default.html#From-CTBase","page":"Default","title":"From CTBase","text":"","category":"section"},{"location":"default.html#__display","page":"Default","title":"__display","text":"","category":"section"},{"location":"default.html#CTBase.__display","page":"Default","title":"CTBase.__display","text":"__display() -> Bool\n\n\nReturn the default value of the display flag.\n\nThis internal utility is used to decide whether output should be shown during execution.\n\nReturns\n\nBool: The default value true, indicating that output is displayed.\n\nExample\n\njulia> using CTBase\n\njulia> CTBase.__display()\ntrue\n\n\n\n\n\n","category":"function"},{"location":"test_runner.html#Private-API","page":"TestRunner","title":"Private API","text":"This page lists non-exported (internal) symbols of TestRunner.\n\n","category":"section"},{"location":"test_runner.html#From-TestRunner","page":"TestRunner","title":"From TestRunner","text":"","category":"section"},{"location":"test_runner.html#_glob_to_regex","page":"TestRunner","title":"_glob_to_regex","text":"","category":"section"},{"location":"test_runner.html#_parse_test_args","page":"TestRunner","title":"_parse_test_args","text":"","category":"section"},{"location":"test_runner.html#_run_single_test","page":"TestRunner","title":"_run_single_test","text":"","category":"section"},{"location":"test_runner.html#_select_tests","page":"TestRunner","title":"_select_tests","text":"","category":"section"},{"location":"test_runner.html#CTBase.run_tests","page":"TestRunner","title":"CTBase.run_tests","text":"","category":"section"},{"location":"test_runner.html#TestRunner._glob_to_regex","page":"TestRunner","title":"TestRunner._glob_to_regex","text":"_glob_to_regex(pattern::AbstractString) -> Regex\n\nConvert a glob pattern (using * and ?) into a regular expression.\n\nThe returned regex is anchored (matches the full string).\n\n\n\n\n\n","category":"function"},{"location":"test_runner.html#TestRunner._parse_test_args","page":"TestRunner","title":"TestRunner._parse_test_args","text":"_parse_test_args(args::Vector{String}) -> Tuple{Vector{Symbol}, Bool, Bool}\n\nParse command-line test arguments, filtering out coverage-related flags.\n\nReturns (selections, run_all, dry_run) where:\n\nselections: selection patterns provided by the user (as symbols)\nrun_all: whether -a / --all was present\ndry_run: whether -n / --dryrun was present\n\n\n\n\n\n","category":"function"},{"location":"test_runner.html#TestRunner._run_single_test","page":"TestRunner","title":"TestRunner._run_single_test","text":"_run_single_test(name::Symbol; kwargs...)\n\nRun a single selected test.\n\nThis helper:\n\nResolves a test filename via filename_builder\nIncludes the file into Main\nOptionally evaluates a function (via funcname_builder) when eval_mode=true\n\nThis function is not part of the public API.\n\n\n\n\n\n","category":"function"},{"location":"test_runner.html#TestRunner._select_tests","page":"TestRunner","title":"TestRunner._select_tests","text":"Determine which tests to run based on selections, available_tests filter, and file globbing.\n\nIdentify potential test files in test_dir (default: test/).\nFilter by available_tests if provided.\nFilter by selections (interpreted as globs) if present.\n\nNotes\n\nIf available_tests is empty, this function falls back to an auto-discovery heuristic using the filename stem as the candidate test name.\n\n\n\n\n\n","category":"function"},{"location":"test_runner.html#CTBase.run_tests-Tuple{CTBase.TestRunnerTag}","page":"TestRunner","title":"CTBase.run_tests","text":"run_tests(::CTBase.TestRunnerTag; kwargs...)\n\nRun tests with configurable file/function name builders and optional available tests filter.\n\nKeyword Arguments\n\ntestset_name::String = \"Tests\"  name of the main testset\navailable_tests::Vector{Symbol} = Symbol[]  if non-empty, only these tests are allowed\nfilename_builder::Function = identity  Symbol  Symbol, builds the filename from the test name\nfuncname_builder::Function = identity  Symbol  Symbol|Nothing, builds the function name (or nothing to skip eval)\neval_mode::Bool = true  whether to eval the function after include\nverbose::Bool = true  verbose testset output\nshowtiming::Bool = true  show timing in testset output\n\nNotes\n\nTest selection is driven by Main.ARGS (coverage flags are ignored).\nSelection arguments are interpreted as glob patterns and matched against both the test name and the corresponding filename.\n\nUsage sketch (non-executed)\n\nusing CTBase\n\n# CTBase.run_tests(; testset_name=\"Tests\")\n\n\n\n\n\n","category":"method"},{"location":"index.html#CTBase.jl","page":"Introduction","title":"CTBase.jl","text":"The CTBase.jl package is part of the control-toolbox ecosystem.\n\nnote: Note\nThe root package is OptimalControl.jl which aims to provide tools to model and solve optimal control problems with ordinary differential equations by direct and indirect methods, both on CPU and GPU.\n\nwarning: Warning\nIn some examples in the documentation, private methods are shown without the module prefix. This is done for the sake of clarity and readability.julia> using CTBase\njulia> x = 1\njulia> private_fun(x) # throws an errorThis should instead be written as:julia> using CTBase\njulia> x = 1\njulia> CTBase.private_fun(x)If the method is re-exported by another package, module OptimalControl\n    import CTBase: private_fun\n    export private_fun\nendthen there is no need to prefix it with the original module name:julia> using OptimalControl\njulia> x = 1\njulia> private_fun(x)","category":"section"},{"location":"index.html#Optional-extensions","page":"Introduction","title":"Optional extensions","text":"CTBase uses Julia's package extensions mechanism (via [weakdeps] + [extensions] in Project.toml) to provide optional functionality without forcing extra dependencies on downstream packages.\n\nThe pattern is:\n\nThe core package defines tag types and extension points (methods that throw CTBase.ExtensionError(...) by default).\nWhen you load an optional dependency, Julia automatically loads the corresponding extension module from ext/, which adds the real implementation.\n\nYou can check whether an extension is loaded with Base.get_extension:\n\nBase.get_extension(CTBase, :TestRunner)\nBase.get_extension(CTBase, :CoveragePostprocessing)\nBase.get_extension(CTBase, :DocumenterReference)","category":"section"},{"location":"index.html#DocumenterReference-(API-reference-generation)","page":"Introduction","title":"DocumenterReference (API reference generation)","text":"Role: provides the backend for CTBase.automatic_reference_documentation(...) used to generate API reference pages for Documenter.\nTriggered by: loading the dependencies needed by the extension, typically:\n\nusing CTBase\nusing Documenter\nusing Markdown\nusing MarkdownAST\n\nWhy there is no simple usage: the function is meant to run inside a docs build and interacts with Documenters build pipeline and filesystem layout.\n\nUsage sketch (non-executed):\n\nusing CTBase\nusing Documenter\nusing Markdown\nusing MarkdownAST\n\n# pages = CTBase.automatic_reference_documentation(; subdirectory=\".\", primary_modules=[CTBase])","category":"section"},{"location":"index.html#TestRunner-(selectable-test-groups)","page":"Introduction","title":"TestRunner (selectable test groups)","text":"Role: provides the backend for CTBase.run_tests(...) used by this repositorys test/runtests.jl to run named test groups and support selection via test_args.\nTriggered by: using Test (or loading Test indirectly via a test run).\n\nWhy it is not exposed as a simple user API:\n\nIt is mainly a developer tool for this package (and related repos).\nIt executes tests, includes files, and may depend on Main.ARGS conventions.\n\nUsage sketch (non-executed):\n\nusing CTBase\nusing Test\n\n# CTBase.run_tests(; testset_name=\"CTBase tests\", test_dir=\"test\")","category":"section"},{"location":"index.html#CoveragePostprocessing-(coverage-artifacts)","page":"Introduction","title":"CoveragePostprocessing (coverage artifacts)","text":"Role: provides the backend for CTBase.postprocess_coverage(...), used after running tests with coverage to collect .cov files and generate reports.\nTriggered by: using Coverage.\n\nWhy it is not a simple usage:\n\nIt performs filesystem side-effects (create/remove/move files under coverage/).\nIt assumes a project layout (src/, test/, ext/).\n\nUsage sketch (non-executed):\n\nusing CTBase\nusing Coverage\n\n# CTBase.postprocess_coverage(; root_dir=pwd(), generate_report=true)","category":"section"},{"location":"index.html#Descriptions:-encoding-algorithms","page":"Introduction","title":"Descriptions: encoding algorithms","text":"One of the central ideas in CTBase is the notion of a description. A description is simply a tuple of Symbols that encodes an algorithm or configuration in a declarative way.\n\nFormally, CTBase defines:\n\nconst DescVarArg = Vararg{Symbol}\nconst Description = Tuple{DescVarArg}\n\nFor example, the tuple\n\njulia> using CTBase\n\njulia> d = (:descent, :bfgs, :bisection)\n(:descent, :bfgs, :bisection)\n\njulia> typeof(d) <: CTBase.Description\ntrue\n\ncan be read as a descent algorithm, with BFGS directions and a bisection line search. Higher-level packages in the control-toolbox ecosystem use descriptions to catalogue algorithms in a uniform way.","category":"section"},{"location":"index.html#Building-a-library-of-descriptions","page":"Introduction","title":"Building a library of descriptions","text":"CTBase provides a few small functions to manage collections of descriptions:\n\nCTBase.add(x, y) adds the description y to the tuple of descriptions x, rejecting duplicates with an IncorrectArgument exception.\nCTBase.complete(list; descriptions=D) picks a complete description from a set D based on a partial list of symbols.\nCTBase.remove(x, y) returns the set difference of two descriptions.\n\nHere is a complete example of a small algorithm library:\n\njulia> algorithms = ()\n()\n\njulia> algorithms = CTBase.add(algorithms, (:descent, :bfgs, :bisection))\n((:descent, :bfgs, :bisection),)\n\njulia> algorithms = CTBase.add(algorithms, (:descent, :gradient, :fixedstep))\n((:descent, :bfgs, :bisection), (:descent, :gradient, :fixedstep))\n\njulia> display(algorithms)\n(:descent, :bfgs, :bisection)\n(:descent, :gradient, :fixedstep)\n\nGiven this library, we can complete a partial description:\n\njulia> CTBase.complete((:descent,); descriptions=algorithms)\n(:descent, :bfgs, :bisection)\n\njulia> CTBase.complete((:gradient, :fixedstep); descriptions=algorithms)\n(:descent, :gradient, :fixedstep)\n\nInternally, CTBase.complete scans the descriptions tuple from top to bottom. For each candidate description it computes:\n\nhow many symbols it shares with the partial list, and\nwhether the partial list is a subset of the full description.\n\nIf no description contains all the symbols from the partial list, AmbiguousDescription is thrown. Otherwise, among the descriptions that do contain the partial list, CTBase selects the one with the largest intersection; if several have the same score, the first one in the descriptions tuple wins. In other words, the order of descriptions encodes a priority from top to bottom.\n\nWith this mechanism in place, we can then analyse the remainder of a description by removing a prefix:\n\njulia> full = CTBase.complete((:descent,); descriptions=algorithms)\n(:descent, :bfgs, :bisection)\n\njulia> CTBase.remove(full, (:descent, :bfgs))\n(:bisection,)\n\nThis description language lets higher-level packages refer to algorithms in a structured, composable way, while CTBase takes care of the low-level operations (adding, completing, and comparing descriptions).","category":"section"},{"location":"index.html#Error-handling-and-CTBase-exceptions","page":"Introduction","title":"Error handling and CTBase exceptions","text":"CTBase defines a small hierarchy of domain-specific exceptions to make error handling explicit and consistent across the control-toolbox ecosystem.\n\nAll custom exceptions inherit from CTBase.CTException:\n\nabstract type CTBase.CTException <: Exception end\n\nYou should generally catch exceptions like this:\n\ntry\n    # call into CTBase or a package built on top of it\ncatch e\n    if e isa CTBase.CTException\n        # handle CTBase domain errors in a uniform way\n        @warn \"CTBase error\" exception=(e, catch_backtrace())\n    else\n        # non-CTBase error: rethrow so it is not hidden\n        rethrow()\n    end\nend\n\nThis pattern avoids accidentally swallowing unrelated internal errors while still giving you a single place to handle all CTBase-specific problems.","category":"section"},{"location":"index.html#AmbiguousDescription","page":"Introduction","title":"AmbiguousDescription","text":"CTBase.AmbiguousDescription <: CTBase.CTException\n\nThrown when a description (a tuple of Symbols) cannot be matched to any known valid description. This typically happens in CTBase.complete when the user provides an incomplete or inconsistent description.\n\njulia> using CTBase\n\njulia> D = ((:a, :b), (:a, :b, :c), (:b, :c))\njulia> CTBase.complete(:f; descriptions=D)\nERROR: AmbiguousDescription: the description (:f,) is ambiguous / incorrect\n\nUse this exception when the high-level choice of description itself is wrong or ambiguous and there is no sensible default.","category":"section"},{"location":"index.html#IncorrectArgument","page":"Introduction","title":"IncorrectArgument","text":"CTBase.IncorrectArgument <: CTBase.CTException\n\nThrown when an individual argument is invalid or violates a precondition.\n\nExamples from CTBase:\n\nAdding a duplicate description:\njulia> algorithms = CTBase.add((), (:a, :b))\njulia> CTBase.add(algorithms, (:a, :b))\nERROR: IncorrectArgument: the description (:a, :b) is already in ((:a, :b),)\nUsing invalid indices for the Unicode helpers:\njulia> CTBase.ctindice(-1)\nERROR: IncorrectArgument: the subscript must be between 0 and 9\n\nUse this exception whenever one input value is outside the allowed domain (wrong range, duplicate, empty when it must not be, etc.).","category":"section"},{"location":"index.html#NotImplemented","page":"Introduction","title":"NotImplemented","text":"CTBase.NotImplemented <: CTBase.CTException\n\nUsed to mark interface points that must be implemented by concrete subtypes. The typical pattern is to provide a method on an abstract type that throws NotImplemented, and then override it in each concrete implementation:\n\nabstract type MyAbstractAlgorithm end\n\nfunction run!(algo::MyAbstractAlgorithm, state)\n    throw(CTBase.NotImplemented(\"run! is not implemented for $(typeof(algo))\"))\nend\n\nConcrete algorithms then provide their own run! method instead of raising this exception. This makes it easy to detect missing implementations during testing.\n\nUse NotImplemented when defining interfaces and you want an explicit, typed error rather than a generic error(\"TODO\").","category":"section"},{"location":"index.html#UnauthorizedCall","page":"Introduction","title":"UnauthorizedCall","text":"CTBase.UnauthorizedCall <: CTBase.CTException\n\nSignals that a function call is not allowed in the current state of the object or system. This is different from IncorrectArgument: here the arguments may be valid, but the call is forbidden because of when or how it is made.\n\nA common pattern is a method that is meant to be called only once:\n\nfunction finalize!(s::SomeState)\n    if s.is_finalized\n        throw(CTBase.UnauthorizedCall(\"finalize! was already called for this state\"))\n    end\n    # ... perform finalisation and mark state as finalised ...\nend\n\nUse UnauthorizedCall when the calling context is invalid (wrong phase of a computation, method already called, state already closed, missing permissions, illegal order of calls, etc.).\n\nIt is also used internally by ExtensionError when it is called without any weak dependencies:\n\njulia> using CTBase\n\njulia> CTBase.ExtensionError()\nERROR: UnauthorizedCall: Please provide at least one weak dependence for the extension.","category":"section"},{"location":"index.html#ParsingError","page":"Introduction","title":"ParsingError","text":"CTBase.ParsingError <: CTBase.CTException\n\nIntended for errors detected during parsing of input structures or DSLs (domain-specific languages).\n\njulia> using CTBase\n\njulia> throw(CTBase.ParsingError(\"unexpected token 'end'\"))\nERROR: ParsingError: unexpected token 'end'","category":"section"},{"location":"utils.html#Private-API","page":"Utils","title":"Private API","text":"This page lists non-exported (internal) symbols of CTBase.\n\n","category":"section"},{"location":"utils.html#From-CTBase","page":"Utils","title":"From CTBase","text":"","category":"section"},{"location":"utils.html#ctindice","page":"Utils","title":"ctindice","text":"","category":"section"},{"location":"utils.html#ctindices","page":"Utils","title":"ctindices","text":"","category":"section"},{"location":"utils.html#ctupperscript","page":"Utils","title":"ctupperscript","text":"","category":"section"},{"location":"utils.html#ctupperscripts","page":"Utils","title":"ctupperscripts","text":"","category":"section"},{"location":"utils.html#CTBase.ctindice","page":"Utils","title":"CTBase.ctindice","text":"ctindice(i::Int64) -> Char\n\n\nReturn the integer i  [0, 9] as a Unicode subscript character.\n\nThrows an IncorrectArgument exception if i is outside this range.\n\nThe Unicode subscript digits start at codepoint U+2080 for '0' and continue sequentially.\n\nExample\n\njulia> using CTBase\n\njulia> CTBase.ctindice(3)\n'': Unicode U+2083 (category No: Number, other)\n\n\n\n\n\n","category":"function"},{"location":"utils.html#CTBase.ctindices","page":"Utils","title":"CTBase.ctindices","text":"ctindices(i::Int64) -> String\n\n\nReturn the integer i  0 as a string of Unicode subscript characters.\n\nThrows an IncorrectArgument if i is negative.\n\nExample\n\njulia> using CTBase\n\njulia> CTBase.ctindices(123)\n\"\"\n\n\n\n\n\n","category":"function"},{"location":"utils.html#CTBase.ctupperscript","page":"Utils","title":"CTBase.ctupperscript","text":"ctupperscript(i::Int64) -> Char\n\n\nReturn the integer i  [0, 9] as a Unicode superscript (upper) character.\n\nThrows an IncorrectArgument exception if i is outside this range.\n\nNote: Unicode superscripts  (U+00B9),  (U+00B2), and  (U+00B3) are special cases. The other digits  (U+2070) and  to  (U+2074 to U+2079) are mostly contiguous.\n\nExample\n\njulia> using CTBase\n\njulia> CTBase.ctupperscript(2)\n'': Unicode U+00B2 (category No: Number, other)\n\n\n\n\n\n","category":"function"},{"location":"utils.html#CTBase.ctupperscripts","page":"Utils","title":"CTBase.ctupperscripts","text":"ctupperscripts(i::Int64) -> String\n\n\nReturn the integer i  0 as a string of Unicode superscript characters.\n\nThrows an IncorrectArgument exception if i is negative.\n\nExample\n\njulia> using CTBase\n\njulia> CTBase.ctupperscripts(123)\n\"\"\n\n\n\n\n\n","category":"function"}]
}

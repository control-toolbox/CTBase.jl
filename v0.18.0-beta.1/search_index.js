var documenterSearchIndex = {"docs":
[{"location":"api/exceptions_public.html#Public-API","page":"Public","title":"Public API","text":"This page lists exported symbols of CTBase.Exceptions.\n\n","category":"section"},{"location":"api/exceptions_public.html#From-CTBase.Exceptions","page":"Public","title":"From CTBase.Exceptions","text":"","category":"section"},{"location":"api/exceptions_public.html#AmbiguousDescription","page":"Public","title":"AmbiguousDescription","text":"","category":"section"},{"location":"api/exceptions_public.html#CTException","page":"Public","title":"CTException","text":"","category":"section"},{"location":"api/exceptions_public.html#ExtensionError","page":"Public","title":"ExtensionError","text":"","category":"section"},{"location":"api/exceptions_public.html#IncorrectArgument","page":"Public","title":"IncorrectArgument","text":"","category":"section"},{"location":"api/exceptions_public.html#NotImplemented","page":"Public","title":"NotImplemented","text":"","category":"section"},{"location":"api/exceptions_public.html#ParsingError","page":"Public","title":"ParsingError","text":"","category":"section"},{"location":"api/exceptions_public.html#PreconditionError","page":"Public","title":"PreconditionError","text":"","category":"section"},{"location":"api/exceptions_public.html#CTBase.Exceptions.AmbiguousDescription","page":"Public","title":"CTBase.Exceptions.AmbiguousDescription","text":"AmbiguousDescription <: CTException\n\nException thrown when a description (a tuple of Symbols) cannot be matched to any known valid descriptions.\n\nThis exception is raised by CTBase.complete() when the user provides an incomplete or inconsistent description that doesn't match any of the available descriptions in the catalogue. Use this exception when the high-level choice of description itself is wrong or ambiguous and there is no sensible default.\n\nEnhanced version with additional context for better error reporting.\n\nFields\n\nmsg::String: Main error message (auto-generated if not provided)\ndescription::Tuple{Vararg{Symbol}}: The ambiguous or incorrect description tuple\ncandidates::Union{Vector{String}, Nothing}: Suggested valid descriptions (optional)\nsuggestion::Union{String, Nothing}: How to fix the problem (optional)\ncontext::Union{String, Nothing}: Where the error occurred (optional)\n\nExample\n\njulia> using CTBase\n\njulia> D = ((:a, :b), (:a, :b, :c), (:b, :c))\njulia> CTBase.complete(:f; descriptions=D)\nERROR: AmbiguousDescription: the description (:f,) is ambiguous / incorrect\n\nIn this example, the symbol :f does not appear in any of the known descriptions, so complete() cannot determine which description to return.\n\nEnhanced version with full context:\n\nthrow(CTBase.Exceptions.AmbiguousDescription(\n    (:f,),\n    candidates=[\"(:descent, :bfgs, :bisection)\", \"(:descent, :gradient, :fixedstep)\"],\n    suggestion=\"Use a complete description like (:descent, :bfgs, :bisection)\",\n    context=\"algorithm selection\"\n))\n\nCommon Use Cases\n\nAlgorithm selection in optimization libraries\nConfiguration matching in DSL systems\nPattern matching in description-based APIs\nValidation of symbolic descriptions in mathematical modeling\n\nSee Also\n\ncomplete: Matches a partial description to a complete one\nadd: Adds descriptions to a catalogue (throws IncorrectArgument for duplicates)\nIncorrectArgument: For input validation errors\n\n\n\n\n\n","category":"type"},{"location":"api/exceptions_public.html#CTBase.Exceptions.CTException","page":"Public","title":"CTBase.Exceptions.CTException","text":"CTException\n\nAbstract supertype for all CTBase exceptions. Compatible with CTBase.CTException for future migration.\n\nAll exceptions inherit from this type to allow uniform error handling.\n\nExample\n\njulia> using CTBase\n\njulia> try\n           throw(CTBase.Exceptions.IncorrectArgument(\"invalid input\"))\n       catch e::CTBase.Exceptions.CTException\n           println(\"Caught a domain-specific exception: \", e)\n       end\nCaught a domain-specific exception: IncorrectArgument: invalid input\n\nUsage Pattern\n\nUse this as the common ancestor for all domain-specific errors to allow catching all exceptions of this family via catch e::CTException.\n\ntry\n    # code that may throw CTBase exceptions\n    risky_operation()\ncatch e::CTBase.Exceptions.CTException\n    # handle all CTBase domain errors uniformly\n    handle_error(e)\nend\n\n\n\n\n\n","category":"type"},{"location":"api/exceptions_public.html#CTBase.Exceptions.ExtensionError","page":"Public","title":"CTBase.Exceptions.ExtensionError","text":"ExtensionError <: CTException\n\nException thrown when an extension or optional dependency is not loaded but a function requiring it is called.\n\nThis exception is used to signal that a feature requires one or more optional dependencies (weak dependencies) to be loaded. When a user tries to use a feature without loading the required extensions, this exception provides a helpful message indicating exactly which packages need to be loaded.\n\nIt is also used internally by ExtensionError() when called without any weak dependencies, in which case it throws PreconditionError instead.\n\nEnhanced version with additional context for better error reporting.\n\nFields\n\nmsg::String: Main error message (auto-generated from message parameter)\nweakdeps::Tuple{Vararg{Symbol}}: The tuple of symbols representing the missing dependencies\nfeature::Union{String, Nothing}: Which functionality requires these dependencies (optional)\ncontext::Union{String, Nothing}: Where the error occurred (optional)\n\nConstructor\n\nExtensionError(weakdeps::Symbol...; message::String=\"\", feature::Union{String, Nothing}=nothing, context::Union{String, Nothing}=nothing)\n\nThrows PreconditionError if no weak dependencies are provided:\n\nExtensionError()  # Throws PreconditionError\n\nExamples\n\njulia> using CTBase\n\njulia> throw(CTBase.Exceptions.ExtensionError(:MyExtension))\nERROR: ExtensionError. Please make: julia> using MyExtension\n\nWith multiple dependencies and a custom message:\n\njulia> throw(CTBase.Exceptions.ExtensionError(:MyExtension, :AnotherDep; message=\"to use this feature\"))\nERROR: ExtensionError. Please make: julia> using MyExtension, AnotherDep to use this feature\n\nEnhanced version with full context:\n\nthrow(CTBase.Exceptions.ExtensionError(\n    (:Plots, :PlotlyJS),\n    message=\"to plot optimization results\",\n    feature=\"plotting functionality\",\n    context=\"solve! call\"\n))\n\nCommon Use Cases\n\nOptional plotting functionality in optimization packages\nSpecialized solvers that require additional packages\nExport/import features with format-specific dependencies\nAdvanced algorithms that depend on external libraries\n\nSee Also\n\nPreconditionError: Thrown when ExtensionError() is called without arguments\n\n\n\n\n\n","category":"type"},{"location":"api/exceptions_public.html#CTBase.Exceptions.IncorrectArgument","page":"Public","title":"CTBase.Exceptions.IncorrectArgument","text":"IncorrectArgument <: CTException\n\nException thrown when an individual argument is invalid or violates a precondition.\n\nThis exception is raised when one input value is outside the allowed domain, such as:\n\nWrong range or bounds (e.g., negative when positive is required)\nDuplicate values when uniqueness is required\nEmpty collections when non-empty is required\nType mismatches or invalid combinations\n\nUse this exception to signal that the problem is with the input data itself, not with the state of the system or the calling context.\n\nFields\n\nmsg::String: Main error message describing the problem\ngot::Union{String, Nothing}: What value was received (optional)\nexpected::Union{String, Nothing}: What value was expected (optional)\nsuggestion::Union{String, Nothing}: How to fix the problem (optional)\ncontext::Union{String, Nothing}: Where the error occurred (optional)\n\nExamples\n\njulia> using CTBase\n\njulia> throw(CTBase.Exceptions.IncorrectArgument(\"the argument must be a non-empty tuple\"))\nERROR: IncorrectArgument: the argument must be a non-empty tuple\n\nAdding a duplicate description to a catalogue:\n\njulia> algorithms = CTBase.add((), (:a, :b))\njulia> CTBase.add(algorithms, (:a, :b))\nERROR: IncorrectArgument: the description (:a, :b) is already in ((:a, :b),)\n\nInvalid indices for Unicode helpers:\n\njulia> CTBase.ctindice(-1)\nERROR: IncorrectArgument: the subscript must be between 0 and 9\n\nEnhanced version with detailed context:\n\nthrow(CTBase.Exceptions.IncorrectArgument(\n    \"Dimension mismatch\",\n    got=\"vector of length 3\",\n    expected=\"vector of length 2\",\n    suggestion=\"Provide a vector matching the state dimension\",\n    context=\"initial_guess for state\"\n))\n\nSee Also\n\nAmbiguousDescription: For high-level description matching errors\n\n\n\n\n\n","category":"type"},{"location":"api/exceptions_public.html#CTBase.Exceptions.NotImplemented","page":"Public","title":"CTBase.Exceptions.NotImplemented","text":"NotImplemented <: CTException\n\nException thrown to mark interface points that must be implemented by concrete subtypes.\n\nThis exception is used to define abstract interfaces where a default method on an abstract type throws NotImplemented, and each concrete implementation must override it. This makes it easy to detect missing implementations during testing and development.\n\nUse NotImplemented when defining interfaces and you want an explicit, typed error rather than a generic error(\"TODO\").\n\nFields\n\nmsg::String: Description of what is not implemented\nrequired_method::Union{String, Nothing}: Method signature or requirement (optional)\nsuggestion::Union{String, Nothing}: How to fix the problem (optional)\ncontext::Union{String, Nothing}: Where the error occurred (optional)\n\nExample\n\njulia> using CTBase\n\njulia> throw(CTBase.Exceptions.NotImplemented(\"feature X is not implemented\"))\nERROR: NotImplemented: feature X is not implemented\n\nA typical pattern for defining an interface:\n\nabstract type MyAbstractAlgorithm end\n\nfunction run!(algo::MyAbstractAlgorithm, state)\n    throw(CTBase.Exceptions.NotImplemented(\n        \"run! is not implemented for $(typeof(algo))\",\n        required_method=\"run!(::MyAbstractAlgorithm, state)\",\n        context=\"algorithm execution\",\n        suggestion=\"Implement run! for your concrete algorithm type\"\n    ))\nend\n\nConcrete algorithms then provide their own run! method instead of raising this exception.\n\nEnhanced version with full context:\n\nthrow(CTBase.Exceptions.NotImplemented(\n    \"Method solve! not implemented\",\n    required_method=\"solve!(::MyStrategy, ...)\",\n    context=\"solve call\",\n    suggestion=\"Import the relevant package (e.g. CTDirect) or implement solve!(::MyStrategy, ...)\"\n))\n\nSee Also\n\nIncorrectArgument: For input validation errors\n\n\n\n\n\n","category":"type"},{"location":"api/exceptions_public.html#CTBase.Exceptions.ParsingError","page":"Public","title":"CTBase.Exceptions.ParsingError","text":"ParsingError <: CTException\n\nException thrown during parsing when a syntax error or invalid structure is detected.\n\nThis exception is intended for errors detected during parsing of input structures or domain-specific languages (DSLs). Use this when processing user input that follows a specific grammar or format, and the input violates the expected syntax.\n\nThis exception is raised when the structure or syntax of the input is invalid, rather than the semantic meaning. For semantic errors, use IncorrectArgument instead.\n\nFields\n\nmsg::String: Description of the parsing error\nlocation::Union{String, Nothing}: Where in the input the error occurred (optional)\nsuggestion::Union{String, Nothing}: How to fix the problem (optional)\n\nExample\n\njulia> using CTBase\n\njulia> throw(CTBase.Exceptions.ParsingError(\"unexpected token 'end'\"))\nERROR: ParsingError: unexpected token 'end'\n\nWith optional fields:\n\nthrow(CTBase.Exceptions.ParsingError(\n    \"Unexpected token 'end'\",\n    location=\"line 42, column 15\",\n    suggestion=\"Check syntax balance or remove extra 'end'\"\n))\n\nAs used in CTParser.jl (message only):\n\ninfo = string(\"Line \", 42, \": x = 1\n\", \"Unexpected token 'end'\")\nthrow(CTBase.Exceptions.ParsingError(info))\n\nCommon use cases:\n\nParsing mathematical expressions or formulas\nReading configuration files or DSL syntax\nProcessing structured input with specific grammar rules\nValidating syntax of domain-specific languages\n\nSee Also\n\nIncorrectArgument: For general input validation errors\nAmbiguousDescription: For description matching errors\n\n\n\n\n\n","category":"type"},{"location":"api/exceptions_public.html#CTBase.Exceptions.PreconditionError","page":"Public","title":"CTBase.Exceptions.PreconditionError","text":"PreconditionError <: CTException\n\nException thrown when a function call violates a precondition or is not allowed in the current state of the object or system.\n\nThis exception signals that the arguments may be valid, but the call is forbidden because of when or how it is made. This is distinct from IncorrectArgument, which indicates a problem with the input values themselves.\n\nCommon use cases:\n\nA method that is meant to be called only once\nState already closed or finalized\nRequired setup not completed (e.g., state must be set before dynamics)\nIllegal order of operations\nWrong phase of a computation\n\nFields\n\nmsg::String: Main error message\nreason::Union{String, Nothing}: Why the precondition failed (optional)\nsuggestion::Union{String, Nothing}: How to fix the problem (optional)\ncontext::Union{String, Nothing}: Where the error occurred (optional)\n\nExamples\n\njulia> using CTBase\n\njulia> throw(CTBase.Exceptions.PreconditionError(\"state must be set before dynamics\"))\nERROR: PreconditionError: state must be set before dynamics\n\nTypical pattern for checking preconditions (as used in CTModels.jl):\n\nfunction dynamics!(ocp::PreModel, f::Function)\n    if !__is_state_set(ocp)\n        throw(CTBase.Exceptions.PreconditionError(\n            \"State must be set before defining dynamics\",\n            reason=\"state has not been defined yet\",\n            suggestion=\"Call state!(ocp, dimension) before dynamics!\",\n            context=\"dynamics! function - state validation\"\n        ))\n    end\n    # ... set dynamics ...\nend\n\nEnhanced version with detailed context:\n\nthrow(CTBase.Exceptions.PreconditionError(\n    \"Cannot call state! twice\",\n    reason=\"state has already been defined for this OCP\",\n    suggestion=\"Create a new OCP instance or use a different component name\",\n    context=\"state definition\"\n))\n\nSee Also\n\nIncorrectArgument: For input validation errors\nNotImplemented: For unimplemented interface methods\n\n\n\n\n\n","category":"type"},{"location":"api/test_runner.html#Private-API","page":"TestRunner","title":"Private API","text":"This page lists non-exported (internal) symbols of TestRunner.\n\n","category":"section"},{"location":"api/test_runner.html#From-TestRunner","page":"TestRunner","title":"From TestRunner","text":"","category":"section"},{"location":"api/test_runner.html#TestRunInfo","page":"TestRunner","title":"TestRunInfo","text":"","category":"section"},{"location":"api/test_runner.html#TestSpec","page":"TestRunner","title":"TestSpec","text":"","category":"section"},{"location":"api/test_runner.html#_bar_width","page":"TestRunner","title":"_bar_width","text":"","category":"section"},{"location":"api/test_runner.html#_builder_to_string","page":"TestRunner","title":"_builder_to_string","text":"","category":"section"},{"location":"api/test_runner.html#_collect_test_files_recursive","page":"TestRunner","title":"_collect_test_files_recursive","text":"","category":"section"},{"location":"api/test_runner.html#_default_on_test_done","page":"TestRunner","title":"_default_on_test_done","text":"","category":"section"},{"location":"api/test_runner.html#_ensure_jl","page":"TestRunner","title":"_ensure_jl","text":"","category":"section"},{"location":"api/test_runner.html#_find_symbol_test_file_rel","page":"TestRunner","title":"_find_symbol_test_file_rel","text":"","category":"section"},{"location":"api/test_runner.html#_format_progress_line","page":"TestRunner","title":"_format_progress_line","text":"","category":"section"},{"location":"api/test_runner.html#_glob_to_regex","page":"TestRunner","title":"_glob_to_regex","text":"","category":"section"},{"location":"api/test_runner.html#_has_failures_in_results","page":"TestRunner","title":"_has_failures_in_results","text":"","category":"section"},{"location":"api/test_runner.html#_normalize_available_tests","page":"TestRunner","title":"_normalize_available_tests","text":"","category":"section"},{"location":"api/test_runner.html#_normalize_selections","page":"TestRunner","title":"_normalize_selections","text":"","category":"section"},{"location":"api/test_runner.html#_parse_test_args","page":"TestRunner","title":"_parse_test_args","text":"","category":"section"},{"location":"api/test_runner.html#_progress_bar","page":"TestRunner","title":"_progress_bar","text":"","category":"section"},{"location":"api/test_runner.html#_resolve_test","page":"TestRunner","title":"_resolve_test","text":"","category":"section"},{"location":"api/test_runner.html#_run_single_test","page":"TestRunner","title":"_run_single_test","text":"","category":"section"},{"location":"api/test_runner.html#_select_tests","page":"TestRunner","title":"_select_tests","text":"","category":"section"},{"location":"api/test_runner.html#_strip_test_prefix","page":"TestRunner","title":"_strip_test_prefix","text":"","category":"section"},{"location":"api/test_runner.html#TestRunner.TestRunInfo","page":"TestRunner","title":"TestRunner.TestRunInfo","text":"struct TestRunInfo\n\nContext information passed to test callbacks (on_test_start, on_test_done).\n\nProvides details about the current test being executed, including progress information (index, total) and execution results (status, error, elapsed).\n\nFields\n\nspec::TestSpec: test identifier (Symbol or relative path String)\nfilename::String: absolute path of the included test file\nfunc_symbol::Union{Symbol,Nothing}: function to call (nothing if eval_mode=false)\nindex::Int: 1-based index of the current test in the selected list\ntotal::Int: total number of selected tests\nstatus::Symbol: one of :pre_eval, :post_eval, :skipped, :error, :test_failed\nerror::Union{Exception,Nothing}: captured exception when status == :error\nelapsed::Union{Float64,Nothing}: wall-clock seconds for the eval phase (only in on_test_done)\n\nExample\n\njulia> using CTBase.TestRunner\n\njulia> info = TestRunner.TestRunInfo(\n           :utils, \n           \"/path/to/test_utils.jl\", \n           :test_utils, \n           3, 10, \n           :post_eval, \n           nothing, \n           1.23\n       )\nTestRunner.TestRunInfo(:utils, \"/path/to/test_utils.jl\", :test_utils, 3, 10, :post_eval, nothing, 1.23)\n\njulia> info.status\n:post_eval\n\njulia> info.elapsed\n1.23\n\n\n\n\n\n","category":"type"},{"location":"api/test_runner.html#TestRunner.TestSpec","page":"TestRunner","title":"TestRunner.TestSpec","text":"Union type representing a test specification.\n\nA test spec can be either:\n\nSymbol: A logical test name (e.g., :utils, :core)\nString: A relative file path or glob pattern (e.g., \"suite/test_utils.jl\", \"suite/core/*\")\n\nThis type is used throughout TestRunner to represent both user-provided selections and internal test identifiers.\n\nNotes\n\nSymbol specs are resolved via filename_builder and funcname_builder\nString specs are treated as relative paths from test_dir\nGlob patterns are supported for String specs\n\nSee also: CTBase.run_tests, TestRunner._select_tests\n\n\n\n\n\n","category":"type"},{"location":"api/test_runner.html#TestRunner._bar_width","page":"TestRunner","title":"TestRunner._bar_width","text":"_bar_width(total::Int64) -> Int64\n\n\nCompute the progress bar character width based on the number of tests.\n\ntotal ≤ 20: width equals total (one block per test).\ntotal > 20: fixed width of 20 (some tests skip a block advance).\n\nArguments\n\ntotal::Int: Total number of tests\n\nReturns\n\nInt: Character width for the progress bar (0 if total ≤ 0)\n\nExample\n\njulia> using CTBase.TestRunner\n\njulia> TestRunner._bar_width(10)\n10\n\njulia> TestRunner._bar_width(25)\n20\n\njulia> TestRunner._bar_width(0)\n0\n\n\n\n\n\n","category":"function"},{"location":"api/test_runner.html#TestRunner._builder_to_string","page":"TestRunner","title":"TestRunner._builder_to_string","text":"_builder_to_string(x) -> String\n\nConvert a Symbol or String to String.\n\nThis helper function ensures that builder function outputs are always converted to strings for consistent handling.\n\nArguments\n\nx: Symbol or String to convert\n\nReturns\n\nString: The string representation of x\n\nExample\n\njulia> TestRunner._builder_to_string(:utils)\n\"utils\"\n\njulia> TestRunner._builder_to_string(\"utils\")\n\"utils\"\n\n\n\n\n\n","category":"function"},{"location":"api/test_runner.html#TestRunner._collect_test_files_recursive","page":"TestRunner","title":"TestRunner._collect_test_files_recursive","text":"_collect_test_files_recursive(test_dir::AbstractString) -> Vector{String}\n\nRecursively collect all .jl files in test_dir (excluding runtests.jl).\n\nReturns relative paths from test_dir, sorted alphabetically.\n\nArguments\n\ntest_dir::AbstractString: Root directory to search\n\nReturns\n\nVector{String}: Relative paths to all .jl files (excluding runtests.jl)\n\nExample\n\n# Assuming test_dir contains:\n# - test/utils.jl\n# - test/core/test_core.jl\n# - test/runtests.jl\n\njulia> TestRunner._collect_test_files_recursive(\"test\")\n2-element Vector{String}:\n \"test/core/test_core.jl\"\n \"test/utils.jl\"\n\n\n\n\n\n","category":"function"},{"location":"api/test_runner.html#TestRunner._default_on_test_done","page":"TestRunner","title":"TestRunner._default_on_test_done","text":"_default_on_test_done(info::TestRunner.TestRunInfo)\n\n\nDefault progress callback for on_test_done. Prints to stdout.\n\nArguments\n\ninfo::TestRunInfo: Test execution information to display\n\nNotes\n\nThis is the default callback used when progress=true and no custom on_test_done is provided\nOutputs a formatted progress line to stdout with colors and timing information\n\nExample\n\njulia> using CTBase.TestRunner\n\njulia> info = TestRunner.TestRunInfo(\n           :test_example, \n           \"/path/to/test.jl\", \n           :test_example, \n           5, 10, \n           :post_eval, \n           nothing, \n           1.23\n       );\n\njulia> TestRunner._default_on_test_done(info)\n[█████░░░░░░░░░░░] ✓ [05/10] test_example (1.2s)\n\n\n\n\n\n","category":"function"},{"location":"api/test_runner.html#TestRunner._ensure_jl","page":"TestRunner","title":"TestRunner._ensure_jl","text":"_ensure_jl(filename::AbstractString) -> String\n\nEnsure that a filename ends with .jl extension.\n\nIf the filename already ends with .jl, returns it unchanged. Otherwise, appends .jl to the filename.\n\nArguments\n\nfilename::AbstractString: Base filename with or without .jl extension\n\nReturns\n\nString: Filename guaranteed to end with .jl\n\nExample\n\njulia> TestRunner._ensure_jl(\"test_utils\")\n\"test_utils.jl\"\n\njulia> TestRunner._ensure_jl(\"test_utils.jl\")\n\"test_utils.jl\"\n\n\n\n\n\n","category":"function"},{"location":"api/test_runner.html#TestRunner._find_symbol_test_file_rel","page":"TestRunner","title":"TestRunner._find_symbol_test_file_rel","text":"_find_symbol_test_file_rel(name::Symbol, filename_builder::Function; test_dir::AbstractString) -> Union{String,Nothing}\n\nFind the relative path to a test file for a given symbol name.\n\nUses the filename_builder to construct the expected filename, then searches for files matching that basename. If multiple matches exist (e.g., files in different subdirectories), prefers the shallowest path.\n\nArguments\n\nname::Symbol: Test name to resolve\nfilename_builder::Function: Function that maps test names to filenames\ntest_dir::AbstractString: Root directory containing test files\n\nReturns\n\nString: Relative path to the matching test file\nnothing: If no matching file is found\n\nNotes\n\nSearches recursively in test_dir\nExcludes runtests.jl from consideration\nPrefers shallower paths when multiple matches exist\nReturns the exact relative path if found\n\nSee also: TestRunner._collect_test_files_recursive, TestRunner._ensure_jl\n\n\n\n\n\n","category":"function"},{"location":"api/test_runner.html#TestRunner._format_progress_line","page":"TestRunner","title":"TestRunner._format_progress_line","text":"_format_progress_line(io::IO, info::TestRunner.TestRunInfo)\n\n\nWrite a styled progress line for a completed test to io.\n\nUses ANSI colors: green for success, red for errors, yellow for skipped.\n\nArguments\n\nio::IO: Output stream to write to\ninfo::TestRunInfo: Test execution information\n\nNotes\n\nFormat: [progress_bar] symbol [index/total] spec (time) status\nColors: green for success, red for errors, yellow for skipped\nTime is displayed with one decimal place when available\n\nExample\n\njulia> using CTBase.TestRunner, IOBuffer\n\njulia> info = TestRunner.TestRunInfo(\n           :test_example, \n           \"/path/to/test.jl\", \n           :test_example, \n           5, 10, \n           :post_eval, \n           nothing, \n           1.23\n       );\n\njulia> buf = IOBuffer();\njulia> TestRunner._format_progress_line(buf, info);\njulia> String(take!(buf))\n\"[█████░░░░░░░░░░░] ✓ [05/10] test_example (1.2s)\"\n\n\n\n\n\n","category":"function"},{"location":"api/test_runner.html#TestRunner._glob_to_regex","page":"TestRunner","title":"TestRunner._glob_to_regex","text":"_glob_to_regex(pattern::AbstractString) -> Regex\n\n\nConvert a glob pattern (using * and ?) into a regular expression.\n\nThe returned regex is anchored (matches the full string).\n\nArguments\n\npattern::AbstractString: Glob pattern to convert\n\nReturns\n\nRegex: Anchored regular expression equivalent to the glob pattern\n\nExample\n\njulia> using CTBase.TestRunner\n\njulia> TestRunner._glob_to_regex(\"test_*.jl\")\nr\"^test_.*\\.jl$\"\n\njulia> TestRunner._glob_to_regex(\"suite/test_?.jl\")\nr\"^suite/test.\\.jl$\"\n\n\n\n\n\n","category":"function"},{"location":"api/test_runner.html#TestRunner._has_failures_in_results","page":"TestRunner","title":"TestRunner._has_failures_in_results","text":"_has_failures_in_results(ts::Test.DefaultTestSet) -> Bool\n_has_failures_in_results(\n    ts::Test.DefaultTestSet,\n    from::Int64\n) -> Bool\n\n\nRecursively scan a DefaultTestSet results for Test.Fail or Test.Error entries, starting at index from.\n\nThis is used to detect @test failures that occurred during a specific eval by comparing the results count before and after the eval. The anynonpass field is unreliable because it is only updated when a testset finishes (in Test.finish).\n\nArguments\n\nts::Test.DefaultTestSet: TestSet to scan\nfrom::Int: Starting index for scanning (default: 1)\n\nReturns\n\nBool: true if any failures are found, false otherwise\n\nExample\n\njulia> using CTBase.TestRunner, Test\n\njulia> ts = Test.DefaultTestSet(\"test\", [])\njulia> Test.@testset \"example\" begin\n           Test.@test 1 == 1\n           Test.@test 2 == 0  # This will fail\n       end\nTest.DefaultTestSet(\"example\", Any[Test.Pass(1), Test.Fail(\"false\")])\n\njulia> TestRunner._has_failures_in_results(ts)\ntrue\n\n\n\n\n\n","category":"function"},{"location":"api/test_runner.html#TestRunner._normalize_available_tests","page":"TestRunner","title":"TestRunner._normalize_available_tests","text":"_normalize_available_tests(available_tests) -> Vector{TestSpec}\n\nNormalize and validate the available_tests argument.\n\nConverts the input to a Vector{TestSpec} and validates that all entries are either Symbol or String. Returns an empty vector if available_tests is nothing.\n\nArguments\n\navailable_tests: nothing, Vector, or Tuple containing Symbol or String entries\n\nReturns\n\nVector{TestSpec}: Normalized vector of test specifications\n\nThrows\n\nArgumentError: If available_tests is not a Vector/Tuple or contains invalid entries\n\nExample\n\njulia> TestRunner._normalize_available_tests([:utils, \"suite/*\"])\n2-element Vector{Union{Symbol, String}}:\n :utils\n \"suite/*\"\n\njulia> TestRunner._normalize_available_tests(nothing)\nUnion{Symbol, String}[]\n\n\n\n\n\n","category":"function"},{"location":"api/test_runner.html#TestRunner._normalize_selections","page":"TestRunner","title":"TestRunner._normalize_selections","text":"_normalize_selections(\n    selections::Vector{String},\n    candidates::Vector{<:Union{String, Symbol}}\n) -> Vector{String}\n\n\nNormalize user-provided selection patterns before glob matching.\n\nApplied transformations:\n\nStrip trailing / (e.g. \"suite/exceptions/\" → \"suite/exceptions\")\nIf a selection contains no glob wildcard (* or ?) and matches a directory prefix of at least one candidate, expand it to \"selection/*\" so that all files under that directory are selected.\n\nThe original selection is always kept so that exact-name matches still work.\n\nArguments\n\nselections::Vector{String}: User-provided selection patterns\ncandidates::Vector{<:TestSpec}: Available test candidates\n\nReturns\n\nVector{String}: Normalized selection patterns\n\nExample\n\njulia> using CTBase.TestRunner\n\njulia> TestRunner._normalize_selections(\n           [\"suite/\"], \n           [\"suite/test_a.jl\", \"suite/test_b.jl\"]\n       )\n2-element Vector{String}:\n \"suite\"\n \"suite/*\"\n\n\n\n\n\n","category":"function"},{"location":"api/test_runner.html#TestRunner._parse_test_args","page":"TestRunner","title":"TestRunner._parse_test_args","text":"_parse_test_args(\n    args::Vector{String}\n) -> Tuple{Vector{String}, Bool, Bool}\n\n\nParse command-line test arguments, filtering out coverage-related flags.\n\nArguments\n\nargs::Vector{String}: Raw command-line arguments\n\nReturns\n\nTuple{Vector{String}, Bool, Bool}: (selections, run_all, dry_run) where:\nselections: selection patterns provided by the user (as strings)\nrun_all: whether -a / --all was present\ndry_run: whether -n / --dryrun was present\n\nNotes\n\nCoverage flags (coverage=true, --coverage, etc.) are automatically filtered out\nSelection patterns starting with test/ or test\\ are automatically stripped so that users can write test/suite/foo or suite/foo interchangeably\n\nExample\n\njulia> using CTBase.TestRunner\n\njulia> TestRunner._parse_test_args([\"utils\", \"-a\", \"--dryrun\"])\n([\"utils\"], true, true)\n\njulia> TestRunner._parse_test_args([\"test/suite\", \"coverage=true\"])\n([\"suite\"], false, false)\n\n\n\n\n\n","category":"function"},{"location":"api/test_runner.html#TestRunner._progress_bar","page":"TestRunner","title":"TestRunner._progress_bar","text":"_progress_bar(index::Int64, total::Int64; width) -> String\n\n\nRender a progress bar string like [████████░░░░░░░░░░░].\n\nWhen width is nothing (default), the width is computed automatically via _bar_width(total). Returns an empty string when the bar is hidden.\n\nArguments\n\nindex::Int: current progress (1-based)\ntotal::Int: total number of items\nwidth::Union{Int,Nothing}: character width of the bar (default: auto)\n\nReturns\n\nString: Progress bar string, or empty string if hidden\n\nExample\n\njulia> using CTBase.TestRunner\n\njulia> TestRunner._progress_bar(5, 10)\n\"[█████░░░░░]\"\n\njulia> TestRunner._progress_bar(5, 10; width=20)\n\"[████████████████████░░░░░░]\"\n\njulia> TestRunner._progress_bar(0, 10; width=5)\n\"[░░░░░]\"\n\n\n\n\n\n","category":"function"},{"location":"api/test_runner.html#TestRunner._resolve_test","page":"TestRunner","title":"TestRunner._resolve_test","text":"_resolve_test(\n    spec::Union{String, Symbol};\n    available_tests,\n    filename_builder,\n    funcname_builder,\n    eval_mode,\n    test_dir\n)\n\n\nResolve a test spec into an absolute filename and function symbol.\n\nHandles both String specs (relative paths) and Symbol specs (logical names). Raises errors if the file is not found or if eval_mode=true but no function can be determined.\n\nArguments\n\nspec::TestSpec: Test specification to resolve\navailable_tests::AbstractVector{<:TestSpec}: Available tests for validation\nfilename_builder::Function: Function to map test names to filenames\nfuncname_builder::Function: Function to map test names to function names\neval_mode::Bool: Whether to resolve a function name\ntest_dir::String: Root directory containing test files\n\nReturns\n\nTuple{String, Union{Symbol,Nothing}}: (filename, func_symbol) where:\nfilename: Absolute path to the test file\nfunc_symbol: Function symbol to call (or nothing if eval_mode=false)\n\nThrows\n\nErrorException: If the test file is not found\nErrorException: If eval_mode=true but no function can be determined\n\nNotes\n\nThis function is not part of the public API\nUse run_tests for running tests with proper error handling\n\n\n\n\n\n","category":"function"},{"location":"api/test_runner.html#TestRunner._run_single_test","page":"TestRunner","title":"TestRunner._run_single_test","text":"_run_single_test(\n    spec::Union{String, Symbol};\n    available_tests,\n    filename_builder,\n    funcname_builder,\n    eval_mode,\n    test_dir,\n    index,\n    total,\n    on_test_start,\n    on_test_done\n)\n\n\nRun a single selected test.\n\nThis helper:\n\nResolves a test filename via filename_builder\nIncludes the file into Main\nCalls on_test_start (if provided) after include, before eval\nOptionally evaluates a function (via funcname_builder) when eval_mode=true\nCalls on_test_done (if provided) after eval, skip, or error\n\nArguments\n\nspec::TestSpec: Test specification to run\navailable_tests::AbstractVector{<:TestSpec}: Available tests for validation\nfilename_builder::Function: Function to map test names to filenames\nfuncname_builder::Function: Function to map test names to function names\neval_mode::Bool: Whether to evaluate the function after include\ntest_dir::String: Root directory containing test files\nindex::Int: 1-based index in the selected list (default: 1)\ntotal::Int: Total number of selected tests (default: 1)\non_test_start::Union{Function,Nothing}: Callback before eval (default: nothing)\non_test_done::Union{Function,Nothing}: Callback after eval (default: nothing)\n\nNotes\n\nThis function is not part of the public API\nUse run_tests for running multiple tests with proper orchestration\n\n\n\n\n\n","category":"function"},{"location":"api/test_runner.html#TestRunner._select_tests","page":"TestRunner","title":"TestRunner._select_tests","text":"_select_tests(\n    selections::Vector{String},\n    available_tests::AbstractVector{<:Union{String, Symbol}},\n    run_all::Bool,\n    filename_builder::Function;\n    test_dir\n) -> Vector{Union{String, Symbol}}\n\n\nDetermine which tests to run based on selections, available_tests filter, and file globbing.\n\nIdentify potential test files in test_dir (default: test/).\nFilter by available_tests if provided.\nFilter by selections (interpreted as globs) if present.\n\nArguments\n\nselections::Vector{String}: User-provided selection patterns\navailable_tests::AbstractVector{<:TestSpec}: Allowed tests (empty = auto-discovery)\nrun_all::Bool: Whether to run all available tests\nfilename_builder::Function: Function to map test names to filenames\ntest_dir::String: Root directory containing test files\n\nReturns\n\nVector{TestSpec}: Selected test specifications\n\nNotes\n\nIf available_tests is empty, this function falls back to an auto-discovery heuristic using the filename stem as the candidate test name\nSelection arguments are matched against multiple representations of each candidate\n\n\n\n\n\n","category":"function"},{"location":"api/test_runner.html#TestRunner._strip_test_prefix","page":"TestRunner","title":"TestRunner._strip_test_prefix","text":"_strip_test_prefix(s::AbstractString) -> Any\n\n\nStrip a leading test/ or test\\ prefix from a selection pattern.\n\nThis allows users to type test/suite/foo instead of suite/foo since the test directory is already the root for pattern matching.\n\nArguments\n\ns::AbstractString: Selection pattern to process\n\nReturns\n\nString: Pattern with test/ or test\\ prefix stripped (if present)\n\nExample\n\njulia> using CTBase.TestRunner\n\njulia> TestRunner._strip_test_prefix(\"test/suite/foo\")\n\"suite/foo\"\n\njulia> TestRunner._strip_test_prefix(\"suite/foo\")\n\"suite/foo\"\n\njulia> TestRunner._strip_test_prefix(\"test\\windows\\path\")\n\"windows\\path\"\n\n\n\n\n\n","category":"function"},{"location":"api/descriptions_private.html#Private-API","page":"Private","title":"Private API","text":"This page lists non-exported (internal) symbols of CTBase.Descriptions.\n\n","category":"section"},{"location":"api/descriptions_private.html#From-CTBase.Descriptions","page":"Private","title":"From CTBase.Descriptions","text":"","category":"section"},{"location":"api/descriptions_private.html#compute_similarity","page":"Private","title":"compute_similarity","text":"","category":"section"},{"location":"api/descriptions_private.html#find_similar_descriptions","page":"Private","title":"find_similar_descriptions","text":"","category":"section"},{"location":"api/descriptions_private.html#format_description_candidates","page":"Private","title":"format_description_candidates","text":"","category":"section"},{"location":"api/descriptions_private.html#CTBase.Descriptions.compute_similarity","page":"Private","title":"CTBase.Descriptions.compute_similarity","text":"compute_similarity(\n    desc1::Tuple{Vararg{Symbol}},\n    desc2::Tuple{Vararg{Symbol}}\n) -> Float64\n\n\nCompute similarity between two descriptions based on the Jaccard index of their symbols.\n\nArguments\n\ndesc1::Description: First description to compare\ndesc2::Description: Second description to compare\n\nReturns\n\nFloat64: A value between 0.0 (no similarity) and 1.0 (identical)\n\nExample\n\njulia> using CTBase\n\njulia> CTBase.Descriptions.compute_similarity((:a, :b), (:a, :c))\n0.5\njulia> CTBase.Descriptions.compute_similarity((:a, :b), (:a, :b))\n1.0\njulia> CTBase.Descriptions.compute_similarity((:x, :y), (:a, :b))\n0.0\n\n\n\n\n\n","category":"function"},{"location":"api/descriptions_private.html#CTBase.Descriptions.find_similar_descriptions","page":"Private","title":"CTBase.Descriptions.find_similar_descriptions","text":"find_similar_descriptions(\n    target::Tuple{Vararg{Symbol}},\n    descriptions::Tuple{Vararg{Tuple{Vararg{Symbol}}}};\n    max_results\n) -> Vector{String}\n\n\nFind descriptions most similar to the target description based on symbol overlap.\n\nArguments\n\ntarget::Tuple{Vararg{Symbol}}: The partial or incorrect description to match\ndescriptions::Tuple{Vararg{Description}}: A catalog of valid descriptions\n\nKeyword Arguments\n\nmax_results::Int=5: Maximum number of similar descriptions to return\n\nReturns\n\nVector{String}: Formatted string representations of the most similar descriptions\n\nExample\n\njulia> using CTBase\n\njulia> descriptions = ((:a, :b), (:a, :c), (:x, :y))\njulia> CTBase.Descriptions.find_similar_descriptions((:a,), descriptions)\n2-element Vector{String}:\n \"(:a, :b)\"\n \"(:a, :c)\"\n\n\n\n\n\n","category":"function"},{"location":"api/descriptions_private.html#CTBase.Descriptions.format_description_candidates","page":"Private","title":"CTBase.Descriptions.format_description_candidates","text":"format_description_candidates(\n    descriptions::Tuple{Vararg{Tuple{Vararg{Symbol}}}};\n    max_show\n) -> Vector{String}\n\n\nFormat description candidates from a catalog for display in error messages.\n\nArguments\n\ndescriptions::Tuple{Vararg{Description}}: A catalog of descriptions\n\nKeyword Arguments\n\nmax_show::Int=5: Maximum number of descriptions to include in the output\n\nReturns\n\nVector{String}: A vector of formatted description strings\n\nExample\n\njulia> using CTBase\n\njulia> descriptions = ((:a, :b), (:a, :c), (:x, :y), (:p, :q))\njulia> CTBase.Descriptions.format_description_candidates(descriptions; max_show=3)\n3-element Vector{String}:\n \"(:a, :b)\"\n \"(:a, :c)\"\n \"(:x, :y)\"\n\n\n\n\n\n","category":"function"},{"location":"api/core_public.html#Public-API","page":"Public","title":"Public API","text":"This page lists exported symbols of CTBase.Core.\n\n","category":"section"},{"location":"api/core_public.html#From-CTBase.Core","page":"Public","title":"From CTBase.Core","text":"","category":"section"},{"location":"api/core_public.html#ctNumber","page":"Public","title":"ctNumber","text":"","category":"section"},{"location":"api/core_public.html#CTBase.Core.ctNumber","page":"Public","title":"CTBase.Core.ctNumber","text":"Type alias for a real number.\n\nThis constant is primarily meant as a short, semantic alias when writing APIs that accept real-valued quantities.\n\nExample\n\njulia> using CTBase\n\njulia> CTBase.ctNumber === Real\ntrue\n\n\n\n\n\n","category":"type"},{"location":"guide/descriptions.html#Descriptions:-encoding-algorithms","page":"Descriptions","title":"Descriptions: encoding algorithms","text":"One of the central ideas in CTBase.jl is the notion of a description. A description is simply a tuple of Symbols that encodes an algorithm or configuration in a declarative way.\n\nFormally, CTBase defines:\n\nconst DescVarArg = Vararg{Symbol}\nconst Description = Tuple{DescVarArg}\n\nFor example, the tuple\n\njulia> using CTBase\n\njulia> d = (:descent, :bfgs, :bisection)\n(:descent, :bfgs, :bisection)\n\njulia> typeof(d) <: CTBase.Description\ntrue\n\ncan be read as “a descent algorithm, with BFGS directions and a bisection line search”. Higher-level packages in the control-toolbox ecosystem use descriptions to catalogue algorithms in a uniform way.","category":"section"},{"location":"guide/descriptions.html#Building-a-library-of-descriptions","page":"Descriptions","title":"Building a library of descriptions","text":"CTBase provides a few small functions to manage collections of descriptions:\n\nCTBase.add(x, y) adds the description y to the tuple of descriptions x, rejecting duplicates with an IncorrectArgument exception.\nCTBase.complete(list; descriptions=D) picks a complete description from a set D based on a partial list of symbols.\nCTBase.remove(x, y) returns the set difference of two descriptions.\n\nHere is a complete example of a small “algorithm library”:\n\njulia> algorithms = ()\n()\n\njulia> algorithms = CTBase.add(algorithms, (:descent, :bfgs, :bisection))\n((:descent, :bfgs, :bisection),)\n\njulia> algorithms = CTBase.add(algorithms, (:descent, :gradient, :fixedstep))\n((:descent, :bfgs, :bisection), (:descent, :gradient, :fixedstep))\n\njulia> display(algorithms)\n(:descent, :bfgs, :bisection)\n(:descent, :gradient, :fixedstep)\n\nGiven this library, we can complete a partial description:\n\njulia> CTBase.complete((:descent,); descriptions=algorithms)\n(:descent, :bfgs, :bisection)\n\njulia> CTBase.complete((:gradient, :fixedstep); descriptions=algorithms)\n(:descent, :gradient, :fixedstep)\n\nInternally, CTBase.complete scans the descriptions tuple from top to bottom. For each candidate description it computes:\n\nhow many symbols it shares with the partial list, and\nwhether the partial list is a subset of the full description.\n\nIf no description contains all the symbols from the partial list, AmbiguousDescription is thrown. Otherwise, among the descriptions that do contain the partial list, CTBase selects the one with the largest intersection; if several have the same score, the first one in the descriptions tuple wins. In other words, the order of descriptions encodes a priority from top to bottom.\n\nWith this mechanism in place, we can then analyse the remainder of a description by removing a prefix:\n\njulia> full = CTBase.complete((:descent,); descriptions=algorithms)\n(:descent, :bfgs, :bisection)\n\njulia> CTBase.remove(full, (:descent, :bfgs))\n(:bisection,)\n\nThis “description language” lets higher-level packages refer to algorithms in a structured, composable way, while CTBase takes care of the low-level operations (adding, completing, and comparing descriptions).","category":"section"},{"location":"guide/descriptions.html#Function-Reference","page":"Descriptions","title":"Function Reference","text":"Function Purpose Returns Throws\nadd(x, y) Add description y to collection x Updated tuple IncorrectArgument if duplicate\ncomplete(list; descriptions=D) Find complete description matching partial list Complete description AmbiguousDescription if no match\nremove(x, y) Remove symbols in y from description x Remaining symbols -","category":"section"},{"location":"guide/descriptions.html#Error-Handling","page":"Descriptions","title":"Error Handling","text":"The description system uses CTBase exceptions to signal problems:","category":"section"},{"location":"guide/descriptions.html#Duplicate-Descriptions","page":"Descriptions","title":"Duplicate Descriptions","text":"using CTBase\nalgorithms = CTBase.add((), (:a, :b))\nCTBase.add(algorithms, (:a, :b))  # Error: duplicate\n\nThis throws IncorrectArgument because adding a duplicate would create ambiguity.","category":"section"},{"location":"guide/descriptions.html#Ambiguous-or-Invalid-Descriptions","page":"Descriptions","title":"Ambiguous or Invalid Descriptions","text":"using CTBase\nD = ((:a, :b), (:c, :d))\nCTBase.complete((:x,); descriptions=D)  # Error: no match\n\nThis throws AmbiguousDescription when no description in the library contains all the requested symbols.","category":"section"},{"location":"guide/descriptions.html#Best-Practices","page":"Descriptions","title":"Best Practices","text":"Order matters: Place more specific descriptions first in your library\nUse meaningful symbols: Choose symbols that clearly describe the algorithm\nKeep it simple: Descriptions should be short and focused\nHandle errors: Always catch AmbiguousDescription when using complete\nDocument your descriptions: Maintain a list of valid descriptions for your package","category":"section"},{"location":"guide/descriptions.html#See-Also","page":"Descriptions","title":"See Also","text":"Exception Handling: Understanding CTBase exceptions","category":"section"},{"location":"api/documenter_reference.html#Private-API","page":"DocumenterReference","title":"Private API","text":"This page lists non-exported (internal) symbols of DocumenterReference.\n\n","category":"section"},{"location":"api/documenter_reference.html#From-DocumenterReference","page":"DocumenterReference","title":"From DocumenterReference","text":"","category":"section"},{"location":"api/documenter_reference.html#APIBuilder","page":"DocumenterReference","title":"APIBuilder","text":"","category":"section"},{"location":"api/documenter_reference.html#CONFIG","page":"DocumenterReference","title":"CONFIG","text":"","category":"section"},{"location":"api/documenter_reference.html#DOCTYPE_NAMES","page":"DocumenterReference","title":"DOCTYPE_NAMES","text":"","category":"section"},{"location":"api/documenter_reference.html#DOCTYPE_ORDER","page":"DocumenterReference","title":"DOCTYPE_ORDER","text":"","category":"section"},{"location":"api/documenter_reference.html#DocType","page":"DocumenterReference","title":"DocType","text":"","category":"section"},{"location":"api/documenter_reference.html#PAGE_CONTENT_ACCUMULATOR","page":"DocumenterReference","title":"PAGE_CONTENT_ACCUMULATOR","text":"","category":"section"},{"location":"api/documenter_reference.html#_Config","page":"DocumenterReference","title":"_Config","text":"","category":"section"},{"location":"api/documenter_reference.html#_build_api_page","page":"DocumenterReference","title":"_build_api_page","text":"","category":"section"},{"location":"api/documenter_reference.html#_build_combined_page_content","page":"DocumenterReference","title":"_build_combined_page_content","text":"","category":"section"},{"location":"api/documenter_reference.html#_build_page_path","page":"DocumenterReference","title":"_build_page_path","text":"","category":"section"},{"location":"api/documenter_reference.html#_build_page_return_structure","page":"DocumenterReference","title":"_build_page_return_structure","text":"","category":"section"},{"location":"api/documenter_reference.html#_build_private_page_content","page":"DocumenterReference","title":"_build_private_page_content","text":"","category":"section"},{"location":"api/documenter_reference.html#_build_public_page_content","page":"DocumenterReference","title":"_build_public_page_content","text":"","category":"section"},{"location":"api/documenter_reference.html#_classify_symbol","page":"DocumenterReference","title":"_classify_symbol","text":"","category":"section"},{"location":"api/documenter_reference.html#_collect_external_module_docstrings","page":"DocumenterReference","title":"_collect_external_module_docstrings","text":"","category":"section"},{"location":"api/documenter_reference.html#_collect_methods_from_source_files","page":"DocumenterReference","title":"_collect_methods_from_source_files","text":"","category":"section"},{"location":"api/documenter_reference.html#_collect_module_docstrings","page":"DocumenterReference","title":"_collect_module_docstrings","text":"","category":"section"},{"location":"api/documenter_reference.html#_collect_private_docstrings","page":"DocumenterReference","title":"_collect_private_docstrings","text":"","category":"section"},{"location":"api/documenter_reference.html#_default_basename","page":"DocumenterReference","title":"_default_basename","text":"","category":"section"},{"location":"api/documenter_reference.html#_default_title","page":"DocumenterReference","title":"_default_title","text":"","category":"section"},{"location":"api/documenter_reference.html#_exported_symbols","page":"DocumenterReference","title":"_exported_symbols","text":"","category":"section"},{"location":"api/documenter_reference.html#_finalize_api_pages","page":"DocumenterReference","title":"_finalize_api_pages","text":"","category":"section"},{"location":"api/documenter_reference.html#_format_datatype_for_docs","page":"DocumenterReference","title":"_format_datatype_for_docs","text":"","category":"section"},{"location":"api/documenter_reference.html#_format_type_for_docs","page":"DocumenterReference","title":"_format_type_for_docs","text":"","category":"section"},{"location":"api/documenter_reference.html#_format_type_param","page":"DocumenterReference","title":"_format_type_param","text":"","category":"section"},{"location":"api/documenter_reference.html#_get_effective_source_files","page":"DocumenterReference","title":"_get_effective_source_files","text":"","category":"section"},{"location":"api/documenter_reference.html#_get_source_file","page":"DocumenterReference","title":"_get_source_file","text":"","category":"section"},{"location":"api/documenter_reference.html#_get_source_from_docstring","page":"DocumenterReference","title":"_get_source_from_docstring","text":"","category":"section"},{"location":"api/documenter_reference.html#_get_source_from_methods","page":"DocumenterReference","title":"_get_source_from_methods","text":"","category":"section"},{"location":"api/documenter_reference.html#_has_documentation","page":"DocumenterReference","title":"_has_documentation","text":"","category":"section"},{"location":"api/documenter_reference.html#_iterate_over_symbols","page":"DocumenterReference","title":"_iterate_over_symbols","text":"","category":"section"},{"location":"api/documenter_reference.html#_method_signature_string","page":"DocumenterReference","title":"_method_signature_string","text":"","category":"section"},{"location":"api/documenter_reference.html#_normalize_paths","page":"DocumenterReference","title":"_normalize_paths","text":"","category":"section"},{"location":"api/documenter_reference.html#_parse_primary_modules","page":"DocumenterReference","title":"_parse_primary_modules","text":"","category":"section"},{"location":"api/documenter_reference.html#_passes_source_filter","page":"DocumenterReference","title":"_passes_source_filter","text":"","category":"section"},{"location":"api/documenter_reference.html#_register_config","page":"DocumenterReference","title":"_register_config","text":"","category":"section"},{"location":"api/documenter_reference.html#_to_string","page":"DocumenterReference","title":"_to_string","text":"","category":"section"},{"location":"api/documenter_reference.html#reset_config!","page":"DocumenterReference","title":"reset_config!","text":"","category":"section"},{"location":"api/documenter_reference.html#DocumenterReference.APIBuilder","page":"DocumenterReference","title":"DocumenterReference.APIBuilder","text":"APIBuilder <: Documenter.Builder.DocumentPipeline\n\nCustom Documenter pipeline stage for automatic API reference generation.\n\nThis builder is inserted into the Documenter pipeline at order 0.0 (before most other stages) to generate API reference pages from the configurations stored in CONFIG.\n\n\n\n\n\n","category":"type"},{"location":"api/documenter_reference.html#DocumenterReference.CONFIG","page":"DocumenterReference","title":"DocumenterReference.CONFIG","text":"CONFIG::Vector{_Config}\n\nGlobal configuration storage for API reference generation.\n\nEach call to CTBase.automatic_reference_documentation appends a new _Config entry to this vector. Use reset_config! to clear it between builds.\n\n\n\n\n\n","category":"constant"},{"location":"api/documenter_reference.html#DocumenterReference.DOCTYPE_NAMES","page":"DocumenterReference","title":"DocumenterReference.DOCTYPE_NAMES","text":"DOCTYPE_NAMES::Dict{DocType, String}\n\nMapping from DocType enum values to their human-readable string representations.\n\n\n\n\n\n","category":"constant"},{"location":"api/documenter_reference.html#DocumenterReference.DOCTYPE_ORDER","page":"DocumenterReference","title":"DocumenterReference.DOCTYPE_ORDER","text":"DOCTYPE_ORDER::Dict{DocType, Int}\n\nOrdering for DocType values used when sorting symbols for display. Lower values appear first.\n\n\n\n\n\n","category":"constant"},{"location":"api/documenter_reference.html#DocumenterReference.DocType","page":"DocumenterReference","title":"DocumenterReference.DocType","text":"DocType\n\nEnumeration of documentation element types recognized by the API reference generator.\n\nValues\n\nDOCTYPE_ABSTRACT_TYPE: An abstract type declaration\nDOCTYPE_CONSTANT: A constant binding (including non-function, non-type values)\nDOCTYPE_FUNCTION: A function or callable\nDOCTYPE_MACRO: A macro (name starts with @)\nDOCTYPE_MODULE: A submodule\nDOCTYPE_STRUCT: A concrete struct type\n\n\n\n\n\n","category":"type"},{"location":"api/documenter_reference.html#DocumenterReference.PAGE_CONTENT_ACCUMULATOR","page":"DocumenterReference","title":"DocumenterReference.PAGE_CONTENT_ACCUMULATOR","text":"PAGE_CONTENT_ACCUMULATOR::Dict{String, Vector{Tuple{Module, Vector{String}, Vector{String}}}}\n\nGlobal accumulator for multi-module combined pages. Maps output filename to a list of (module, publicdocstrings, privatedocstrings) tuples.\n\n\n\n\n\n","category":"constant"},{"location":"api/documenter_reference.html#DocumenterReference._Config","page":"DocumenterReference","title":"DocumenterReference._Config","text":"_Config\n\nInternal configuration for API reference generation.\n\nFields\n\ncurrent_module::Module: The module being documented.\nsubdirectory::String: Output directory for generated API pages.\nmodules::Dict{Module,Vector{String}}: Mapping of modules to their source files. When a module is specified as Module => files, the files are stored here.\nsort_by::Function: Custom sort function for symbols.\nexclude::Set{Symbol}: Symbol names to exclude from documentation.\npublic::Bool: Flag to generate public API page.\nprivate::Bool: Flag to generate private API page.\ntitle::String: Title displayed at the top of the generated page.\ntitle_in_menu::String: Title displayed in the navigation menu.\nsource_files::Vector{String}: Global source file paths (fallback if no module-specific files).\nfilename::String: Base filename (without extension) for the markdown file.\ninclude_without_source::Bool: If true, include symbols whose source file cannot be determined.\nexternal_modules_to_document::Vector{Module}: Additional modules to search for docstrings.\npublic_title::String: Custom title for public API page (empty string uses default).\nprivate_title::String: Custom title for private API page (empty string uses default).\npublic_description::String: Custom description for public API page (empty string uses default).\nprivate_description::String: Custom description for private API page (empty string uses default).\n\n\n\n\n\n","category":"type"},{"location":"api/documenter_reference.html#DocumenterReference._build_api_page","page":"DocumenterReference","title":"DocumenterReference._build_api_page","text":"_build_api_page(document::Documenter.Document, config::_Config)\n\nGenerate public and/or private API reference pages for a module. Accumulates content in PAGE_CONTENT_ACCUMULATOR for later finalization.\n\n\n\n\n\n","category":"function"},{"location":"api/documenter_reference.html#DocumenterReference._build_combined_page_content","page":"DocumenterReference","title":"DocumenterReference._build_combined_page_content","text":"_build_combined_page_content(modules_str, module_contents) -> Tuple{String, Vector{String}}\n\nBuild the overview and docstrings for a combined (Public + Private) API page.\n\n\n\n\n\n","category":"function"},{"location":"api/documenter_reference.html#DocumenterReference._build_page_path","page":"DocumenterReference","title":"DocumenterReference._build_page_path","text":"_build_page_path(subdirectory::String, filename::String) -> String\n\nBuild the page path by joining subdirectory and filename. Handles special cases where subdirectory is \".\" or empty.\n\n\n\n\n\n","category":"function"},{"location":"api/documenter_reference.html#DocumenterReference._build_page_return_structure","page":"DocumenterReference","title":"DocumenterReference._build_page_return_structure","text":"_build_page_return_structure(title_in_menu, subdirectory, filename, public, private) -> Pair\n\nBuild the return structure for automatic_reference_documentation.\n\n\n\n\n\n","category":"function"},{"location":"api/documenter_reference.html#DocumenterReference._build_private_page_content","page":"DocumenterReference","title":"DocumenterReference._build_private_page_content","text":"_build_private_page_content(modules_str, module_contents, is_split; custom_title=\"\", custom_description=\"\") -> Tuple{String, Vector{String}}\n\nBuild the overview and docstrings for a private API page.\n\nArguments\n\nmodules_str: Comma-separated list of module names\nmodule_contents: Vector of (module, publicdocs, privatedocs) tuples\nis_split: Whether this is part of a split public/private documentation\ncustom_title: Optional custom title (empty string uses default)\ncustom_description: Optional custom description (empty string uses default)\n\n\n\n\n\n","category":"function"},{"location":"api/documenter_reference.html#DocumenterReference._build_public_page_content","page":"DocumenterReference","title":"DocumenterReference._build_public_page_content","text":"_build_public_page_content(modules_str, module_contents, is_split; custom_title=\"\", custom_description=\"\") -> Tuple{String, Vector{String}}\n\nBuild the overview and docstrings for a public API page.\n\nArguments\n\nmodules_str: Comma-separated list of module names\nmodule_contents: Vector of (module, publicdocs, privatedocs) tuples\nis_split: Whether this is part of a split public/private documentation\ncustom_title: Optional custom title (empty string uses default)\ncustom_description: Optional custom description (empty string uses default)\n\n\n\n\n\n","category":"function"},{"location":"api/documenter_reference.html#DocumenterReference._classify_symbol","page":"DocumenterReference","title":"DocumenterReference._classify_symbol","text":"_classify_symbol(obj, name_str::String) -> DocType\n\nClassify a symbol by its type (function, macro, struct, constant, module, abstract type).\n\n\n\n\n\n","category":"function"},{"location":"api/documenter_reference.html#DocumenterReference._collect_external_module_docstrings","page":"DocumenterReference","title":"DocumenterReference._collect_external_module_docstrings","text":"_collect_external_module_docstrings(config::_Config) -> Vector{String}\n\nCollect docstrings for methods from external modules defined in source files.\n\n\n\n\n\n","category":"function"},{"location":"api/documenter_reference.html#DocumenterReference._collect_methods_from_source_files","page":"DocumenterReference","title":"DocumenterReference._collect_methods_from_source_files","text":"_collect_methods_from_source_files(mod::Module, source_files::Vector{String}) -> Dict{Symbol, Vector{Method}}\n\nCollect all methods from a module that are defined in the given source files.\n\n\n\n\n\n","category":"function"},{"location":"api/documenter_reference.html#DocumenterReference._collect_module_docstrings","page":"DocumenterReference","title":"DocumenterReference._collect_module_docstrings","text":"_collect_module_docstrings(config::_Config, symbol_list) -> Vector{String}\n\nCollect docstring blocks for symbols from the current module.\n\n\n\n\n\n","category":"function"},{"location":"api/documenter_reference.html#DocumenterReference._collect_private_docstrings","page":"DocumenterReference","title":"DocumenterReference._collect_private_docstrings","text":"_collect_private_docstrings(config::_Config, symbol_list) -> Vector{String}\n\nCollect docstring blocks for private symbols, including external module methods.\n\n\n\n\n\n","category":"function"},{"location":"api/documenter_reference.html#DocumenterReference._default_basename","page":"DocumenterReference","title":"DocumenterReference._default_basename","text":"_default_basename(filename::String, public::Bool, private::Bool) -> String\n\nCompute the default base filename for the generated markdown file.\n\n\n\n\n\n","category":"function"},{"location":"api/documenter_reference.html#DocumenterReference._default_title","page":"DocumenterReference","title":"DocumenterReference._default_title","text":"_default_title(public::Bool, private::Bool) -> String\n\nCompute the default title based on public/private flags. Returns empty string for single pages to use configured title.\n\n\n\n\n\n","category":"function"},{"location":"api/documenter_reference.html#DocumenterReference._exported_symbols","page":"DocumenterReference","title":"DocumenterReference._exported_symbols","text":"_exported_symbols(mod::Module) -> NamedTuple\n\nClassify all symbols in a module into exported and private categories. Returns a NamedTuple with exported and private fields, each containing sorted lists of (Symbol, DocType) pairs.\n\n\n\n\n\n","category":"function"},{"location":"api/documenter_reference.html#DocumenterReference._finalize_api_pages","page":"DocumenterReference","title":"DocumenterReference._finalize_api_pages","text":"_finalize_api_pages(document::Documenter.Document)\n\nFinalize all accumulated API pages by combining content from multiple modules.\n\n\n\n\n\n","category":"function"},{"location":"api/documenter_reference.html#DocumenterReference._format_datatype_for_docs","page":"DocumenterReference","title":"DocumenterReference._format_datatype_for_docs","text":"_format_datatype_for_docs(T::DataType) -> String\n\nFormat a DataType for use in @docs blocks.\n\n\n\n\n\n","category":"function"},{"location":"api/documenter_reference.html#DocumenterReference._format_type_for_docs","page":"DocumenterReference","title":"DocumenterReference._format_type_for_docs","text":"_format_type_for_docs(T) -> String\n\nFormat a type for use in Documenter's @docs block. Always fully qualifies types to avoid UndefVarError when Documenter evaluates in Main.\n\n\n\n\n\n","category":"function"},{"location":"api/documenter_reference.html#DocumenterReference._format_type_param","page":"DocumenterReference","title":"DocumenterReference._format_type_param","text":"_format_type_param(p) -> String\n\nFormat a type parameter (can be a type or a value like an integer).\n\n\n\n\n\n","category":"function"},{"location":"api/documenter_reference.html#DocumenterReference._get_effective_source_files","page":"DocumenterReference","title":"DocumenterReference._get_effective_source_files","text":"_get_effective_source_files(config::_Config) -> Vector{String}\n\nDetermine the effective source files for filtering symbols. Priority: module-specific files > global source_files > empty (no filtering).\n\n\n\n\n\n","category":"function"},{"location":"api/documenter_reference.html#DocumenterReference._get_source_file","page":"DocumenterReference","title":"DocumenterReference._get_source_file","text":"_get_source_file(mod::Module, key::Symbol, type::DocType) -> Union{String, Nothing}\n\nDetermine the source file path where a symbol is defined. Returns nothing if the source file cannot be determined.\n\n\n\n\n\n","category":"function"},{"location":"api/documenter_reference.html#DocumenterReference._get_source_from_docstring","page":"DocumenterReference","title":"DocumenterReference._get_source_from_docstring","text":"_get_source_from_docstring(mod::Module, key::Symbol) -> Union{String, Nothing}\n\nTry to get source file path from docstring metadata.\n\n\n\n\n\n","category":"function"},{"location":"api/documenter_reference.html#DocumenterReference._get_source_from_methods","page":"DocumenterReference","title":"DocumenterReference._get_source_from_methods","text":"_get_source_from_methods(obj) -> Union{String, Nothing}\n\nTry to get source file path from method definitions.\n\n\n\n\n\n","category":"function"},{"location":"api/documenter_reference.html#DocumenterReference._has_documentation","page":"DocumenterReference","title":"DocumenterReference._has_documentation","text":"_has_documentation(mod::Module, key::Symbol, type::DocType, modules::Dict) -> Bool\n\nCheck if a symbol has documentation. Logs a warning if not.\n\n\n\n\n\n","category":"function"},{"location":"api/documenter_reference.html#DocumenterReference._iterate_over_symbols","page":"DocumenterReference","title":"DocumenterReference._iterate_over_symbols","text":"_iterate_over_symbols(f, config, symbol_list)\n\nIterate over symbols, applying a function to each documented symbol. Filters symbols based on exclusion list, documentation presence, and source files.\n\n\n\n\n\n","category":"function"},{"location":"api/documenter_reference.html#DocumenterReference._method_signature_string","page":"DocumenterReference","title":"DocumenterReference._method_signature_string","text":"_method_signature_string(m::Method, mod::Module, key::Symbol) -> String\n\nGenerate a Documenter-compatible signature string for a method. Returns a string like Module.func(::Type1, ::Type2) for use in @docs blocks.\n\n\n\n\n\n","category":"function"},{"location":"api/documenter_reference.html#DocumenterReference._normalize_paths","page":"DocumenterReference","title":"DocumenterReference._normalize_paths","text":"_normalize_paths(paths) -> Vector{String}\n\nNormalize a collection of paths to absolute paths.\n\n\n\n\n\n","category":"function"},{"location":"api/documenter_reference.html#DocumenterReference._parse_primary_modules","page":"DocumenterReference","title":"DocumenterReference._parse_primary_modules","text":"_parse_primary_modules(primary_modules::Vector) -> Dict{Module, Vector{String}}\n\nParse the primary_modules argument into a dictionary mapping modules to their source files. Handles both plain modules and Module => files pairs.\n\n\n\n\n\n","category":"function"},{"location":"api/documenter_reference.html#DocumenterReference._passes_source_filter","page":"DocumenterReference","title":"DocumenterReference._passes_source_filter","text":"_passes_source_filter(mod, key, type, source_files, include_without_source) -> Bool\n\nCheck if a symbol passes the source file filter.\n\n\n\n\n\n","category":"function"},{"location":"api/documenter_reference.html#DocumenterReference._register_config","page":"DocumenterReference","title":"DocumenterReference._register_config","text":"_register_config(current_module, subdirectory, modules, sort_by, exclude, public, private, \n                 title, title_in_menu, source_files, filename, include_without_source, \n                 external_modules_to_document, public_title, private_title, \n                 public_description, private_description)\n\nCreate and register a _Config in the global CONFIG vector.\n\n\n\n\n\n","category":"function"},{"location":"api/documenter_reference.html#DocumenterReference._to_string","page":"DocumenterReference","title":"DocumenterReference._to_string","text":"_to_string(x::DocType) -> String\n\nConvert a DocType enumeration value to its string representation.\n\n\n\n\n\n","category":"function"},{"location":"api/documenter_reference.html#DocumenterReference.reset_config!","page":"DocumenterReference","title":"DocumenterReference.reset_config!","text":"reset_config!()\n\nClear the global CONFIG vector and PAGE_CONTENT_ACCUMULATOR. Useful between documentation builds or for testing.\n\n\n\n\n\n","category":"function"},{"location":"api/coverage_postprocessing.html#Private-API","page":"CoveragePostprocessing","title":"Private API","text":"This page lists non-exported (internal) symbols of CoveragePostprocessing.\n\n","category":"section"},{"location":"api/coverage_postprocessing.html#From-CoveragePostprocessing","page":"CoveragePostprocessing","title":"From CoveragePostprocessing","text":"","category":"section"},{"location":"api/coverage_postprocessing.html#_clean_stale_cov_files!","page":"CoveragePostprocessing","title":"_clean_stale_cov_files!","text":"","category":"section"},{"location":"api/coverage_postprocessing.html#_collect_and_move_cov_files!","page":"CoveragePostprocessing","title":"_collect_and_move_cov_files!","text":"","category":"section"},{"location":"api/coverage_postprocessing.html#_count_cov_files","page":"CoveragePostprocessing","title":"_count_cov_files","text":"","category":"section"},{"location":"api/coverage_postprocessing.html#_generate_coverage_reports!","page":"CoveragePostprocessing","title":"_generate_coverage_reports!","text":"","category":"section"},{"location":"api/coverage_postprocessing.html#_reset_coverage_dir","page":"CoveragePostprocessing","title":"_reset_coverage_dir","text":"","category":"section"},{"location":"api/coverage_postprocessing.html#CoveragePostprocessing._clean_stale_cov_files!","page":"CoveragePostprocessing","title":"CoveragePostprocessing._clean_stale_cov_files!","text":"_clean_stale_cov_files!(source_dirs)\n\nInternal helper that removes stale .cov files from source_dirs.\n\nIf multiple runs are detected (PID suffix in filenames), this function keeps the PID with the largest number of .cov files and removes the others.\n\n\n\n\n\n","category":"function"},{"location":"api/coverage_postprocessing.html#CoveragePostprocessing._collect_and_move_cov_files!","page":"CoveragePostprocessing","title":"CoveragePostprocessing._collect_and_move_cov_files!","text":"_collect_and_move_cov_files!(source_dirs, dest_dir) -> Vector{String}\n\nInternal helper that moves all .cov files from source_dirs into dest_dir.\n\nReturns a vector of destination paths for the moved files.\n\n\n\n\n\n","category":"function"},{"location":"api/coverage_postprocessing.html#CoveragePostprocessing._count_cov_files","page":"CoveragePostprocessing","title":"CoveragePostprocessing._count_cov_files","text":"_count_cov_files(source_dirs) -> Int\n\nInternal helper that counts the number of .cov files in the provided directories.\n\n\n\n\n\n","category":"function"},{"location":"api/coverage_postprocessing.html#CoveragePostprocessing._generate_coverage_reports!","page":"CoveragePostprocessing","title":"CoveragePostprocessing._generate_coverage_reports!","text":"_generate_coverage_reports!(source_dirs, coverage_dir, root_dir)\n\nInternal helper that generates coverage reports from .cov files.\n\nWrites:\n\ncoverage/lcov.info\ncoverage/cov_report.md\n\n\n\n\n\n","category":"function"},{"location":"api/coverage_postprocessing.html#CoveragePostprocessing._reset_coverage_dir","page":"CoveragePostprocessing","title":"CoveragePostprocessing._reset_coverage_dir","text":"_reset_coverage_dir(coverage_dir, cov_storage_dir)\n\nInternal helper that recreates the coverage/ directory structure.\n\nThis function removes coverage_dir (recursively) if it already exists, then creates cov_storage_dir.\n\n\n\n\n\n","category":"function"},{"location":"api/exceptions_private.html#Private-API","page":"Private","title":"Private API","text":"This page lists non-exported (internal) symbols of CTBase.Exceptions.\n\n","category":"section"},{"location":"api/exceptions_private.html#From-CTBase.Exceptions","page":"Private","title":"From CTBase.Exceptions","text":"","category":"section"},{"location":"api/exceptions_private.html#extract_user_frames","page":"Private","title":"extract_user_frames","text":"","category":"section"},{"location":"api/exceptions_private.html#format_user_friendly_error","page":"Private","title":"format_user_friendly_error","text":"","category":"section"},{"location":"api/exceptions_private.html#CTBase.Exceptions.extract_user_frames","page":"Private","title":"CTBase.Exceptions.extract_user_frames","text":"extract_user_frames(st::Vector)\n\nExtract stacktrace frames that are relevant to user code. Filters out Julia stdlib.\n\nArguments\n\nst::Vector: Stacktrace from stacktrace(catch_backtrace())\n\nReturns\n\nVector: Filtered stacktrace frames\n\n\n\n\n\n","category":"function"},{"location":"api/exceptions_private.html#CTBase.Exceptions.format_user_friendly_error","page":"Private","title":"CTBase.Exceptions.format_user_friendly_error","text":"format_user_friendly_error(io::IO, e::CTException)\n\nDisplay an error in a user-friendly format with clear sections and user code location.\n\nArguments\n\nio::IO: Output stream\ne::CTException: The exception to display\n\n\n\n\n\n","category":"function"},{"location":"api/extensions_private.html#Private-API","page":"Private","title":"Private API","text":"This page lists non-exported (internal) symbols of CTBase.Extensions.\n\n","category":"section"},{"location":"api/extensions_private.html#From-CTBase.Extensions","page":"Private","title":"From CTBase.Extensions","text":"","category":"section"},{"location":"api/extensions_private.html#AbstractCoveragePostprocessingTag","page":"Private","title":"AbstractCoveragePostprocessingTag","text":"","category":"section"},{"location":"api/extensions_private.html#AbstractDocumenterReferenceTag","page":"Private","title":"AbstractDocumenterReferenceTag","text":"","category":"section"},{"location":"api/extensions_private.html#AbstractTestRunnerTag","page":"Private","title":"AbstractTestRunnerTag","text":"","category":"section"},{"location":"api/extensions_private.html#CoveragePostprocessingTag","page":"Private","title":"CoveragePostprocessingTag","text":"","category":"section"},{"location":"api/extensions_private.html#DocumenterReferenceTag","page":"Private","title":"DocumenterReferenceTag","text":"","category":"section"},{"location":"api/extensions_private.html#TestRunnerTag","page":"Private","title":"TestRunnerTag","text":"","category":"section"},{"location":"api/extensions_private.html#CTBase.Extensions.AbstractCoveragePostprocessingTag","page":"Private","title":"CTBase.Extensions.AbstractCoveragePostprocessingTag","text":"abstract type AbstractCoveragePostprocessingTag\n\nAbstract supertype for tags used to select a particular implementation of postprocess_coverage.\n\nConcrete subtypes identify a specific backend that provides the actual coverage post-processing logic.\n\nExample\n\njulia> using CTBase\n\njulia> CTBase.CoveragePostprocessingTag() isa CTBase.AbstractCoveragePostprocessingTag\ntrue\n\n\n\n\n\n","category":"type"},{"location":"api/extensions_private.html#CTBase.Extensions.AbstractDocumenterReferenceTag","page":"Private","title":"CTBase.Extensions.AbstractDocumenterReferenceTag","text":"abstract type AbstractDocumenterReferenceTag\n\nAbstract supertype for tags used to select a particular implementation of automatic_reference_documentation.\n\nConcrete subtypes identify a specific backend that provides the actual documentation generation logic.\n\nExample\n\njulia> using CTBase\n\njulia> CTBase.DocumenterReferenceTag() isa CTBase.AbstractDocumenterReferenceTag\ntrue\n\n\n\n\n\n","category":"type"},{"location":"api/extensions_private.html#CTBase.Extensions.AbstractTestRunnerTag","page":"Private","title":"CTBase.Extensions.AbstractTestRunnerTag","text":"abstract type AbstractTestRunnerTag\n\nAbstract supertype for tags used to select a particular implementation of run_tests.\n\nConcrete subtypes identify a specific backend that provides the actual test runner logic.\n\n\n\n\n\n","category":"type"},{"location":"api/extensions_private.html#CTBase.Extensions.CoveragePostprocessingTag","page":"Private","title":"CTBase.Extensions.CoveragePostprocessingTag","text":"struct CoveragePostprocessingTag <: CTBase.Extensions.AbstractCoveragePostprocessingTag\n\nConcrete tag type used to dispatch to the CoveragePostprocessing extension.\n\nInstances of this type are passed to postprocess_coverage to enable coverage post-processing when the extension is available.\n\n\n\n\n\n","category":"type"},{"location":"api/extensions_private.html#CTBase.Extensions.DocumenterReferenceTag","page":"Private","title":"CTBase.Extensions.DocumenterReferenceTag","text":"struct DocumenterReferenceTag <: CTBase.Extensions.AbstractDocumenterReferenceTag\n\nConcrete tag type used to dispatch to the DocumenterReference extension.\n\nInstances of this type are passed to automatic_reference_documentation to enable the integration with Documenter.jl when the DocumenterReference extension is available.\n\nExample\n\njulia> using CTBase\n\njulia> tag = CTBase.DocumenterReferenceTag()\nCTBase.DocumenterReferenceTag()\n\n\n\n\n\n","category":"type"},{"location":"api/extensions_private.html#CTBase.Extensions.TestRunnerTag","page":"Private","title":"CTBase.Extensions.TestRunnerTag","text":"struct TestRunnerTag <: CTBase.Extensions.AbstractTestRunnerTag\n\nConcrete tag type used to dispatch to the TestRunner extension.\n\nInstances of this type are passed to run_tests to enable the extension-based test runner when the extension is available.\n\n\n\n\n\n","category":"type"},{"location":"api/descriptions_public.html#Public-API","page":"Public","title":"Public API","text":"This page lists exported symbols of CTBase.Descriptions.\n\n","category":"section"},{"location":"api/descriptions_public.html#From-CTBase.Descriptions","page":"Public","title":"From CTBase.Descriptions","text":"","category":"section"},{"location":"api/descriptions_public.html#DescVarArg","page":"Public","title":"DescVarArg","text":"","category":"section"},{"location":"api/descriptions_public.html#Description","page":"Public","title":"Description","text":"","category":"section"},{"location":"api/descriptions_public.html#add","page":"Public","title":"add","text":"","category":"section"},{"location":"api/descriptions_public.html#complete","page":"Public","title":"complete","text":"","category":"section"},{"location":"api/descriptions_public.html#remove","page":"Public","title":"remove","text":"","category":"section"},{"location":"api/descriptions_public.html#CTBase.Descriptions.DescVarArg","page":"Public","title":"CTBase.Descriptions.DescVarArg","text":"A type alias representing a variable number of Symbols.\n\nExample\n\njulia> using CTBase\n\njulia> CTBase.DescVarArg\nVararg{Symbol}\n\nSee also: Description\n\n\n\n\n\n","category":"constant"},{"location":"api/descriptions_public.html#CTBase.Descriptions.Description","page":"Public","title":"CTBase.Descriptions.Description","text":"struct Tuple{Vararg{Symbol}}\n\nA description is a tuple of symbols, used to declarative encode algorithms or configurations.\n\nExample\n\nBase.show is overloaded for descriptions, so tuples of descriptions are printed one per line:\n\njulia> using CTBase\n\njulia> display(((:a, :b), (:b, :c)))\n(:a, :b)\n(:b, :c)\n\nSee also: DescVarArg\n\n\n\n\n\n","category":"type"},{"location":"api/descriptions_public.html#CTBase.Descriptions.add","page":"Public","title":"CTBase.Descriptions.add","text":"add(\n    _::Tuple{},\n    y::Tuple{Vararg{Symbol}}\n) -> Tuple{Tuple{Vararg{Symbol}}}\n\n\nInitialize a new description catalog with a single description y.\n\nArguments\n\ny::Description: The initial description to add\n\nReturns\n\nTuple{Vararg{Description}}: A tuple containing only the description y\n\nExample\n\njulia> using CTBase\n\njulia> descriptions = ()\njulia> descriptions = CTBase.add(descriptions, (:a,))\n(:a,)\njulia> print(descriptions)\n((:a,),)\njulia> descriptions[1]\n(:a,)\n\nSee also: Description\n\n\n\n\n\nadd(\n    x::Tuple{Vararg{Tuple{Vararg{Symbol}}}},\n    y::Tuple{Vararg{Symbol}}\n) -> Tuple{Tuple{Vararg{Symbol}}}\n\n\nAdd the description y to the catalog x if it is not already present.\n\nArguments\n\nx::Tuple{Vararg{Description}}: Existing description catalog\ny::Description: Specific description to add\n\nReturns\n\nTuple{Vararg{Description}}: The updated catalog with y appended\n\nThrows\n\nIncorrectArgument: If the description y is already contained in x\n\nExample\n\njulia> using CTBase\n\njulia> descriptions = ()\njulia> descriptions = CTBase.add(descriptions, (:a,))\n(:a,)\njulia> descriptions = CTBase.add(descriptions, (:b,))\n(:a,)\n(:b,)\njulia> descriptions = CTBase.add(descriptions, (:b,))\nERROR: IncorrectArgument: the description (:b,) is already in ((:a,), (:b,))\n       Got: (:b,)\n       Expected: a unique description not in the catalog\n       Suggestion: Check existing descriptions before adding, or use a different description\n       Context: description catalog management\n\nSee also: complete, remove\n\n\n\n\n\n","category":"function"},{"location":"api/descriptions_public.html#CTBase.Descriptions.complete","page":"Public","title":"CTBase.Descriptions.complete","text":"complete(list::Symbol...; descriptions)\n\n\nSelect the most matching description from a catalog based on a partial list of symbols.\n\nIf multiple descriptions contain all the symbols in list, the one with the largest  intersection is selected. If multiple descriptions have the same intersection size,  the first one in the catalog wins (priority is top-to-bottom).\n\nArguments\n\nlist::Symbol...: A variable number of symbols representing a partial description\n\nKeyword Arguments\n\ndescriptions::Tuple{Vararg{Description}}: A catalog of candidate descriptions\n\nReturns\n\nDescription: The best-matching description from the catalog\n\nThrows\n\nAmbiguousDescription: If the catalog is empty or if no description contains all symbols in list.\n\nExample\n\njulia> using CTBase\n\njulia> D = ((:a, :b), (:a, :b, :c), (:b, :c), (:a, :c))\n(:a, :b)\n(:b, :c)\n(:a, :c)\njulia> CTBase.complete(:a; descriptions=D)\n(:a, :b)\njulia> CTBase.complete(:a, :c; descriptions=D)\n(:a, :b, :c)\njulia> CTBase.complete((:a, :c); descriptions=D)\n(:a, :b, :c)\njulia> CTBase.complete(:f; descriptions=D)\nERROR: AmbiguousDescription: the description (:f,) is ambiguous / incorrect\n       Description: (:f,)\n       Valid candidates:\n       - (:a, :b)\n       - (:a, :b, :c)\n       - (:b, :c)\n       - (:a, :c)\n       Suggestion: Available descriptions: (:a, :b), (:a, :b, :c), (:b, :c), (:a, :c)\n       Context: description completion\n\nEnhanced Error Features\n\nWhen no matching description is found, the function provides suggestions based on  similarity and lists existing candidates.\n\nSee also: compute_similarity, find_similar_descriptions, format_description_candidates\n\n\n\n\n\ncomplete(list::Tuple{Vararg{Symbol}}; descriptions)\n\n\nConvenience overload of complete for tuple inputs.\n\nThis method is equivalent to complete(list...; descriptions=descriptions).\n\nArguments\n\nlist::Tuple{Vararg{Symbol}}: A tuple of symbols representing a partial description.\n\nKeyword Arguments\n\ndescriptions::Tuple{Vararg{Description}}: Candidate descriptions used for completion.\n\nReturns\n\nDescription: A description from descriptions that contains all symbols in list.\n\nThrows\n\nAmbiguousDescription: If descriptions is empty, or if list is not contained in any candidate description.\n\n\n\n\n\n","category":"function"},{"location":"api/descriptions_public.html#CTBase.Descriptions.remove","page":"Public","title":"CTBase.Descriptions.remove","text":"remove(\n    x::Tuple{Vararg{Symbol}},\n    y::Tuple{Vararg{Symbol}}\n) -> Tuple{Vararg{Symbol}}\n\n\nRemove symbols from a description tuple.\n\nExample\n\njulia> using CTBase\n\njulia> CTBase.remove((:a, :b, :c), (:a,))\n(:b, :c)\n\n\n\n\n\n","category":"function"},{"location":"guide/exceptions.html#Error-Handling-and-CTBase-Exceptions","page":"Exceptions","title":"Error Handling and CTBase Exceptions","text":"CTBase defines a small hierarchy of domain-specific exceptions to make error handling explicit and consistent across the control-toolbox ecosystem.\n\nAll custom exceptions inherit from CTBase.CTException:\n\nabstract type CTBase.CTException <: Exception end","category":"section"},{"location":"guide/exceptions.html#Exception-Hierarchy","page":"Exceptions","title":"Exception Hierarchy","text":"CTException (abstract)\n├── IncorrectArgument      # Input validation errors\n├── PreconditionError      # Order of operations, state validation\n├── NotImplemented         # Unimplemented interface methods\n├── ParsingError           # Parsing errors\n├── AmbiguousDescription   # Ambiguous or incorrect descriptions\n└── ExtensionError         # Missing optional dependencies","category":"section"},{"location":"guide/exceptions.html#General-Error-Handling-Pattern","page":"Exceptions","title":"General Error Handling Pattern","text":"You should generally catch exceptions like this:\n\ntry\n    # call into CTBase or a package built on top of it\ncatch e\n    if e isa CTBase.CTException\n        # handle CTBase domain errors in a uniform way\n        @warn \"CTBase error\" exception=(e, catch_backtrace())\n    else\n        # non-CTBase error: rethrow so it is not hidden\n        rethrow()\n    end\nend\n\nThis pattern avoids accidentally swallowing unrelated internal errors while still giving you a single place to handle all CTBase-specific problems.","category":"section"},{"location":"guide/exceptions.html#Input-Validation-Exceptions","page":"Exceptions","title":"Input Validation Exceptions","text":"","category":"section"},{"location":"guide/exceptions.html#incorrect-argument-tutorial","page":"Exceptions","title":"IncorrectArgument","text":"CTBase.IncorrectArgument <: CTBase.CTException\n\nWhen to use: Thrown when an individual argument is invalid or violates a constraint.\n\nFields:\n\nmsg::String: Error message\ngot::Union{String,Nothing}: The invalid value received (optional)\nexpected::Union{String,Nothing}: What was expected (optional)\nsuggestion::Union{String,Nothing}: How to fix the problem (optional)\ncontext::Union{String,Nothing}: Where the error occurred (optional)\n\nExamples:\n\nAdding a duplicate description:\n\nusing CTBase\nalgorithms = CTBase.add((), (:a, :b))\nCTBase.add(algorithms, (:a, :b))  # Error: duplicate\n\nUsing invalid indices for the Unicode helpers:\n\nusing CTBase\nCTBase.ctindice(-1)  # Error: must be between 0 and 9\n\nUse this exception whenever one input value is outside the allowed domain (wrong range, duplicate, empty when it must not be, etc.).","category":"section"},{"location":"guide/exceptions.html#ambiguous-description-tutorial","page":"Exceptions","title":"AmbiguousDescription","text":"CTBase.AmbiguousDescription <: CTBase.CTException\n\nWhen to use: Thrown when a description (a tuple of Symbols) cannot be matched to any known valid description.\n\nFields:\n\ndescription::Description: The ambiguous description\ncandidates::Union{Vector{String},Nothing}: Suggested alternatives (optional)\nsuggestion::Union{String,Nothing}: How to fix the problem (optional)\ncontext::Union{String,Nothing}: Where the error occurred (optional)\n\nExample:\n\nusing CTBase\nD = ((:a, :b), (:a, :b, :c), (:b, :c))\nCTBase.complete(:f; descriptions=D)  # Error: no match found\n\nUse this exception when the high-level choice of description itself is wrong or ambiguous and there is no sensible default.","category":"section"},{"location":"guide/exceptions.html#Precondition-and-State-Exceptions","page":"Exceptions","title":"Precondition and State Exceptions","text":"","category":"section"},{"location":"guide/exceptions.html#precondition-error-tutorial","page":"Exceptions","title":"PreconditionError","text":"CTBase.PreconditionError <: CTBase.CTException\n\nWhen to use: Thrown when a function is called in the wrong order or when the system is in an invalid state.\n\nFields:\n\nmsg::String: Error message\nreason::Union{String,Nothing}: Why the precondition failed (optional)\nsuggestion::Union{String,Nothing}: How to fix the problem (optional)\ncontext::Union{String,Nothing}: Where the error occurred (optional)\n\nExamples:\n\nSystem initialization order:\n\nfunction configure!(state::SystemState, config::Dict)\n    if !state.initialized\n        throw(CTBase.PreconditionError(\n            \"System must be initialized before configuration\",\n            reason=\"initialize! not called yet\",\n            suggestion=\"Call initialize!(state) before configure!\",\n            context=\"system configuration\"\n        ))\n    end\n    # ... configure system ...\nend\n\nState validation:\n\nfunction dynamics!(ocp::PreModel, f::Function)\n    if !__is_state_set(ocp)\n        throw(CTBase.PreconditionError(\n            \"State must be set before defining dynamics\",\n            reason=\"state has not been defined yet\",\n            suggestion=\"Call state!(ocp, dimension) before dynamics!\",\n            context=\"dynamics! function\"\n        ))\n    end\n    # ... set dynamics ...\nend\n\nUse this exception for:\n\nFunctions called in the wrong order\nOperations on uninitialized objects\nState machine violations\nWorkflow step dependencies\n\nDistinction from IncorrectArgument:\n\nIncorrectArgument: The value of an argument is wrong\nPreconditionError: The timing or state is wrong","category":"section"},{"location":"guide/exceptions.html#Implementation-Exceptions","page":"Exceptions","title":"Implementation Exceptions","text":"","category":"section"},{"location":"guide/exceptions.html#not-implemented-tutorial","page":"Exceptions","title":"NotImplemented","text":"CTBase.NotImplemented <: CTBase.CTException\n\nWhen to use: Used to mark interface points that must be implemented by concrete subtypes.\n\nFields:\n\nmsg::String: Error message\nrequired_method::Union{String,Nothing}: Method signature that needs implementation (optional)\nsuggestion::Union{String,Nothing}: How to implement (optional)\ncontext::Union{String,Nothing}: Where the error occurred (optional)\n\nExample:\n\nThe typical pattern is to provide a method on an abstract type that throws NotImplemented, and then override it in each concrete implementation:\n\nabstract type MyAbstractAlgorithm end\n\nfunction run!(algo::MyAbstractAlgorithm, state)\n    throw(CTBase.NotImplemented(\n        \"run! is not implemented for $(typeof(algo))\",\n        required_method=\"run!(::$(typeof(algo)), state)\",\n        suggestion=\"Implement run! for your algorithm type\",\n        context=\"algorithm execution\"\n    ))\nend\n\n# Concrete implementation\nstruct MyConcreteAlgorithm <: MyAbstractAlgorithm end\n\nfunction run!(algo::MyConcreteAlgorithm, state)\n    # actual implementation\nend\n\nUse this exception when defining interfaces and you want an explicit, typed error rather than a generic error(\"TODO\").","category":"section"},{"location":"guide/exceptions.html#Parsing-and-Extension-Exceptions","page":"Exceptions","title":"Parsing and Extension Exceptions","text":"","category":"section"},{"location":"guide/exceptions.html#parsing-error-tutorial","page":"Exceptions","title":"ParsingError","text":"CTBase.ParsingError <: CTBase.CTException\n\nWhen to use: Intended for errors detected during parsing of input structures or DSLs (domain-specific languages).\n\nFields:\n\nmsg::String: Error message\nlocation::Union{String,Nothing}: Where in the input the error occurred (optional)\nsuggestion::Union{String,Nothing}: How to fix the syntax (optional)\ncontext::Union{String,Nothing}: What was being parsed (optional)\n\nExample:\n\nusing CTBase\nthrow(CTBase.ParsingError(\n    \"unexpected token 'end'\",\n    location=\"line 42, column 10\",\n    suggestion=\"Check for unmatched 'begin' or remove extra 'end'\",\n    context=\"control flow parsing\"\n))\n\nUse this exception when parsing user input, configuration files, or DSL expressions.","category":"section"},{"location":"guide/exceptions.html#extension-error-tutorial","page":"Exceptions","title":"ExtensionError","text":"CTBase.ExtensionError <: CTBase.CTException\n\nWhen to use: Thrown when a feature requires optional dependencies (weak dependencies) that are not loaded.\n\nFields:\n\nmsg::String: Error message\nweakdeps::Tuple{Vararg{Symbol}}: Names of missing packages\nfeature::Union{String,Nothing}: What feature needs the dependencies (optional)\ncontext::Union{String,Nothing}: Where the error occurred (optional)\n\nExample:\n\nfunction plot_results(data)\n    throw(CTBase.ExtensionError(\n        :Plots,\n        feature=\"result visualization\",\n        context=\"plot_results function\"\n    ))\nend\n\nThe enriched display automatically suggests:\n\n❌ Error: ExtensionError, missing dependencies\n📦 Missing dependencies: Plots\n💡 Suggestion: julia> using Plots\n\nUse this exception when:\n\nA feature requires optional packages\nExtensions are not loaded\nWeak dependencies are missing","category":"section"},{"location":"guide/exceptions.html#Quick-Reference:-Which-Exception-to-Use?","page":"Exceptions","title":"Quick Reference: Which Exception to Use?","text":"Situation Exception Example\nInvalid argument value IncorrectArgument throw(IncorrectArgument(\"x must be > 0\", got=\"-5\", expected=\"> 0\"))\nWrong function call order PreconditionError throw(PreconditionError(\"Must initialize before configure\"))\nUnimplemented interface NotImplemented throw(NotImplemented(\"run! not implemented for MyType\"))\nParsing error ParsingError throw(ParsingError(\"unexpected token\", location=\"line 10\"))\nAmbiguous description AmbiguousDescription throw(AmbiguousDescription((:x,), candidates=[\"(:a,:b)\", \"(:c,:d)\"]))\nMissing optional dependency ExtensionError throw(ExtensionError(:Plots, feature=\"plotting\"))","category":"section"},{"location":"guide/exceptions.html#Enriched-Error-Display","page":"Exceptions","title":"Enriched Error Display","text":"All CTBase exceptions provide an enriched, user-friendly display with:\n\n🎯 Clear error type and message\n📋 Contextual information (got/expected, reason, location)\n💡 Actionable suggestions for fixing the problem\n📍 User code location tracking\n🎨 Emoji-based visual hierarchy\n\nExample of enriched display:\n\nControl Toolbox Error\n\n❌ Error: PreconditionError, System must be initialized before configuration\n❓ Reason: initialize! not called yet\n📂 Context: system configuration\n💡 Suggestion: Call initialize!(state) before configure!\n📍 In your code:\n     configure! at MyModule.jl:42\n\nThis makes debugging faster by providing all the information needed to understand and fix the problem.","category":"section"},{"location":"guide/exceptions.html#Best-Practices","page":"Exceptions","title":"Best Practices","text":"Choose the right exception type: Use the decision table above\nProvide context: Always fill in optional fields when available\nBe specific: Include actual values in error messages\nSuggest solutions: Help users fix the problem\nCatch specifically: Use e isa SpecificException rather than catching all exceptions\nDon't hide errors: Only catch exceptions you can handle","category":"section"},{"location":"guide/exceptions.html#See-Also","page":"Exceptions","title":"See Also","text":"Descriptions Tutorial: Understanding the description system\nTest Runner Guide: Testing exception handling","category":"section"},{"location":"guide/api-documentation.html#API-Documentation-Guide","page":"API Documentation","title":"API Documentation Guide","text":"This guide explains how to set up automated API reference documentation generation using the DocumenterReference extension of CTBase.jl. This is particularly useful for maintaining comprehensive and up-to-date API documentation as your codebase evolves.","category":"section"},{"location":"guide/api-documentation.html#Overview","page":"API Documentation","title":"Overview","text":"The DocumenterReference extension provides the CTBase.automatic_reference_documentation() function, which automatically generates API reference pages from your Julia source code. It:\n\nExtracts docstrings from your modules\nSeparates public and private APIs\nGenerates markdown files suitable for Documenter.jl\nHandles extensions and optional dependencies gracefully\nSupports filtering and customization","category":"section"},{"location":"guide/api-documentation.html#Architecture","page":"API Documentation","title":"Architecture","text":"","category":"section"},{"location":"guide/api-documentation.html#Directory-Structure","page":"API Documentation","title":"Directory Structure","text":"docs/\n├── make.jl                 # Main documentation build script\n├── api_reference.jl        # API reference generation logic\n└── src/\n    ├── index.md           # Documentation homepage\n    └── ...","category":"section"},{"location":"guide/api-documentation.html#How-It-Works","page":"API Documentation","title":"How It Works","text":"The documentation generation happens in two stages:\n\napi_reference.jl: Defines generate_api_reference() which calls CTBase.automatic_reference_documentation() for each module.\nmake.jl: Calls with_api_reference() which executes the generation and passes the pages to Documenter.makedocs().","category":"section"},{"location":"guide/api-documentation.html#Setting-Up-API-Documentation","page":"API Documentation","title":"Setting Up API Documentation","text":"","category":"section"},{"location":"guide/api-documentation.html#Basic-Configuration","page":"API Documentation","title":"Basic Configuration","text":"The core function is CTBase.automatic_reference_documentation(). Here's a minimal example:\n\nusing CTBase\nusing Documenter\n\nCTBase.automatic_reference_documentation(;\n    subdirectory=\".\",\n    primary_modules=[MyModule => [\"src/MyModule.jl\"]],\n    title=\"MyModule API\",\n    title_in_menu=\"API\",\n    filename=\"api\",\n)","category":"section"},{"location":"guide/api-documentation.html#Key-Parameters","page":"API Documentation","title":"Key Parameters","text":"subdirectory: Where to write generated markdown files (relative to docs/src).\nprimary_modules: Vector of modules to document, optionally with source files.\nFormat: Module or Module => [\"path/to/file.jl\"].\nWhen source files are provided, only symbols from those files are documented.\ntitle: Title displayed at the top of the generated page.\ntitle_in_menu: Title in the navigation menu (defaults to title).\nfilename: Base filename for the markdown file (without .md extension).\nexclude: Vector of symbol names to skip from documentation.\npublic: Generate public API page (default: true).\nprivate: Generate private API page (default: true).\nexternal_modules_to_document: Additional modules to search for docstrings (e.g., [Base]).\npublic_title: Custom title for public API page (empty string uses default).\nprivate_title: Custom title for private API page (empty string uses default).\npublic_description: Custom description for public API page (empty string uses default).\nprivate_description: Custom description for private API page (empty string uses default).","category":"section"},{"location":"guide/api-documentation.html#Public-vs.-Private-API","page":"API Documentation","title":"Public vs. Private API","text":"The public and private flags control which symbols are documented:","category":"section"},{"location":"guide/api-documentation.html#Option-1:-Public-API-Only-(publictrue,-privatefalse)","page":"API Documentation","title":"Option 1: Public API Only (public=true, private=false)","text":"CTBase.automatic_reference_documentation(;\n    # ...\n    public=true,\n    private=false,\n    title=\"MyModule API\",\n    filename=\"api\",\n)\n\nResult: Only exported symbols are documented. This is ideal for end-user documentation.","category":"section"},{"location":"guide/api-documentation.html#Option-2:-Private-API-Only-(publicfalse,-privatetrue)","page":"API Documentation","title":"Option 2: Private API Only (public=false, private=true)","text":"CTBase.automatic_reference_documentation(;\n    # ...\n    public=false,\n    private=true,\n    title=\"MyModule Internals\",\n    filename=\"internals\",\n)\n\nResult: Only non-exported (private) symbols are documented. Useful for developer documentation.","category":"section"},{"location":"guide/api-documentation.html#Option-3:-Both-Public-and-Private-(publictrue,-privatetrue)","page":"API Documentation","title":"Option 3: Both Public and Private (public=true, private=true)","text":"CTBase.automatic_reference_documentation(;\n    # ...\n    public=true,\n    private=true,\n    title=\"MyModule Complete Reference\",\n    filename=\"complete_api\",\n)\n\nResult: If public and private are both true, the function returns a structure with two sub-pages (Public and Private).","category":"section"},{"location":"guide/api-documentation.html#Customizing-Page-Titles-and-Descriptions","page":"API Documentation","title":"Customizing Page Titles and Descriptions","text":"You can customize the titles and descriptions of generated API pages using the public_title, private_title, public_description, and private_description parameters.","category":"section"},{"location":"guide/api-documentation.html#Default-Behavior","page":"API Documentation","title":"Default Behavior","text":"By default, the system automatically generates appropriate titles based on the page type:\n\nSingle public page (public=true, private=false): Title is \"Public API\"\nSingle private page (public=false, private=true): Title is \"Private API\"\nSplit pages (public=true, private=true): Titles are \"Public API\" and \"Private API\"\nCombined page (both public and private on same page): Title is \"API reference\"","category":"section"},{"location":"guide/api-documentation.html#Custom-Titles","page":"API Documentation","title":"Custom Titles","text":"Override the default titles with custom text:\n\nCTBase.automatic_reference_documentation(;\n    # ...\n    public=false,\n    private=true,\n    private_title=\"Internal Implementation\",\n    filename=\"internals\",\n)\n\nResult: The private page will display \"Internal Implementation\" instead of \"Private API\".","category":"section"},{"location":"guide/api-documentation.html#Custom-Descriptions","page":"API Documentation","title":"Custom Descriptions","text":"Customize the introductory text that appears below the title:\n\nCTBase.automatic_reference_documentation(;\n    # ...\n    public=true,\n    private=false,\n    public_title=\"User API\",\n    public_description=\"This page documents the public interface for end users. All functions listed here are stable and safe to use in your applications.\",\n    filename=\"api\",\n)\n\nResult: The page will show your custom title and description instead of the defaults.","category":"section"},{"location":"guide/api-documentation.html#Split-Pages-with-Custom-Titles","page":"API Documentation","title":"Split Pages with Custom Titles","text":"When generating split pages, you can customize both public and private titles:\n\nCTBase.automatic_reference_documentation(;\n    # ...\n    public=true,\n    private=true,\n    public_title=\"Exported Functions\",\n    public_description=\"Stable API for end users.\",\n    private_title=\"Internal Functions\",\n    private_description=\"Implementation details for contributors.\",\n    filename=\"api\",\n)\n\nResult: Two pages are created with your custom titles and descriptions.","category":"section"},{"location":"guide/api-documentation.html#Empty-String-Behavior","page":"API Documentation","title":"Empty String Behavior","text":"If you pass empty strings (the default), the system uses the standard titles and descriptions:\n\nCTBase.automatic_reference_documentation(;\n    # ...\n    public_title=\"\",        # Uses default: \"Public API\"\n    private_title=\"\",       # Uses default: \"Private API\"\n    public_description=\"\",  # Uses default description\n    private_description=\"\", # Uses default description\n    # ...\n)\n\nThis allows you to selectively customize only the titles or descriptions you want to change.","category":"section"},{"location":"guide/api-documentation.html#Handling-Extensions","page":"API Documentation","title":"Handling Extensions","text":"When your package uses extensions (weak dependencies), you should check if they're loaded before documenting them in api_reference.jl:\n\n# Check if the extension is loaded\nMyExtension = Base.get_extension(MyPackage, :MyExtension)\nif !isnothing(MyExtension)\n    push!(\n        pages,\n        CTBase.automatic_reference_documentation(;\n            subdirectory=\".\",\n            primary_modules=[MyExtension => [\"ext/MyExtension.jl\"]],\n            external_modules_to_document=[MyPackage],\n            # ...\n            title=\"MyExtension\",\n            filename=\"my_extension\",\n        ),\n    )\nend","category":"section"},{"location":"guide/api-documentation.html#Integration-with-Documenter.jl","page":"API Documentation","title":"Integration with Documenter.jl","text":"In docs/make.jl, use with_api_reference() to integrate the generated pages:\n\nusing Documenter\nusing CTBase\n\ninclude(\"api_reference.jl\")\n\nwith_api_reference(dirname(@__DIR__)) do api_pages\n    makedocs(;\n        # ...\n        pages=[\n            \"Introduction\" => \"index.md\",\n            \"API Reference\" => api_pages,\n            # ...\n        ],\n    )\nend\n\nThe with_api_reference() function:\n\nGenerates the API reference pages.\nPasses them to your makedocs() call.\nCleans up temporary generated files after the build.","category":"section"},{"location":"guide/api-documentation.html#DocType-System","page":"API Documentation","title":"DocType System","text":"The DocumenterReference extension recognizes several documentation element types:\n\nDOCTYPE_ABSTRACT_TYPE: Abstract type declarations\nDOCTYPE_STRUCT: Concrete struct types\nDOCTYPE_FUNCTION: Functions and callables\nDOCTYPE_MACRO: Macros (names starting with @)\nDOCTYPE_MODULE: Submodules\nDOCTYPE_CONSTANT: Constants and non-function values\n\nThese types are automatically detected and organized in the generated documentation.","category":"section"},{"location":"guide/api-documentation.html#Common-Patterns","page":"API Documentation","title":"Common Patterns","text":"","category":"section"},{"location":"guide/api-documentation.html#Pattern-1:-Main-Module-with-Extensions","page":"API Documentation","title":"Pattern 1: Main Module with Extensions","text":"# In api_reference.jl\nfunction generate_api_reference(src_dir)\n    pages = []\n    \n    # Main module\n    push!(pages, CTBase.automatic_reference_documentation(;\n        subdirectory=\".\",\n        primary_modules=[MyPackage => [joinpath(src_dir, \"MyPackage.jl\")]],\n        title=\"MyPackage API\",\n        filename=\"api\",\n    ))\n    \n    # Check and document extensions\n    for (ext_name, ext_files) in [\n        (:PlotExt, [\"ext/PlotExt.jl\"]),\n        (:OptimExt, [\"ext/OptimExt.jl\"])\n    ]\n        ext = Base.get_extension(MyPackage, ext_name)\n        if !isnothing(ext)\n            push!(pages, CTBase.automatic_reference_documentation(;\n                subdirectory=\".\",\n                primary_modules=[ext => ext_files],\n                external_modules_to_document=[MyPackage],\n                title=\"$ext_name Extension\",\n                filename=lowercase(string(ext_name)),\n            ))\n        end\n    end\n    \n    return pages\nend","category":"section"},{"location":"guide/api-documentation.html#Pattern-2:-Separate-Public-and-Private-Documentation","page":"API Documentation","title":"Pattern 2: Separate Public and Private Documentation","text":"# Public API for users\npush!(pages, CTBase.automatic_reference_documentation(;\n    subdirectory=\".\",\n    primary_modules=[MyPackage],\n    public=true,\n    private=false,\n    title=\"Public API\",\n    filename=\"api_public\",\n))\n\n# Private API for developers\npush!(pages, CTBase.automatic_reference_documentation(;\n    subdirectory=\".\",\n    primary_modules=[MyPackage],\n    public=false,\n    private=true,\n    title=\"Internal API\",\n    filename=\"api_private\",\n))","category":"section"},{"location":"guide/api-documentation.html#Pattern-3:-Filtering-Unwanted-Symbols","page":"API Documentation","title":"Pattern 3: Filtering Unwanted Symbols","text":"CTBase.automatic_reference_documentation(;\n    subdirectory=\".\",\n    primary_modules=[MyPackage],\n    exclude=[\n        \"eval\",           # Compiler-generated\n        \"include\",        # Compiler-generated\n        \"__init__\",       # Internal initialization\n        \"PRIVATE_CONST\",  # Internal constant\n    ],\n    title=\"MyPackage API\",\n    filename=\"api\",\n)","category":"section"},{"location":"guide/api-documentation.html#Troubleshooting","page":"API Documentation","title":"Troubleshooting","text":"","category":"section"},{"location":"guide/api-documentation.html#Issue:-Extension-not-documented","page":"API Documentation","title":"Issue: Extension not documented","text":"Problem: Extension exists but doesn't appear in documentation\n\nSolution: Ensure the extension is loaded before generating docs:\n\n# In docs/make.jl\nusing MyPackage\nusing OptionalDependency  # Load the extension\n\n# Now the extension will be available\nconst MyExt = Base.get_extension(MyPackage, :MyExt)","category":"section"},{"location":"guide/api-documentation.html#Issue:-Docstrings-not-found","page":"API Documentation","title":"Issue: Docstrings not found","text":"Problem: Functions are listed but have no documentation\n\nSolution: Check that:\n\nDocstrings are properly formatted with \"\"\"\nSource files are correctly specified in primary_modules\nThe module is properly loaded","category":"section"},{"location":"guide/api-documentation.html#Issue:-Too-many-symbols-documented","page":"API Documentation","title":"Issue: Too many symbols documented","text":"Problem: Documentation includes internal/generated symbols\n\nSolution: Use the exclude parameter:\n\nexclude=[\"eval\", \"include\", \"#.*\"]  # Exclude compiler-generated symbols","category":"section"},{"location":"guide/api-documentation.html#Issue:-Methods-from-Base-not-showing","page":"API Documentation","title":"Issue: Methods from Base not showing","text":"Problem: Extended Base methods don't appear\n\nSolution: Add Base to external_modules_to_document:\n\nexternal_modules_to_document=[Base, Core]","category":"section"},{"location":"guide/api-documentation.html#Issue:-ExtensionError-when-generating-docs","page":"API Documentation","title":"Issue: ExtensionError when generating docs","text":"Error: ExtensionError: missing dependencies\n\nSolution: The DocumenterReference extension requires Documenter, Markdown, and MarkdownAST. Ensure they're in your docs environment:\n\n# In docs/Project.toml\n[deps]\nDocumenter = \"...\"\nMarkdown = \"...\"\nMarkdownAST = \"...\"","category":"section"},{"location":"guide/api-documentation.html#Best-Practices","page":"API Documentation","title":"Best Practices","text":"Exclude internal symbols: Use the exclude parameter to hide implementation details or compiler-generated symbols\nSeparate public and private: Create separate pages for public and private APIs to keep the end-user documentation focused\nDocument external modules: Use external_modules_to_document to include methods from other packages that your package extends (e.g., Base or Plots)\nCheck extensions before documenting: Always use Base.get_extension() to safely check for optional dependencies before calling automatic_reference_documentation on them\nUse meaningful titles: Choose clear, descriptive titles for each documentation page\nOrganize by module: Group related functionality together\nKeep it up-to-date: Regenerate documentation with each release\nTest documentation builds: Include documentation building in your CI pipeline","category":"section"},{"location":"guide/api-documentation.html#CI/CD-Integration","page":"API Documentation","title":"CI/CD Integration","text":"","category":"section"},{"location":"guide/api-documentation.html#GitHub-Actions-Example","page":"API Documentation","title":"GitHub Actions Example","text":"name: Documentation\non:\n  push:\n    branches: [main]\n    tags: ['*']\n  pull_request:\n\njobs:\n  build:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v2\n      - uses: julia-actions/setup-julia@v1\n      - name: Install dependencies\n        run: julia --project=docs -e 'using Pkg; Pkg.develop(PackageSpec(path=pwd())); Pkg.instantiate()'\n      - name: Build documentation\n        run: julia --project=docs docs/make.jl\n      - name: Deploy to GitHub Pages\n        if: github.event_name == 'push' && github.ref == 'refs/heads/main'\n        uses: peaceiris/actions-gh-pages@v3\n        with:\n          github_token: ${{ secrets.GITHUB_TOKEN }}\n          publish_dir: ./docs/build","category":"section"},{"location":"guide/api-documentation.html#Summary","page":"API Documentation","title":"Summary","text":"The DocumenterReference extension provides a powerful, flexible system for automatically generating API documentation. By following the patterns shown in this guide, you can maintain comprehensive, up-to-date documentation with minimal manual effort.","category":"section"},{"location":"guide/api-documentation.html#See-Also","page":"API Documentation","title":"See Also","text":"Exception Handling: Documenting exception types\nTest Runner Guide: Testing documentation examples\nCoverage Guide: Ensuring documentation coverage","category":"section"},{"location":"guide/coverage.html#Coverage-Post-processing-Guide","page":"Coverage","title":"Coverage Post-processing Guide","text":"This guide explains how to generate human-readable and machine-parseable coverage reports using the CoveragePostprocessing extension of CTBase.jl.","category":"section"},{"location":"guide/coverage.html#Prerequisites","page":"Coverage","title":"⚠️ Prerequisites","text":"Important: The Coverage package must be installed in your base Julia environment for coverage post-processing to work properly:\n\n# In your base Julia environment (not the project environment)\njulia --project=@v1.12 -e 'using Pkg; Pkg.add(\"Coverage\")'\n\nThis is required because coverage processing happens at the Julia level and needs the Coverage package to be available globally.","category":"section"},{"location":"guide/coverage.html#Setting-up-Coverage","page":"Coverage","title":"Setting up Coverage","text":"To generate actionable coverage reports, we use a dedicated coverage.jl script. This script processes the raw .cov files generated by Julia and produces summaries that are easy to read.","category":"section"},{"location":"guide/coverage.html#Example-test/coverage.jl","page":"Coverage","title":"Example test/coverage.jl","text":"# Add the test directory to the load path so Julia can find dependencies from \n# test/Project.toml.\npushfirst!(LOAD_PATH, @__DIR__)\n\nusing Pkg\nusing CTBase # Provides postprocess_coverage\nusing Coverage\n\n# This function:\n# 1. Aggregates coverage data.\n# 2. Generates an LCOV file (coverage/lcov.info).\n# 3. Generates a markdown summary (coverage/cov_report.md).\n# 4. Archives used .cov files to keep the directory clean.\nCTBase.postprocess_coverage(; \n    root_dir=dirname(@__DIR__) # Point to the package root\n)","category":"section"},{"location":"guide/coverage.html#Running-with-Coverage","page":"Coverage","title":"Running with Coverage","text":"To run tests and generate the report:\n\njulia --project -e '\n    using Pkg; \n    Pkg.test(\"MyPackage\"; coverage=true); \n    include(\"test/coverage.jl\")\n'\n\nThe resulting coverage/cov_report.md will contain a list of files with their coverage percentages and, crucially, a list of uncovered lines. This allows identifying exactly which parts of the code need more tests.","category":"section"},{"location":"guide/coverage.html#Coverage-Artifacts","page":"Coverage","title":"Coverage Artifacts","text":"The post-processing script produces:\n\ncoverage/lcov.info: LCOV format for CI integration (e.g., Codecov).\ncoverage/cov_report.md: Human-readable summary with uncovered lines.\ncoverage/cov/: Archived .cov files.","category":"section"},{"location":"guide/coverage.html#Complete-Workflow","page":"Coverage","title":"Complete Workflow","text":"Here's a complete workflow from running tests to analyzing coverage:\n\n# 1. Clean previous coverage data\nrm -rf coverage/\n\n# 2. Run tests with coverage enabled\njulia --project -e 'using Pkg; Pkg.test(\"MyPackage\"; coverage=true)'\n\n# 3. Generate coverage report\njulia --project -e 'include(\"test/coverage.jl\")'\n\n# 4. View the report\ncat coverage/cov_report.md","category":"section"},{"location":"guide/coverage.html#Troubleshooting","page":"Coverage","title":"Troubleshooting","text":"","category":"section"},{"location":"guide/coverage.html#Issue:-Coverage-package-not-found","page":"Coverage","title":"Issue: Coverage package not found","text":"Error: ArgumentError: Package Coverage not found in current path\n\nSolution: Install Coverage in your base Julia environment:\n\njulia --project=@v1.12 -e 'using Pkg; Pkg.add(\"Coverage\")'","category":"section"},{"location":"guide/coverage.html#Issue:-No-.cov-files-generated","page":"Coverage","title":"Issue: No .cov files generated","text":"Problem: Tests run but no coverage data is collected\n\nSolution: Ensure you're running tests with coverage=true:\n\njulia --project -e 'using Pkg; Pkg.test(\"MyPackage\"; coverage=true)'","category":"section"},{"location":"guide/coverage.html#Issue:-Coverage-report-shows-0%-for-all-files","page":"Coverage","title":"Issue: Coverage report shows 0% for all files","text":"Problem: Coverage data exists but shows no coverage\n\nSolution: Check that your package source is in the src/ directory and that the root_dir parameter in coverage.jl points to the correct location.","category":"section"},{"location":"guide/coverage.html#Issue:-ExtensionError-when-running-coverage","page":"Coverage","title":"Issue: ExtensionError when running coverage","text":"Error: ExtensionError: missing dependencies\n\nSolution: The Coverage package must be available. Install it globally:\n\njulia -e 'using Pkg; Pkg.add(\"Coverage\")'","category":"section"},{"location":"guide/coverage.html#Understanding-Coverage-Reports","page":"Coverage","title":"Understanding Coverage Reports","text":"The cov_report.md file contains:","category":"section"},{"location":"guide/coverage.html#File-Coverage-Summary","page":"Coverage","title":"File Coverage Summary","text":"File: src/MyModule.jl\nCoverage: 85.7% (60/70 lines)\nUncovered lines: 15, 23-25, 42, 58-60\n\nThis shows:\n\nTotal coverage: 85.7% of lines are executed\nLine counts: 60 out of 70 lines covered\nUncovered lines: Specific line numbers that need tests","category":"section"},{"location":"guide/coverage.html#Interpreting-Results","page":"Coverage","title":"Interpreting Results","text":"High coverage (>90%): Good test coverage, most code paths tested\nMedium coverage (70-90%): Acceptable, but room for improvement\nLow coverage (<70%): Needs more tests, many code paths untested\n\nFocus on:\n\nCritical paths: Ensure core functionality is well-tested\nError handling: Test exception paths\nEdge cases: Test boundary conditions","category":"section"},{"location":"guide/coverage.html#Best-Practices","page":"Coverage","title":"Best Practices","text":"Run coverage regularly: Include in your development workflow\nFocus on quality, not just quantity: 100% coverage doesn't mean bug-free code\nTest meaningful paths: Cover important logic, not just trivial getters\nUse coverage to find gaps: Identify untested code paths\nIntegrate with CI: Automate coverage reporting in your CI pipeline\nSet coverage thresholds: Maintain or improve coverage over time\nReview uncovered lines: Understand why code isn't covered","category":"section"},{"location":"guide/coverage.html#CI/CD-Integration","page":"Coverage","title":"CI/CD Integration","text":"","category":"section"},{"location":"guide/coverage.html#GitHub-Actions-with-Codecov","page":"Coverage","title":"GitHub Actions with Codecov","text":"name: Coverage\non: [push, pull_request]\njobs:\n  coverage:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v2\n      - uses: julia-actions/setup-julia@v1\n      - name: Install Coverage\n        run: julia -e 'using Pkg; Pkg.add(\"Coverage\")'\n      - name: Run tests with coverage\n        run: julia --project -e 'using Pkg; Pkg.test(coverage=true)'\n      - name: Process coverage\n        run: julia --project -e 'include(\"test/coverage.jl\")'\n      - name: Upload to Codecov\n        uses: codecov/codecov-action@v3\n        with:\n          files: coverage/lcov.info","category":"section"},{"location":"guide/coverage.html#See-Also","page":"Coverage","title":"See Also","text":"Test Runner Guide: Setting up modular tests\nException Handling: Testing exception paths","category":"section"},{"location":"guide/test-runner.html#Test-Runner-Guide","page":"Test Runner","title":"Test Runner Guide","text":"This guide explains how to set up a modular testing infrastructure for Julia packages using the TestRunner extension of CTBase.jl. This setup enables granular test execution and is friendly both for human developers and AI agents.","category":"section"},{"location":"guide/test-runner.html#Architecture-Overview","page":"Test Runner","title":"Architecture Overview","text":"A robust testing architecture typically involves:\n\nTest Runner: A runtests.jl file that allows running specific test groups via command-line arguments.\nTest Suite Structure: Modular test files, each containing a main entry point function.","category":"section"},{"location":"guide/test-runner.html#Recommended-Directory-Structure","page":"Test Runner","title":"Recommended Directory Structure","text":"We recommend placing your tests in a suite subdirectory to keep the top-level test/ folder clean.\n\nMyPackage.jl/\n├── src/\n│   └── ...\n├── test/\n│   ├── runtests.jl          # Main test runner\n│   └── suite/               # Directory containing test files\n│       ├── test_utils.jl\n│       ├── test_core.jl\n│       └── ...\n└── ...\n\nwarning: Restriction\nThe test/ directory must not contain a subdirectory named test. This would conflict with the automatic test/ prefix stripping (see Path prefix stripping).","category":"section"},{"location":"guide/test-runner.html#Setting-up-runtests.jl","page":"Test Runner","title":"Setting up runtests.jl","text":"The runtests.jl file is the entry point for your test suite. By using CTBase.run_tests, you enable a powerful mechanism to filter and execute specific tests using command-line arguments. This is crucial for fast iteration cycles.","category":"section"},{"location":"guide/test-runner.html#Example-test/runtests.jl","page":"Test Runner","title":"Example test/runtests.jl","text":"# Load dependencies\nusing Test\nusing CTBase # Provides run_tests\nusing MyPackage # Your package\n\n# Define where your tests are located\nconst TEST_DIR = @__DIR__\n\n# Run tests using the CTBase test runner\nCTBase.run_tests(;\n    args=String.(ARGS),                 # Pass command line arguments\n    testset_name=\"MyPackage Tests\",     # Name of the main testset\n    available_tests=[                   # List of available test groups/files\n        \"suite/*\"                       # Use glob pattern to include all tests in suite/\n    ],\n    filename_builder = name -> \"test_$(name).jl\",\n    funcname_builder = name -> \"test_$(name)\",\n    test_dir=TEST_DIR,                  # Directory containing test files\n)","category":"section"},{"location":"guide/test-runner.html#Keyword-Arguments","page":"Test Runner","title":"Keyword Arguments","text":"Argument Type Default Description\nargs AbstractVector{<:AbstractString} String[] Command-line arguments (typically String.(ARGS))\ntestset_name String \"Tests\" Name of the main @testset\navailable_tests Vector Symbol[] Allowed tests (Symbols, Strings, or glob patterns). Empty = auto-discovery\nfilename_builder Function identity name → filename mapping\nfuncname_builder Function identity name → function_name mapping (return nothing to skip eval)\neval_mode Bool true Whether to call the function after include\nverbose Bool true Verbose @testset output\nshowtiming Bool true Show timing in @testset output\ntest_dir String joinpath(pwd(), \"test\") Root directory for test files\non_test_start Function or nothing nothing Callback before eval (see Callbacks)\non_test_done Function or nothing nothing Callback after eval (see Callbacks)\nprogress Bool true Show built-in progress bar. Ignored when on_test_done is provided","category":"section"},{"location":"guide/test-runner.html#Writing-Test-Files","page":"Test Runner","title":"Writing Test Files","text":"To support the modular execution model, each test file should define a function (typically matching the filename) that contains the tests. This avoids scope pollution and makes the tests easy to invoke programmatically.","category":"section"},{"location":"guide/test-runner.html#Example-test/suite/test_utils.jl","page":"Test Runner","title":"Example test/suite/test_utils.jl","text":"# The function name matches the `funcname_builder` logic in runtests.jl\nfunction test_utils()\n    @testset \"Utilities\" begin\n        @test MyPackage.add(1, 1) == 2\n        @test MyPackage.sub(2, 1) == 1\n    end\nend","category":"section"},{"location":"guide/test-runner.html#Running-Tests","page":"Test Runner","title":"Running Tests","text":"","category":"section"},{"location":"guide/test-runner.html#Default-(all-available-tests)","page":"Test Runner","title":"Default (all available tests)","text":"julia --project -e 'using Pkg; Pkg.test(\"MyPackage\")'","category":"section"},{"location":"guide/test-runner.html#Run-a-specific-test-group","page":"Test Runner","title":"Run a specific test group","text":"julia --project -e 'using Pkg; Pkg.test(\"MyPackage\"; test_args=[\"utils\"])'\njulia --project -e 'using Pkg; Pkg.test(\"MyPackage\"; test_args=[\"core\", \"utils\"])'","category":"section"},{"location":"guide/test-runner.html#Path-prefix-stripping","page":"Test Runner","title":"Path prefix stripping","text":"Selection arguments starting with test/ are automatically stripped, so the following are equivalent:\n\n# These two commands run the same tests:\njulia --project -e 'using Pkg; Pkg.test(\"MyPackage\"; test_args=[\"suite\"])'\njulia --project -e 'using Pkg; Pkg.test(\"MyPackage\"; test_args=[\"test/suite\"])'\n\nThis is convenient when tab-completing paths from the project root.","category":"section"},{"location":"guide/test-runner.html#CLI-flags","page":"Test Runner","title":"CLI flags","text":"-a or --all — run all available tests (same as no arguments).\n-n or --dryrun — print the list of tests that would run, without executing them.\nCoverage flags (coverage=true, --coverage, etc.) are silently filtered out.","category":"section"},{"location":"guide/test-runner.html#Directory-selection","page":"Test Runner","title":"Directory selection","text":"Bare directory names are automatically expanded. For example, suite/exceptions is treated as suite/exceptions/*, selecting all test files in that directory.","category":"section"},{"location":"guide/test-runner.html#Progress-Bar","page":"Test Runner","title":"Progress Bar","text":"By default, run_tests displays a progress bar after each test completes:\n\n[████████░░░░░░░░░░░░] ✓ [08/19] suite/exceptions/test_display.jl (2.5s)\n[█████████░░░░░░░░░░░] ✓ [09/19] suite/exceptions/test_exceptions.jl (0.6s)\n[██████████░░░░░░░░░░] ✗ [10/19] suite/exceptions/test_types.jl FAILED, (0.9s)","category":"section"},{"location":"guide/test-runner.html#Visual-elements","page":"Test Runner","title":"Visual elements","text":"Bar: █ (filled) and ░ (empty), enclosed in […]\nStatus symbol: ✓ (green, success), ✗ (red, failure/error), ○ (yellow, skipped)\nIndex: zero-padded [01/19] for alignment\nSpec: test identifier (relative path or symbol name)\nTime: wall-clock elapsed time for the eval phase\nFAILED: appended in bold red when the test failed","category":"section"},{"location":"guide/test-runner.html#Adaptive-bar-width","page":"Test Runner","title":"Adaptive bar width","text":"The bar width adapts to the number of tests:\n\n≤ 20 tests: width equals the total number of tests (one block per test).\n> 20 tests: fixed width of 20 characters. Some tests will not visually advance the bar (the fill is computed as round(Int, index / total * 20)).","category":"section"},{"location":"guide/test-runner.html#Failure-detection","page":"Test Runner","title":"Failure detection","text":"The progress bar correctly detects both types of failures:\n\nExceptions: errors thrown during test execution (caught via try/catch).\n@test assertion failures: detected by scanning the enclosing DefaultTestSet results before and after eval. This is more reliable than checking anynonpass, which is only updated when a testset finishes.","category":"section"},{"location":"guide/test-runner.html#Disabling-the-progress-bar","page":"Test Runner","title":"Disabling the progress bar","text":"Set progress=false to disable the built-in progress display:\n\nCTBase.run_tests(; args=String.(ARGS), progress=false)\n\nThe progress bar is also automatically disabled when a custom on_test_done callback is provided.","category":"section"},{"location":"guide/test-runner.html#Callbacks","page":"Test Runner","title":"Callbacks","text":"The on_test_start and on_test_done callbacks allow custom actions during the test lifecycle. Both receive a TestRunInfo struct.","category":"section"},{"location":"guide/test-runner.html#TestRunInfo","page":"Test Runner","title":"TestRunInfo","text":"struct TestRunInfo\n    spec::Union{Symbol,String}          # Test identifier\n    filename::String                     # Absolute path of the test file\n    func_symbol::Union{Symbol,Nothing}  # Function to call (nothing if eval_mode=false)\n    index::Int                           # 1-based index in the selected list\n    total::Int                           # Total number of selected tests\n    status::Symbol                       # See below\n    error::Union{Exception,Nothing}     # Captured exception (only when status == :error)\n    elapsed::Union{Float64,Nothing}     # Wall-clock seconds (only in on_test_done)\nend","category":"section"},{"location":"guide/test-runner.html#Status-values","page":"Test Runner","title":"Status values","text":"Status When Callback\n:pre_eval After include, before eval on_test_start\n:post_eval After successful eval on_test_done\n:test_failed After eval with @test failures (no exception) on_test_done\n:error After eval raised an exception on_test_done\n:skipped When eval_mode=false or on_test_start returned false on_test_done","category":"section"},{"location":"guide/test-runner.html#on_test_start","page":"Test Runner","title":"on_test_start","text":"Called after the test file is included but before the function is evaluated. Must return a Bool:\n\ntrue — proceed with eval.\nfalse — skip eval (triggers on_test_done with :skipped).","category":"section"},{"location":"guide/test-runner.html#on_test_done","page":"Test Runner","title":"on_test_done","text":"Called after eval completes (or after skip/error). The built-in progress bar is implemented as a default on_test_done callback.","category":"section"},{"location":"guide/test-runner.html#Example:-custom-callbacks","page":"Test Runner","title":"Example: custom callbacks","text":"CTBase.run_tests(;\n    args=String.(ARGS),\n    on_test_start = info -> begin\n        print(\"  [$(info.index)/$(info.total)] $(info.spec)...\")\n        return true  # proceed with eval\n    end,\n    on_test_done = info -> begin\n        if info.status == :post_eval\n            println(\" ✓ ($(round(info.elapsed; digits=1))s)\")\n        elseif info.status == :error || info.status == :test_failed\n            println(\" ✗ FAILED\")\n        elseif info.status == :skipped\n            println(\" ○ skipped\")\n        end\n    end,\n)","category":"section"},{"location":"guide/test-runner.html#Advanced-Usage","page":"Test Runner","title":"Advanced Usage","text":"","category":"section"},{"location":"guide/test-runner.html#Filtering-Tests-with-Glob-Patterns","page":"Test Runner","title":"Filtering Tests with Glob Patterns","text":"You can use glob patterns to organize tests hierarchically:\n\nCTBase.run_tests(;\n    args=String.(ARGS),\n    testset_name=\"MyPackage Tests\",\n    available_tests=[\n        \"suite/core/*\",       # All core tests\n        \"suite/utils/*\",      # All utility tests\n        \"suite/integration/*\" # All integration tests\n    ],\n    # ...\n)\n\nSelection arguments are matched against multiple representations of each candidate:\n\nThe candidate name (e.g. :utils)\nThe full relative path (e.g. suite/test_utils.jl)\nThe path without .jl extension\nThe basename (e.g. test_utils.jl)\nThe basename without extension\nThe basename without test_ prefix (e.g. utils)","category":"section"},{"location":"guide/test-runner.html#Custom-Test-Options","page":"Test Runner","title":"Custom Test Options","text":"Pass custom options to your test suite:\n\n# In runtests.jl\nconst VERBOSE = \"--verbose\" in ARGS\nconst SHOWTIMING = \"--timing\" in ARGS\n\n# In test files\nfunction test_utils()\n    @testset \"Utilities\" verbose=VERBOSE showtiming=SHOWTIMING begin\n        # tests here\n    end\nend","category":"section"},{"location":"guide/test-runner.html#Debugging-Test-Failures","page":"Test Runner","title":"Debugging Test Failures","text":"","category":"section"},{"location":"guide/test-runner.html#Common-Issues-and-Solutions","page":"Test Runner","title":"Common Issues and Solutions","text":"","category":"section"},{"location":"guide/test-runner.html#Issue:-Test-function-not-found","page":"Test Runner","title":"Issue: Test function not found","text":"Error: UndefVarError: test_utils not defined\n\nSolution: Ensure your test file exports the test function to the outer scope:\n\n# At the end of test/suite/test_utils.jl\ntest_utils() = TestUtils.test_utils()  # Export to outer scope","category":"section"},{"location":"guide/test-runner.html#Issue:-Module-conflicts","page":"Test Runner","title":"Issue: Module conflicts","text":"Error: WARNING: replacing module TestUtils\n\nSolution: Use unique module names for each test file:\n\nmodule TestUtilsModule  # Unique name\nusing Test\nusing MyPackage\n\nfunction test_utils()\n    @testset \"Utilities\" begin\n        # tests\n    end\nend\n\nend # module\n\ntest_utils() = TestUtilsModule.test_utils()","category":"section"},{"location":"guide/test-runner.html#Issue:-Tests-not-discovered","page":"Test Runner","title":"Issue: Tests not discovered","text":"Error: No tests run when specifying a test name\n\nSolution: Check that your filename_builder and funcname_builder match your file structure:\n\n# If your files are named \"utils_test.jl\"\nfilename_builder = name -> \"$(name)_test.jl\"\n\n# If your functions are named \"run_utils_tests\"\nfuncname_builder = name -> \"run_$(name)_tests\"","category":"section"},{"location":"guide/test-runner.html#Issue:-@test-failure-shown-as-success","page":"Test Runner","title":"Issue: @test failure shown as success","text":"The progress bar detects @test failures by scanning the enclosing testset results before and after eval. If you see a ✓ for a test that should have failed, make sure the test function is wrapped in a @testset block so that failures are recorded in the results.","category":"section"},{"location":"guide/test-runner.html#Debugging-with-Verbose-Output","page":"Test Runner","title":"Debugging with Verbose Output","text":"Run tests with verbose output to see detailed information:\n\njulia --project -e 'using Pkg; Pkg.test(\"MyPackage\"; test_args=[\"--verbose\", \"utils\"])'","category":"section"},{"location":"guide/test-runner.html#Best-Practices","page":"Test Runner","title":"Best Practices","text":"One test function per file: Keep test files focused and easy to navigate\nUse descriptive names: Name test files and functions clearly (e.g., test_optimization.jl, test_optimization())\nOrganize by feature: Group related tests in subdirectories\nFast tests first: Place quick unit tests before slow integration tests\nIsolate test state: Each test should be independent and not rely on execution order\nUse test fixtures: Create helper functions for common test setup\nDocument test requirements: Note any special dependencies or setup needed\nNo test/ subdirectory in test/: Avoid naming a subdirectory test inside your test directory","category":"section"},{"location":"guide/test-runner.html#Integration-with-CI/CD","page":"Test Runner","title":"Integration with CI/CD","text":"","category":"section"},{"location":"guide/test-runner.html#GitHub-Actions-Example","page":"Test Runner","title":"GitHub Actions Example","text":"name: Tests\non: [push, pull_request]\njobs:\n  test:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v2\n      - uses: julia-actions/setup-julia@v1\n      - name: Run all tests\n        run: julia --project -e 'using Pkg; Pkg.test()'\n      - name: Run specific test group\n        run: julia --project -e 'using Pkg; Pkg.test(test_args=[\"core\"])'","category":"section"},{"location":"guide/test-runner.html#See-Also","page":"Test Runner","title":"See Also","text":"Exception Handling: Understanding test failures and exceptions\nCoverage Guide: Measuring test coverage","category":"section"},{"location":"api/unicode.html#Public-API","page":"Unicode","title":"Public API","text":"This page lists exported symbols of CTBase.Unicode.\n\n","category":"section"},{"location":"api/unicode.html#From-CTBase.Unicode","page":"Unicode","title":"From CTBase.Unicode","text":"","category":"section"},{"location":"api/unicode.html#ctindice","page":"Unicode","title":"ctindice","text":"","category":"section"},{"location":"api/unicode.html#ctindices","page":"Unicode","title":"ctindices","text":"","category":"section"},{"location":"api/unicode.html#ctupperscript","page":"Unicode","title":"ctupperscript","text":"","category":"section"},{"location":"api/unicode.html#ctupperscripts","page":"Unicode","title":"ctupperscripts","text":"","category":"section"},{"location":"api/unicode.html#CTBase.Unicode.ctindice","page":"Unicode","title":"CTBase.Unicode.ctindice","text":"ctindice(i::Int64) -> Char\n\n\nReturn the integer i ∈ [0, 9] as a Unicode subscript character.\n\nThrows an CTBase.Exceptions.IncorrectArgument exception if i is outside this range.\n\nThe Unicode subscript digits start at codepoint U+2080 for '0' and continue sequentially.\n\nExample\n\njulia> using CTBase\n\njulia> CTBase.ctindice(3)\n'₃': Unicode U+2083 (category No: Number, other)\n\n\n\n\n\n","category":"function"},{"location":"api/unicode.html#CTBase.Unicode.ctindices","page":"Unicode","title":"CTBase.Unicode.ctindices","text":"ctindices(i::Int64) -> String\n\n\nReturn the integer i ≥ 0 as a string of Unicode subscript characters.\n\nThrows an CTBase.Exceptions.IncorrectArgument if i is negative.\n\nExample\n\njulia> using CTBase\n\njulia> CTBase.ctindices(123)\n\"₁₂₃\"\n\n\n\n\n\n","category":"function"},{"location":"api/unicode.html#CTBase.Unicode.ctupperscript","page":"Unicode","title":"CTBase.Unicode.ctupperscript","text":"ctupperscript(i::Int64) -> Char\n\n\nReturn the integer i ∈ [0, 9] as a Unicode superscript (upper) character.\n\nThrows an CTBase.Exceptions.IncorrectArgument exception if i is outside this range.\n\nNote: Unicode superscripts ¹ (U+00B9), ² (U+00B2), and ³ (U+00B3) are special cases. The other digits ⁰ (U+2070) and ⁴ to ⁹ (U+2074 to U+2079) are mostly contiguous.\n\nExample\n\njulia> using CTBase\n\njulia> CTBase.ctupperscript(2)\n'²': Unicode U+00B2 (category No: Number, other)\n\n\n\n\n\n","category":"function"},{"location":"api/unicode.html#CTBase.Unicode.ctupperscripts","page":"Unicode","title":"CTBase.Unicode.ctupperscripts","text":"ctupperscripts(i::Int64) -> String\n\n\nReturn the integer i ≥ 0 as a string of Unicode superscript characters.\n\nThrows an CTBase.Exceptions.IncorrectArgument if i is negative.\n\nExample\n\njulia> using CTBase\n\njulia> CTBase.ctupperscripts(123)\n\"¹²³\"\n\n\n\n\n\n","category":"function"},{"location":"api/core_private.html#Private-API","page":"Private","title":"Private API","text":"This page lists non-exported (internal) symbols of CTBase.Core.\n\n","category":"section"},{"location":"api/core_private.html#From-CTBase.Core","page":"Private","title":"From CTBase.Core","text":"","category":"section"},{"location":"api/core_private.html#__display","page":"Private","title":"__display","text":"","category":"section"},{"location":"api/core_private.html#CTBase.Core.__display","page":"Private","title":"CTBase.Core.__display","text":"__display() -> Bool\n\n\nReturn the default value of the display flag.\n\nThis internal utility is used to decide whether output should be shown during execution.\n\nReturns\n\nBool: The default value true, indicating that output is displayed.\n\nExample\n\njulia> using CTBase\n\njulia> CTBase.__display()\ntrue\n\n\n\n\n\n","category":"function"},{"location":"api/extensions_public.html#Public-API","page":"Public","title":"Public API","text":"This page lists exported symbols of CTBase.Extensions.\n\n","category":"section"},{"location":"api/extensions_public.html#From-CTBase.Extensions","page":"Public","title":"From CTBase.Extensions","text":"","category":"section"},{"location":"api/extensions_public.html#automatic_reference_documentation","page":"Public","title":"automatic_reference_documentation","text":"","category":"section"},{"location":"api/extensions_public.html#postprocess_coverage","page":"Public","title":"postprocess_coverage","text":"","category":"section"},{"location":"api/extensions_public.html#run_tests","page":"Public","title":"run_tests","text":"","category":"section"},{"location":"api/extensions_public.html#CTBase.Extensions.automatic_reference_documentation","page":"Public","title":"CTBase.Extensions.automatic_reference_documentation","text":"automatic_reference_documentation(\n    ::CTBase.Extensions.AbstractDocumenterReferenceTag;\n    kwargs...\n)\n\n\nGenerate API reference documentation pages for one or more modules.\n\nThis method is an extension point: the default implementation throws an CTBase.Exceptions.ExtensionError unless a backend extension providing the actual implementation is loaded (e.g. the DocumenterReference extension).\n\nKeyword Arguments\n\nForwarded to the active backend implementation.\n\nThrows\n\nCTBase.Exceptions.ExtensionError: If no backend extension is loaded.\n\nExample\n\nusing CTBase\n# Requires DocumenterReference extension to be active\nautomatic_reference_documentation(\n    subdirectory=\"api\",\n    primary_modules=[MyModule],\n    title=\"My API\"\n)\n\n\n\n\n\nautomatic_reference_documentation(; kwargs...)\n\n\nConvenience wrapper for automatic_reference_documentation using the default backend tag.\n\nKeyword Arguments\n\nForwarded to automatic_reference_documentation(DocumenterReferenceTag(); kwargs...).\n\nThrows\n\nCTBase.Exceptions.ExtensionError: If the required backend extension is not loaded.\n\nExample\n\nusing CTBase\n# automatic_reference_documentation(subdirectory=\"api\")\n\n\n\n\n\nautomatic_reference_documentation(;\n    subdirectory::String,\n    primary_modules,\n    sort_by::Function = identity,\n    exclude::Vector{Symbol} = Symbol[],\n    public::Bool = true,\n    private::Bool = true,\n    title::String = \"API Reference\",\n    title_in_menu::String = \"\",\n    filename::String = \"\",\n    source_files::Vector{String} = String[],\n    include_without_source::Bool = false,\n    external_modules_to_document::Vector{Module} = Module[],\n    public_title::String = \"\",\n    private_title::String = \"\",\n    public_description::String = \"\",\n    private_description::String = \"\",\n)\n\nAutomatically creates the API reference documentation for one or more modules and returns a structure which can be used in the pages argument of Documenter.makedocs.\n\nArguments\n\nsubdirectory: the directory relative to the documentation root in which to write the API files.\nprimary_modules: a vector of modules or Module => source_files pairs to document. When source files are provided, only symbols defined in those files are documented.\nsort_by: a custom sort function applied to symbol lists.\nexclude: vector of symbol names to skip from the generated API.\npublic: flag to generate public API page (default: true).\nprivate: flag to generate private API page (default: true).\ntitle: title displayed at the top of the generated page.\ntitle_in_menu: title displayed in the navigation menu (default: same as title).\nfilename: base filename (without extension) for the markdown file.\nsource_files: global source file paths (fallback if no module-specific files). Deprecated: prefer using primary_modules=[Module => files] instead.\ninclude_without_source: if true, include symbols whose source file cannot be determined. Default: false.\nexternal_modules_to_document: additional modules to search for docstrings (e.g., [Plots] to include Plots.plot methods defined in your source files).\npublic_title: custom title for public API page. Empty string uses default (\"Public API\" or \"Public\").\nprivate_title: custom title for private API page. Empty string uses default (\"Private API\" or \"Private\").\npublic_description: custom description text for public API page. Empty string uses default.\nprivate_description: custom description text for private API page. Empty string uses default.\n\nMultiple instances\n\nEach time you call this function, a new object is added to the global variable DocumenterReference.CONFIG. Use reset_config!() to clear it between builds.\n\n\n\n\n\n","category":"function"},{"location":"api/extensions_public.html#CTBase.Extensions.postprocess_coverage","page":"Public","title":"CTBase.Extensions.postprocess_coverage","text":"postprocess_coverage(\n    ::CTBase.Extensions.AbstractCoveragePostprocessingTag;\n    generate_report,\n    root_dir,\n    dest_dir\n)\n\n\nPost-process coverage artifacts produced by Pkg.test(; coverage=true).\n\nThis is an extension point: the default implementation throws an CTBase.Exceptions.ExtensionError unless a backend extension (e.g. CoveragePostprocessing) is loaded.\n\nKeyword Arguments\n\ngenerate_report::Bool=true: Whether to generate summary reports.\nroot_dir::String=pwd(): Project root directory used to locate coverage artifacts.\ndest_dir::String=\"coverage\": Destination directory for coverage artifacts.\n\nThrows\n\nCTBase.Exceptions.ExtensionError: If the coverage post-processing extension is not loaded.\n\nExample\n\nusing CTBase\n# postprocess_coverage(generate_report=true)\n\n\n\n\n\npostprocess_coverage(; kwargs...)\n\n\nConvenience wrapper for postprocess_coverage using the default backend tag.\n\nKeyword Arguments\n\nForwarded to postprocess_coverage(CoveragePostprocessingTag(); kwargs...).\n\nThrows\n\nCTBase.Exceptions.ExtensionError: If the coverage post-processing extension is not loaded.\n\nExample\n\nusing CTBase\n# postprocess_coverage()\n\n\n\n\n\nCTBase.postprocess_coverage(::CTBase.Extensions.CoveragePostprocessingTag; generate_report::Bool=true, root_dir::String=pwd())\n\nPost-process coverage artifacts produced by Pkg.test(; coverage=true).\n\nThis implementation:\n\nCollects coverage source directories under root_dir (src/, test/, ext/ when present)\nResets the coverage/ directory\nRemoves stale .cov files (keeping the most complete PID suffix when multiple runs exist)\nOptionally generates reports (LCOV + markdown report)\nMoves .cov files into coverage/cov/ (recursively from source dirs)\n\nKeyword Arguments\n\ngenerate_report::Bool=true: If true, write coverage/lcov.info and coverage/cov_report.md.\nroot_dir::String=pwd(): Root directory of the project.\ndest_dir::String=\"coverage\": Destination directory for coverage artifacts.\n\nReturns\n\nNothing\n\nNotes\n\nThis function creates/removes/moves files and directories under root_dir.\n\nUsage sketch (non-executed)\n\nusing CTBase\n\n# CTBase.postprocess_coverage(; generate_report=true, root_dir=pwd())\n\n\n\n\n\n","category":"function"},{"location":"api/extensions_public.html#CTBase.Extensions.run_tests","page":"Public","title":"CTBase.Extensions.run_tests","text":"run_tests(\n    ::CTBase.Extensions.AbstractTestRunnerTag;\n    kwargs...\n) -> Union{Nothing, Test.FallbackTestSet, Test.DefaultTestSet}\n\n\nRun the project test suite using an extension-provided test runner.\n\nThis is an extension point: the default implementation throws an CTBase.Exceptions.ExtensionError unless a backend extension is loaded.\n\nKeyword Arguments\n\nForwarded to the active backend implementation.\n\nThrows\n\nCTBase.Exceptions.ExtensionError: If the test runner extension is not loaded.\n\nExample\n\nusing CTBase\n# run_tests()\n\n\n\n\n\nrun_tests(\n;\n    kwargs...\n) -> Union{Nothing, Test.FallbackTestSet, Test.DefaultTestSet}\n\n\nConvenience wrapper for run_tests using the default backend tag.\n\nKeyword Arguments\n\nForwarded to run_tests(TestRunnerTag(); kwargs...).\n\nThrows\n\nCTBase.Exceptions.ExtensionError: If the test runner extension is not loaded.\n\nExample\n\nusing CTBase\n# run_tests()\n\n\n\n\n\nrun_tests(\n    ::CTBase.Extensions.TestRunnerTag;\n    args,\n    testset_name,\n    available_tests,\n    filename_builder,\n    funcname_builder,\n    eval_mode,\n    verbose,\n    showtiming,\n    test_dir,\n    on_test_start,\n    on_test_done,\n    progress\n) -> Union{Nothing, Test.FallbackTestSet, Test.DefaultTestSet}\n\n\nRun tests with configurable file/function name builders and optional available tests filter.\n\nArguments\n\n::CTBase.Extensions.TestRunnerTag: Dispatch tag for the TestRunner extension\nargs::AbstractVector{<:AbstractString}: Command-line arguments (typically String.(ARGS))\ntestset_name::String: Name of the main testset (default: \"Tests\")\navailable_tests: Allowed tests (Symbols, Strings, or glob patterns). Empty = auto-discovery\nfilename_builder::Function: name → filename mapping (default: identity)\nfuncname_builder::Function: name → function_name mapping (default: identity)\neval_mode::Bool: Whether to call the function after include (default: true)\nverbose::Bool: Verbose @testset output (default: true)\nshowtiming::Bool: Show timing in @testset output (default: true)\ntest_dir::String: Root directory for test files (default: joinpath(pwd(), \"test\"))\non_test_start::Union{Function,Nothing}: Callback before eval (default: nothing)\non_test_done::Union{Function,Nothing}: Callback after eval (default: nothing)\nprogress::Bool: Show built-in progress bar (default: true)\n\nReturns\n\nNothing: Tests are executed via side effects\n\nNotes\n\nTest selection is driven by args (coverage flags are automatically filtered out)\nSelection arguments are interpreted as glob patterns and matched against both test names and filenames\nArguments starting with test/ are automatically stripped for convenience\nWhen on_test_done is provided, the built-in progress bar is disabled unless progress=true\n\nExample\n\njulia> using CTBase.TestRunner\n\njulia> # Run all tests with default settings\njulia> CTBase.run_tests()\n\njulia> # Run specific tests with custom callbacks\njulia> CTBase.run_tests(;\n           args=[\"utils\", \"core\"],\n           on_test_start = info -> (println(\"Running: \", info.spec); true),\n           on_test_done = info -> println(\"Done: \", info.status)\n       )\n\nSee also: TestRunner.TestRunInfo, TestRunner._parse_test_args, TestRunner._select_tests\n\n\n\n\n\n","category":"function"},{"location":"index.html#CTBase.jl","page":"Introduction","title":"CTBase.jl","text":"The CTBase.jl package is part of the control-toolbox ecosystem.\n\nIt provides the core types, utilities, and infrastructure used by other packages in the ecosystem, such as OptimalControl.jl.\n\nnote: Note\nThe root package is OptimalControl.jl which aims to provide tools to model and solve optimal control problems with ordinary differential equations by direct and indirect methods, both on CPU and GPU.","category":"section"},{"location":"index.html#Features-and-User-Guides","page":"Introduction","title":"Features and User Guides","text":"CTBase provides several key features to build robust control-toolbox packages:\n\nDescriptions: encoding algorithms: A declarative way to encode algorithms or configurations using tuples of symbols.\nError handling and Exceptions: A domain-specific exception hierarchy for consistent error reporting.\nTest Runner: A modular test runner for granular test execution.\nCoverage Post-processing: Tools to generate readable coverage reports.\nAPI Documentation Generation: Automated API reference generation from docstrings.","category":"section"},{"location":"index.html#Note-on-Private-Methods","page":"Introduction","title":"Note on Private Methods","text":"In some examples in the documentation, private methods are shown without the module prefix. This is done for the sake of clarity and readability.\n\njulia> using CTBase\njulia> x = 1\njulia> private_fun(x) # throws an error\n\nThis should instead be written as:\n\njulia> using CTBase\njulia> x = 1\njulia> CTBase.private_fun(x)\n\nIf the method is re-exported by another package,\n\nmodule OptimalControl\n    import CTBase: private_fun\n    export private_fun\nend\n\nthen there is no need to prefix it with the original module name:\n\njulia> using OptimalControl\njulia> x = 1\njulia> private_fun(x)","category":"section"}]
}

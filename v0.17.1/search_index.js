var documenterSearchIndex = {"docs":
[{"location":"description.html#Private-API","page":"Description","title":"Private API","text":"This page lists non-exported (internal) symbols of CTBase.\n\n","category":"section"},{"location":"description.html#From-CTBase","page":"Description","title":"From CTBase","text":"","category":"section"},{"location":"description.html#DescVarArg","page":"Description","title":"DescVarArg","text":"","category":"section"},{"location":"description.html#Description","page":"Description","title":"Description","text":"","category":"section"},{"location":"description.html#add","page":"Description","title":"add","text":"","category":"section"},{"location":"description.html#complete","page":"Description","title":"complete","text":"","category":"section"},{"location":"description.html#remove","page":"Description","title":"remove","text":"","category":"section"},{"location":"description.html#CTBase.DescVarArg","page":"Description","title":"CTBase.DescVarArg","text":"DescVarArg is a type alias representing a variable number of Symbols.\n\njulia> using CTBase\n\njulia> CTBase.DescVarArg\nVararg{Symbol}\n\nSee also: CTBase.Description.\n\n\n\n\n\n","category":"constant"},{"location":"description.html#CTBase.Description","page":"Description","title":"CTBase.Description","text":"A description is a tuple of symbols. Description is a type alias for a tuple of symbols.\n\nSee also: DescVarArg.\n\nExample\n\nBase.show is overloaded for descriptions, so tuples of descriptions are printed one per line:\n\njulia> using CTBase\n\njulia> display(((:a, :b), (:b, :c)))\n(:a, :b)\n(:b, :c)\n\n\n\n\n\n","category":"type"},{"location":"description.html#CTBase.add","page":"Description","title":"CTBase.add","text":"add(\n    _::Tuple{},\n    y::Tuple{Vararg{Symbol}}\n) -> Tuple{Tuple{Vararg{Symbol}}}\n\n\nReturn a tuple containing only the description y.\n\nExample\n\njulia> using CTBase\n\njulia> descriptions = ()\njulia> descriptions = CTBase.add(descriptions, (:a,))\n(:a,)\njulia> print(descriptions)\n((:a,),)\njulia> descriptions[1]\n(:a,)\n\n\n\n\n\nadd(\n    x::Tuple{Vararg{Tuple{Vararg{Symbol}}}},\n    y::Tuple{Vararg{Symbol}}\n) -> Tuple{Tuple{Vararg{Symbol}}}\n\n\nAdd the description y to the tuple of descriptions x if x does not contain y and return the new tuple of descriptions. \n\nThrow an exception (IncorrectArgument) if the description y is already contained in x.\n\nExample\n\njulia> using CTBase\n\njulia> descriptions = ()\njulia> descriptions = CTBase.add(descriptions, (:a,))\n(:a,)\njulia> descriptions = CTBase.add(descriptions, (:b,))\n(:a,)\n(:b,)\njulia> descriptions = CTBase.add(descriptions, (:b,))\nERROR: IncorrectArgument: the description (:b,) is already in ((:a,), (:b,))\n\n\n\n\n\n","category":"function"},{"location":"description.html#CTBase.complete","page":"Description","title":"CTBase.complete","text":"complete(list::Symbol...; descriptions)\n\n\nReturn one description from a list of Symbols list and a set of descriptions D.  If multiple descriptions are possible, then the first one is selected.\n\nIf the list is not contained in any of the descriptions, then an exception is thrown.\n\nExample\n\njulia> using CTBase\n\njulia> D = ((:a, :b), (:a, :b, :c), (:b, :c), (:a, :c))\n(:a, :b)\n(:b, :c)\n(:a, :c)\njulia> CTBase.complete(:a; descriptions=D)\n(:a, :b)\njulia> CTBase.complete(:a, :c; descriptions=D)\n(:a, :b, :c)\njulia> CTBase.complete((:a, :c); descriptions=D)\n(:a, :b, :c)\njulia> CTBase.complete(:f; descriptions=D)\nERROR: AmbiguousDescription: the description (:f,) is ambiguous / incorrect\n\n\n\n\n\n","category":"function"},{"location":"description.html#CTBase.remove","page":"Description","title":"CTBase.remove","text":"remove(\n    x::Tuple{Vararg{Symbol}},\n    y::Tuple{Vararg{Symbol}}\n) -> Tuple{Vararg{Symbol}}\n\n\nReturn the difference between the description x and the description y.\n\nExample\n\njulia> using CTBase\n\njulia> CTBase.remove((:a, :b), (:a,))\n(:b,)\n\n\n\n\n\n","category":"function"},{"location":"exception.html#Private-API","page":"Exception","title":"Private API","text":"This page lists non-exported (internal) symbols of CTBase.\n\n","category":"section"},{"location":"exception.html#From-CTBase","page":"Exception","title":"From CTBase","text":"","category":"section"},{"location":"exception.html#AmbiguousDescription","page":"Exception","title":"AmbiguousDescription","text":"","category":"section"},{"location":"exception.html#CTException","page":"Exception","title":"CTException","text":"","category":"section"},{"location":"exception.html#ExtensionError","page":"Exception","title":"ExtensionError","text":"","category":"section"},{"location":"exception.html#IncorrectArgument","page":"Exception","title":"IncorrectArgument","text":"","category":"section"},{"location":"exception.html#NotImplemented","page":"Exception","title":"NotImplemented","text":"","category":"section"},{"location":"exception.html#ParsingError","page":"Exception","title":"ParsingError","text":"","category":"section"},{"location":"exception.html#UnauthorizedCall","page":"Exception","title":"UnauthorizedCall","text":"","category":"section"},{"location":"exception.html#Base.showerror","page":"Exception","title":"Base.showerror","text":"","category":"section"},{"location":"exception.html#Base.showerror-2","page":"Exception","title":"Base.showerror","text":"","category":"section"},{"location":"exception.html#Base.showerror-3","page":"Exception","title":"Base.showerror","text":"","category":"section"},{"location":"exception.html#Base.showerror-4","page":"Exception","title":"Base.showerror","text":"","category":"section"},{"location":"exception.html#Base.showerror-5","page":"Exception","title":"Base.showerror","text":"","category":"section"},{"location":"exception.html#Base.showerror-6","page":"Exception","title":"Base.showerror","text":"","category":"section"},{"location":"exception.html#CTBase.AmbiguousDescription","page":"Exception","title":"CTBase.AmbiguousDescription","text":"struct AmbiguousDescription <: CTBase.CTException\n\nException thrown when a description is ambiguous or does not match any known descriptions.\n\nFields\n\nvar::Tuple{Vararg{Symbol}}: The ambiguous or incorrect description tuple that caused the error.\n\nExample\n\njulia> using CTBase\n\njulia> CTBase.complete(:f; descriptions=((:a, :b), (:a, :b, :c)))\nERROR: AmbiguousDescription: the description (:f,) is ambiguous / incorrect\n\nThis error is useful to signal when a user provides a description that cannot be matched to any known valid descriptions.\n\n\n\n\n\n","category":"type"},{"location":"exception.html#CTBase.CTException","page":"Exception","title":"CTBase.CTException","text":"abstract type CTException <: Exception\n\nAbstract supertype for all custom exceptions in this module.\n\nUse this as the common ancestor for all domain-specific errors to allow catching all exceptions of this family via catch e::CTException.\n\nNo fields.\n\nExample\n\njulia> using CTBase\n\njulia> try\n           throw(CTBase.IncorrectArgument(\"invalid input\"))\n       catch e::CTBase.CTException\n           println(\"Caught a domain-specific exception: \", e)\n       end\nCaught a domain-specific exception: IncorrectArgument: invalid input\n\n\n\n\n\n","category":"type"},{"location":"exception.html#CTBase.ExtensionError","page":"Exception","title":"CTBase.ExtensionError","text":"struct ExtensionError <: CTBase.CTException\n\nException thrown when an extension or optional dependency is not loaded but a function requiring it is called.\n\nFields\n\nweakdeps::Tuple{Vararg{Symbol}}: The tuple of symbols representing the missing dependencies.\n\nConstructor\n\nThrows UnauthorizedCall if no weak dependencies are provided.\n\nExample\n\njulia> using CTBase\n\njulia> throw(CTBase.ExtensionError(:MyExtension))\nERROR: ExtensionError. Please make: julia> using MyExtension\n\n\n\n\n\n","category":"type"},{"location":"exception.html#CTBase.IncorrectArgument","page":"Exception","title":"CTBase.IncorrectArgument","text":"struct IncorrectArgument <: CTBase.CTException\n\nException thrown when an argument passed to a function or constructor is inconsistent, invalid, or does not satisfy preconditions.\n\nFields\n\nvar::String: A descriptive message explaining the nature of the incorrect argument.\n\nExample\n\njulia> using CTBase\n\njulia> throw(CTBase.IncorrectArgument(\"the argument must be a non-empty tuple\"))\nERROR: IncorrectArgument: the argument must be a non-empty tuple\n\n\n\n\n\n","category":"type"},{"location":"exception.html#CTBase.NotImplemented","page":"Exception","title":"CTBase.NotImplemented","text":"struct NotImplemented <: CTBase.CTException\n\nException thrown when a method or function has not been implemented yet.\n\nFields\n\nvar::String: A message indicating what functionality is not yet implemented.\n\nExample\n\njulia> using CTBase\n\njulia> throw(CTBase.NotImplemented(\"feature X is not implemented\"))\nERROR: NotImplemented: feature X is not implemented\n\n\n\n\n\n","category":"type"},{"location":"exception.html#CTBase.ParsingError","page":"Exception","title":"CTBase.ParsingError","text":"struct ParsingError <: CTBase.CTException\n\nException thrown during parsing when a syntax error or invalid structure is detected.\n\nFields\n\nvar::String: A message describing the parsing error.\n\nExample\n\njulia> using CTBase\n\njulia> throw(CTBase.ParsingError(\"unexpected token\"))\nERROR: ParsingError: unexpected token\n\n\n\n\n\n","category":"type"},{"location":"exception.html#CTBase.UnauthorizedCall","page":"Exception","title":"CTBase.UnauthorizedCall","text":"struct UnauthorizedCall <: CTBase.CTException\n\nException thrown when a function call is not authorized in the current context or with the given arguments.\n\nFields\n\nvar::String: A message explaining why the call is unauthorized.\n\nExample\n\njulia> using CTBase\n\njulia> throw(CTBase.UnauthorizedCall(\"user does not have permission\"))\nERROR: UnauthorizedCall: user does not have permission\n\n\n\n\n\n","category":"type"},{"location":"exception.html#Base.showerror-Tuple{IO, CTBase.ExtensionError}","page":"Exception","title":"Base.showerror","text":"showerror(io::IO, e::CTBase.ExtensionError)\n\n\nCustomizes the printed message of the exception, prompting the user to load the required extensions.\n\nExample\n\njulia> using CTBase\n\njulia> e = CTBase.ExtensionError(:MyExtension, :AnotherDep)\njulia> showerror(stdout, e)\nERROR: ExtensionError. Please make: julia> using MyExtension, AnotherDep\n\n\n\n\n\n","category":"method"},{"location":"exception.html#Base.showerror-Tuple{IO, CTBase.AmbiguousDescription}","page":"Exception","title":"Base.showerror","text":"showerror(io::IO, e::CTBase.AmbiguousDescription)\n\n\nCustomizes the printed message of the exception.\n\nExample\n\njulia> using CTBase\n\njulia> throw(CTBase.AmbiguousDescription((:x, :y)))\nERROR: AmbiguousDescription: the description (:x, :y) is ambiguous / incorrect\n\n\n\n\n\n","category":"method"},{"location":"exception.html#Base.showerror-Tuple{IO, CTBase.IncorrectArgument}","page":"Exception","title":"Base.showerror","text":"showerror(io::IO, e::CTBase.IncorrectArgument)\n\n\nCustomizes the printed message of the exception.\n\n\n\n\n\n","category":"method"},{"location":"exception.html#Base.showerror-Tuple{IO, CTBase.ParsingError}","page":"Exception","title":"Base.showerror","text":"showerror(io::IO, e::CTBase.ParsingError)\n\n\nCustomizes the printed message of the exception.\n\n\n\n\n\n","category":"method"},{"location":"exception.html#Base.showerror-Tuple{IO, CTBase.NotImplemented}","page":"Exception","title":"Base.showerror","text":"showerror(io::IO, e::CTBase.NotImplemented)\n\n\nCustomizes the printed message of the exception.\n\n\n\n\n\n","category":"method"},{"location":"exception.html#Base.showerror-Tuple{IO, CTBase.UnauthorizedCall}","page":"Exception","title":"Base.showerror","text":"showerror(io::IO, e::CTBase.UnauthorizedCall)\n\n\nCustomizes the printed message of the exception.\n\n\n\n\n\n","category":"method"},{"location":"ctbase.html#Private-API","page":"CTBase","title":"Private API","text":"This page lists non-exported (internal) symbols of CTBase.\n\n","category":"section"},{"location":"ctbase.html#From-CTBase","page":"CTBase","title":"From CTBase","text":"","category":"section"},{"location":"ctbase.html#AbstractDocumenterReferenceTag","page":"CTBase","title":"AbstractDocumenterReferenceTag","text":"","category":"section"},{"location":"ctbase.html#DocumenterReferenceTag","page":"CTBase","title":"DocumenterReferenceTag","text":"","category":"section"},{"location":"ctbase.html#ctNumber","page":"CTBase","title":"ctNumber","text":"","category":"section"},{"location":"ctbase.html#CTBase.AbstractDocumenterReferenceTag","page":"CTBase","title":"CTBase.AbstractDocumenterReferenceTag","text":"abstract type AbstractDocumenterReferenceTag\n\nAbstract supertype for tags used to select a particular implementation of automatic_reference_documentation.\n\nConcrete subtypes identify a specific backend that provides the actual documentation generation logic.\n\nExample\n\njulia> using CTBase\n\njulia> CTBase.DocumenterReferenceTag() isa CTBase.AbstractDocumenterReferenceTag\ntrue\n\n\n\n\n\n","category":"type"},{"location":"ctbase.html#CTBase.DocumenterReferenceTag","page":"CTBase","title":"CTBase.DocumenterReferenceTag","text":"struct DocumenterReferenceTag <: CTBase.AbstractDocumenterReferenceTag\n\nConcrete tag type used to dispatch to the DocumenterReference extension.\n\nInstances of this type are passed to automatic_reference_documentation to enable the integration with Documenter.jl when the DocumenterReference extension is available.\n\nExample\n\njulia> using CTBase\n\njulia> tag = CTBase.DocumenterReferenceTag()\nCTBase.DocumenterReferenceTag()\n\n\n\n\n\n","category":"type"},{"location":"ctbase.html#CTBase.ctNumber","page":"CTBase","title":"CTBase.ctNumber","text":"Type alias for a real number.\n\njulia> const ctNumber = Real\n\n\n\n\n\n","category":"type"},{"location":"default.html#Private-API","page":"Default","title":"Private API","text":"This page lists non-exported (internal) symbols of CTBase.\n\n","category":"section"},{"location":"default.html#From-CTBase","page":"Default","title":"From CTBase","text":"","category":"section"},{"location":"default.html#__display","page":"Default","title":"__display","text":"","category":"section"},{"location":"default.html#CTBase.__display","page":"Default","title":"CTBase.__display","text":"__display() -> Bool\n\n\nReturn the default value of the display flag.\n\nThis internal utility is used to decide whether output should be shown during execution.\n\nReturns\n\nBool: The default value true, indicating that output is displayed.\n\nExample\n\njulia> using CTBase\n\njulia> CTBase.__display()\ntrue\n\n\n\n\n\n","category":"function"},{"location":"index.html#CTBase.jl","page":"Introduction","title":"CTBase.jl","text":"The CTBase.jl package is part of the control-toolbox ecosystem.\n\nnote: Note\nThe root package is OptimalControl.jl which aims to provide tools to model and solve optimal control problems with ordinary differential equations by direct and indirect methods, both on CPU and GPU.\n\nwarning: Warning\nIn some examples in the documentation, private methods are shown without the module prefix. This is done for the sake of clarity and readability.julia> using CTBase\njulia> x = 1\njulia> private_fun(x) # throws an errorThis should instead be written as:julia> using CTBase\njulia> x = 1\njulia> CTBase.private_fun(x)If the method is re-exported by another package, module OptimalControl\n    import CTBase: private_fun\n    export private_fun\nendthen there is no need to prefix it with the original module name:julia> using OptimalControl\njulia> x = 1\njulia> private_fun(x)","category":"section"},{"location":"index.html#Descriptions:-encoding-algorithms","page":"Introduction","title":"Descriptions: encoding algorithms","text":"One of the central ideas in CTBase is the notion of a description. A description is simply a tuple of Symbols that encodes an algorithm or configuration in a declarative way.\n\nFormally, CTBase defines:\n\nconst DescVarArg = Vararg{Symbol}\nconst Description = Tuple{DescVarArg}\n\nFor example, the tuple\n\njulia> using CTBase\n\njulia> d = (:descent, :bfgs, :bisection)\n(:descent, :bfgs, :bisection)\n\njulia> typeof(d) <: CTBase.Description\ntrue\n\ncan be read as “a descent algorithm, with BFGS directions and a bisection line search”. Higher-level packages in the control-toolbox ecosystem use descriptions to catalogue algorithms in a uniform way.","category":"section"},{"location":"index.html#Building-a-library-of-descriptions","page":"Introduction","title":"Building a library of descriptions","text":"CTBase provides a few small functions to manage collections of descriptions:\n\nCTBase.add(x, y) adds the description y to the tuple of descriptions x, rejecting duplicates with an IncorrectArgument exception.\nCTBase.complete(list; descriptions=D) picks a complete description from a set D based on a partial list of symbols.\nCTBase.remove(x, y) returns the set difference of two descriptions.\n\nHere is a complete example of a small “algorithm library”:\n\njulia> algorithms = ()\n()\n\njulia> algorithms = CTBase.add(algorithms, (:descent, :bfgs, :bisection))\n((:descent, :bfgs, :bisection),)\n\njulia> algorithms = CTBase.add(algorithms, (:descent, :gradient, :fixedstep))\n((:descent, :bfgs, :bisection), (:descent, :gradient, :fixedstep))\n\njulia> display(algorithms)\n(:descent, :bfgs, :bisection)\n(:descent, :gradient, :fixedstep)\n\nGiven this library, we can complete a partial description:\n\njulia> CTBase.complete((:descent,); descriptions=algorithms)\n(:descent, :bfgs, :bisection)\n\njulia> CTBase.complete((:gradient, :fixedstep); descriptions=algorithms)\n(:descent, :gradient, :fixedstep)\n\nInternally, CTBase.complete scans the descriptions tuple from top to bottom. For each candidate description it computes:\n\nhow many symbols it shares with the partial list, and\nwhether the partial list is a subset of the full description.\n\nIf no description contains all the symbols from the partial list, AmbiguousDescription is thrown. Otherwise, among the descriptions that do contain the partial list, CTBase selects the one with the largest intersection; if several have the same score, the first one in the descriptions tuple wins. In other words, the order of descriptions encodes a priority from top to bottom.\n\nWith this mechanism in place, we can then analyse the remainder of a description by removing a prefix:\n\njulia> full = CTBase.complete((:descent,); descriptions=algorithms)\n(:descent, :bfgs, :bisection)\n\njulia> CTBase.remove(full, (:descent, :bfgs))\n(:bisection,)\n\nThis “description language” lets higher-level packages refer to algorithms in a structured, composable way, while CTBase takes care of the low-level operations (adding, completing, and comparing descriptions).","category":"section"},{"location":"index.html#Error-handling-and-CTBase-exceptions","page":"Introduction","title":"Error handling and CTBase exceptions","text":"CTBase defines a small hierarchy of domain-specific exceptions to make error handling explicit and consistent across the control-toolbox ecosystem.\n\nAll custom exceptions inherit from CTBase.CTException:\n\nabstract type CTBase.CTException <: Exception end\n\nYou should generally catch exceptions like this:\n\ntry\n    # call into CTBase or a package built on top of it\ncatch e\n    if e isa CTBase.CTException\n        # handle CTBase domain errors in a uniform way\n        @warn \"CTBase error\" exception=(e, catch_backtrace())\n    else\n        # non-CTBase error: rethrow so it is not hidden\n        rethrow()\n    end\nend\n\nThis pattern avoids accidentally swallowing unrelated internal errors while still giving you a single place to handle all CTBase-specific problems.","category":"section"},{"location":"index.html#AmbiguousDescription","page":"Introduction","title":"AmbiguousDescription","text":"CTBase.AmbiguousDescription <: CTBase.CTException\n\nThrown when a description (a tuple of Symbols) cannot be matched to any known valid description. This typically happens in CTBase.complete when the user provides an incomplete or inconsistent description.\n\njulia> using CTBase\n\njulia> D = ((:a, :b), (:a, :b, :c), (:b, :c))\njulia> CTBase.complete(:f; descriptions=D)\nERROR: AmbiguousDescription: the description (:f,) is ambiguous / incorrect\n\nUse this exception when the high-level choice of description itself is wrong or ambiguous and there is no sensible default.","category":"section"},{"location":"index.html#IncorrectArgument","page":"Introduction","title":"IncorrectArgument","text":"CTBase.IncorrectArgument <: CTBase.CTException\n\nThrown when an individual argument is invalid or violates a precondition.\n\nExamples from CTBase:\n\nAdding a duplicate description:\njulia> algorithms = CTBase.add((), (:a, :b))\njulia> CTBase.add(algorithms, (:a, :b))\nERROR: IncorrectArgument: the description (:a, :b) is already in ((:a, :b),)\nUsing invalid indices for the Unicode helpers:\njulia> CTBase.ctindice(-1)\nERROR: IncorrectArgument: the subscript must be between 0 and 9\n\nUse this exception whenever one input value is outside the allowed domain (wrong range, duplicate, empty when it must not be, etc.).","category":"section"},{"location":"index.html#NotImplemented","page":"Introduction","title":"NotImplemented","text":"CTBase.NotImplemented <: CTBase.CTException\n\nUsed to mark interface points that must be implemented by concrete subtypes. The typical pattern is to provide a method on an abstract type that throws NotImplemented, and then override it in each concrete implementation:\n\nabstract type MyAbstractAlgorithm end\n\nfunction run!(algo::MyAbstractAlgorithm, state)\n    throw(CTBase.NotImplemented(\"run! is not implemented for $(typeof(algo))\"))\nend\n\nConcrete algorithms then provide their own run! method instead of raising this exception. This makes it easy to detect missing implementations during testing.\n\nUse NotImplemented when defining interfaces and you want an explicit, typed error rather than a generic error(\"TODO\").","category":"section"},{"location":"index.html#UnauthorizedCall","page":"Introduction","title":"UnauthorizedCall","text":"CTBase.UnauthorizedCall <: CTBase.CTException\n\nSignals that a function call is not allowed in the current state of the object or system. This is different from IncorrectArgument: here the arguments may be valid, but the call is forbidden because of when or how it is made.\n\nA common pattern is a method that is meant to be called only once:\n\nfunction finalize!(s::SomeState)\n    if s.is_finalized\n        throw(CTBase.UnauthorizedCall(\"finalize! was already called for this state\"))\n    end\n    # ... perform finalisation and mark state as finalised ...\nend\n\nUse UnauthorizedCall when the calling context is invalid (wrong phase of a computation, method already called, state already closed, missing permissions, illegal order of calls, etc.).\n\nIt is also used internally by ExtensionError when it is called without any weak dependencies:\n\njulia> using CTBase\n\njulia> CTBase.ExtensionError()\nERROR: UnauthorizedCall: Please provide at least one weak dependence for the extension.","category":"section"},{"location":"index.html#ParsingError","page":"Introduction","title":"ParsingError","text":"CTBase.ParsingError <: CTBase.CTException\n\nIntended for errors detected during parsing of input structures or DSLs (domain-specific languages).\n\njulia> using CTBase\n\njulia> throw(CTBase.ParsingError(\"unexpected token 'end'\"))\nERROR: ParsingError: unexpected token 'end'","category":"section"},{"location":"utils.html#Private-API","page":"Utils","title":"Private API","text":"This page lists non-exported (internal) symbols of CTBase.\n\n","category":"section"},{"location":"utils.html#From-CTBase","page":"Utils","title":"From CTBase","text":"","category":"section"},{"location":"utils.html#ctindice","page":"Utils","title":"ctindice","text":"","category":"section"},{"location":"utils.html#ctindices","page":"Utils","title":"ctindices","text":"","category":"section"},{"location":"utils.html#ctupperscript","page":"Utils","title":"ctupperscript","text":"","category":"section"},{"location":"utils.html#ctupperscripts","page":"Utils","title":"ctupperscripts","text":"","category":"section"},{"location":"utils.html#CTBase.ctindice","page":"Utils","title":"CTBase.ctindice","text":"ctindice(i::Int64) -> Char\n\n\nReturn the integer i ∈ [0, 9] as a Unicode subscript character.\n\nThrows an IncorrectArgument exception if i is outside this range.\n\nThe Unicode subscript digits start at codepoint U+2080 for '0' and continue sequentially.\n\nExample\n\njulia> using CTBase\n\njulia> CTBase.ctindice(3)\n'₃': Unicode U+2083 (category No: Number, other)\n\n\n\n\n\n","category":"function"},{"location":"utils.html#CTBase.ctindices","page":"Utils","title":"CTBase.ctindices","text":"ctindices(i::Int64) -> String\n\n\nReturn the integer i ≥ 0 as a string of Unicode subscript characters.\n\nThrows an IncorrectArgument if i is negative.\n\nExample\n\njulia> using CTBase\n\njulia> CTBase.ctindices(123)\n\"₁₂₃\"\n\n\n\n\n\n","category":"function"},{"location":"utils.html#CTBase.ctupperscript","page":"Utils","title":"CTBase.ctupperscript","text":"ctupperscript(i::Int64) -> Char\n\n\nReturn the integer i ∈ [0, 9] as a Unicode superscript (upper) character.\n\nThrows an IncorrectArgument exception if i is outside this range.\n\nNote: Unicode superscripts ¹ (U+00B9), ² (U+00B2), and ³ (U+00B3) are special cases. The other digits ⁰ (U+2070) and ⁴ to ⁹ (U+2074 to U+2079) are mostly contiguous.\n\nExample\n\njulia> using CTBase\n\njulia> CTBase.ctupperscript(2)\n'²': Unicode U+00B2 (category No: Number, other)\n\n\n\n\n\n","category":"function"},{"location":"utils.html#CTBase.ctupperscripts","page":"Utils","title":"CTBase.ctupperscripts","text":"ctupperscripts(i::Int64) -> String\n\n\nReturn the integer i ≥ 0 as a string of Unicode superscript characters.\n\nThrows an IncorrectArgument exception if i is negative.\n\nExample\n\njulia> using CTBase\n\njulia> CTBase.ctupperscripts(123)\n\"¹²³\"\n\n\n\n\n\n","category":"function"}]
}

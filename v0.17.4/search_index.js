var documenterSearchIndex = {"docs":
[{"location":"documentation-guide.html#Documentation-Guide","page":"Documentation","title":"Documentation Guide","text":"This guide explains how to set up automated API reference documentation generation using the DocumenterReference extension. This is particularly useful for maintaining comprehensive and up-to-date API documentation as your codebase evolves.","category":"section"},{"location":"documentation-guide.html#Overview","page":"Documentation","title":"Overview","text":"The DocumenterReference extension provides the CTBase.automatic_reference_documentation() function, which automatically generates API reference pages from your Julia source code. It:\n\nExtracts docstrings from your modules\nSeparates public and private APIs\nGenerates markdown files suitable for Documenter.jl\nHandles extensions and optional dependencies gracefully\nSupports filtering and customization","category":"section"},{"location":"documentation-guide.html#Architecture","page":"Documentation","title":"Architecture","text":"","category":"section"},{"location":"documentation-guide.html#Directory-Structure","page":"Documentation","title":"Directory Structure","text":"docs/\n├── make.jl                 # Main documentation build script\n├── api_reference.jl        # API reference generation logic\n└── src/\n    ├── index.md           # Documentation homepage\n    ├── developers-guide.md # Testing and coverage guide\n    └── documentation-guide.md  # This file","category":"section"},{"location":"documentation-guide.html#How-It-Works","page":"Documentation","title":"How It Works","text":"The documentation generation happens in two stages:\n\napi_reference.jl: Defines generate_api_reference() which calls CTBase.automatic_reference_documentation() for each module\nmake.jl: Calls with_api_reference() which executes the generation and passes the pages to Documenter.makedocs()","category":"section"},{"location":"documentation-guide.html#Setting-Up-API-Documentation","page":"Documentation","title":"Setting Up API Documentation","text":"","category":"section"},{"location":"documentation-guide.html#Basic-Configuration","page":"Documentation","title":"Basic Configuration","text":"The core function is CTBase.automatic_reference_documentation(). Here's a minimal example:\n\nusing CTBase\nusing Documenter\n\nCTBase.automatic_reference_documentation(;\n    subdirectory=\".\",\n    primary_modules=[MyModule => [\"src/MyModule.jl\"]],\n    title=\"MyModule API\",\n    title_in_menu=\"API\",\n    filename=\"api\",\n)","category":"section"},{"location":"documentation-guide.html#Key-Parameters","page":"Documentation","title":"Key Parameters","text":"subdirectory: Where to write generated markdown files (relative to docs/src)\nprimary_modules: Vector of modules to document, optionally with source files\nFormat: Module or Module => [\"path/to/file.jl\"]\nWhen source files are provided, only symbols from those files are documented\ntitle: Title displayed at the top of the generated page\ntitle_in_menu: Title in the navigation menu (defaults to title)\nfilename: Base filename for the markdown file (without .md extension)\nexclude: Vector of symbol names to skip from documentation\npublic: Generate public API page (default: true)\nprivate: Generate private API page (default: true)\nexternal_modules_to_document: Additional modules to search for docstrings (e.g., [Base])","category":"section"},{"location":"documentation-guide.html#Public-vs.-Private-API","page":"Documentation","title":"Public vs. Private API","text":"The public and private flags control which symbols are documented:","category":"section"},{"location":"documentation-guide.html#Option-1:-Public-API-Only-(publictrue,-privatefalse)","page":"Documentation","title":"Option 1: Public API Only (public=true, private=false)","text":"CTBase.automatic_reference_documentation(;\n    subdirectory=\".\",\n    primary_modules=[MyModule => src(\"MyModule.jl\")],\n    public=true,\n    private=false,\n    title=\"MyModule API\",\n    filename=\"api\",\n)\n\nResult: Only exported symbols are documented. This is ideal for end-user documentation.","category":"section"},{"location":"documentation-guide.html#Option-2:-Private-API-Only-(publicfalse,-privatetrue)","page":"Documentation","title":"Option 2: Private API Only (public=false, private=true)","text":"CTBase.automatic_reference_documentation(;\n    subdirectory=\".\",\n    primary_modules=[MyModule => src(\"MyModule.jl\")],\n    public=false,\n    private=true,\n    title=\"MyModule Internals\",\n    filename=\"internals\",\n)\n\nResult: Only non-exported (private) symbols are documented. Useful for developer documentation.","category":"section"},{"location":"documentation-guide.html#Option-3:-Both-Public-and-Private-(publictrue,-privatetrue)","page":"Documentation","title":"Option 3: Both Public and Private (public=true, private=true)","text":"CTBase.automatic_reference_documentation(;\n    subdirectory=\".\",\n    primary_modules=[MyModule => src(\"MyModule.jl\")],\n    public=true,\n    private=true,\n    title=\"MyModule Complete Reference\",\n    filename=\"complete_api\",\n)\n\nResult: All symbols are documented in a single page. This provides a comprehensive reference.","category":"section"},{"location":"documentation-guide.html#Example:-CTBase-Configuration","page":"Documentation","title":"Example: CTBase Configuration","text":"Here's how CTBase configures its API documentation in docs/api_reference.jl:\n\nfunction generate_api_reference(src_dir::String)\n    # Helper functions to build absolute paths\n    src(files...) = [abspath(joinpath(src_dir, f)) for f in files]\n    ext_dir = abspath(joinpath(src_dir, \"..\", \"ext\"))\n    ext(files...) = [abspath(joinpath(ext_dir, f)) for f in files]\n\n    # Symbols to exclude from all API pages\n    EXCLUDE_SYMBOLS = Symbol[:include, :eval]\n\n    pages = [\n        # Main CTBase module - private API only\n        CTBase.automatic_reference_documentation(;\n            subdirectory=\".\",\n            primary_modules=[CTBase => src(\"CTBase.jl\")],\n            exclude=EXCLUDE_SYMBOLS,\n            public=false,\n            private=true,\n            title=\"CTBase\",\n            title_in_menu=\"CTBase\",\n            filename=\"ctbase\",\n        ),\n        # Other modules...\n    ]\n\n    # Extensions are checked with Base.get_extension\n    DocumenterReference = Base.get_extension(CTBase, :DocumenterReference)\n    if !isnothing(DocumenterReference)\n        push!(\n            pages,\n            CTBase.automatic_reference_documentation(;\n                subdirectory=\".\",\n                primary_modules=[DocumenterReference => ext(\"DocumenterReference.jl\")],\n                external_modules_to_document=[CTBase],\n                exclude=EXCLUDE_SYMBOLS,\n                public=false,\n                private=true,\n                title=\"DocumenterReference\",\n                title_in_menu=\"DocumenterReference\",\n                filename=\"documenter_reference\",\n            ),\n        )\n    end\n\n    return pages\nend","category":"section"},{"location":"documentation-guide.html#Handling-Extensions","page":"Documentation","title":"Handling Extensions","text":"When your package uses extensions (weak dependencies), you need to check if they're loaded before documenting them:\n\n# Check if the extension is loaded\nMyExtension = Base.get_extension(MyPackage, :MyExtension)\nif !isnothing(MyExtension)\n    push!(\n        pages,\n        CTBase.automatic_reference_documentation(;\n            subdirectory=\".\",\n            primary_modules=[MyExtension => ext(\"MyExtension.jl\")],\n            external_modules_to_document=[MyPackage],\n            exclude=EXCLUDE_SYMBOLS,\n            public=false,\n            private=true,\n            title=\"MyExtension\",\n            title_in_menu=\"MyExtension\",\n            filename=\"my_extension\",\n        ),\n    )\nend\n\nThis ensures that:\n\nDocumentation is only generated if the extension is actually loaded\nThe extension can reference types and functions from the main package via external_modules_to_document","category":"section"},{"location":"documentation-guide.html#Integration-with-Documenter.jl","page":"Documentation","title":"Integration with Documenter.jl","text":"In docs/make.jl, use with_api_reference() to integrate the generated pages:\n\nusing Documenter\nusing CTBase\n\ninclude(\"api_reference.jl\")\n\nwith_api_reference(dirname(@__DIR__)) do api_pages\n    makedocs(;\n        modules=[CTBase],\n        authors=\"Your Name\",\n        repo=\"https://github.com/yourname/yourpackage.jl\",\n        sitename=\"YourPackage.jl\",\n        format=Documenter.HTML(;\n            assets=String[],\n        ),\n        pages=[\n            \"Introduction\" => \"index.md\",\n            \"Developers Guide\" => \"developers-guide.md\",\n            \"Documentation Guide\" => \"documentation-guide.md\",\n            \"API Reference\" => api_pages,\n        ],\n        checkdocs=:none,\n    )\nend\n\nThe with_api_reference() function:\n\nGenerates the API reference pages\nPasses them to your makedocs() call\nCleans up temporary generated files after the build","category":"section"},{"location":"documentation-guide.html#DocType-System","page":"Documentation","title":"DocType System","text":"The DocumenterReference extension recognizes several documentation element types:\n\nDOCTYPE_ABSTRACT_TYPE: Abstract type declarations\nDOCTYPE_STRUCT: Concrete struct types\nDOCTYPE_FUNCTION: Functions and callables\nDOCTYPE_MACRO: Macros (names starting with @)\nDOCTYPE_MODULE: Submodules\nDOCTYPE_CONSTANT: Constants and non-function values\n\nThese types are automatically detected and organized in the generated documentation.","category":"section"},{"location":"documentation-guide.html#Best-Practices","page":"Documentation","title":"Best Practices","text":"Exclude internal symbols: Use the exclude parameter to hide implementation details\nexclude=Symbol[:_internal_helper, :_private_constant]\nSeparate public and private: Create separate pages for public and private APIs\n# Public API\nCTBase.automatic_reference_documentation(;\n    ...,\n    public=true,\n    private=false,\n    filename=\"api_public\",\n)\n# Private API\nCTBase.automatic_reference_documentation(;\n    ...,\n    public=false,\n    private=true,\n    filename=\"api_private\",\n)\nDocument external modules: Use external_modules_to_document to include methods from other packages\nCTBase.automatic_reference_documentation(;\n    ...,\n    external_modules_to_document=[Base, Documenter],\n)\nCheck extensions before documenting: Always use Base.get_extension() to safely check for optional dependencies\nMyExt = Base.get_extension(MyPackage, :MyExtension)\nif !isnothing(MyExt)\n    # Document the extension\nend","category":"section"},{"location":"documentation-guide.html#Troubleshooting","page":"Documentation","title":"Troubleshooting","text":"","category":"section"},{"location":"documentation-guide.html#Missing-Docstrings","page":"Documentation","title":"Missing Docstrings","text":"If symbols appear without docstrings in the generated documentation, ensure:\n\nThe docstring is defined immediately before the symbol\nThe docstring uses the correct Julia docstring syntax (triple quotes)\nThe symbol is actually exported or included in your module","category":"section"},{"location":"documentation-guide.html#Symbols-Not-Appearing","page":"Documentation","title":"Symbols Not Appearing","text":"If expected symbols don't appear in the documentation:\n\nCheck if they're in the exclude list\nVerify the source file path is correct\nEnsure the symbol is defined in the specified source file (not imported)","category":"section"},{"location":"documentation-guide.html#Extension-Not-Documented","page":"Documentation","title":"Extension Not Documented","text":"If an extension's documentation isn't generated:\n\nVerify the extension is loaded with Base.get_extension()\nCheck that the extension file path is correct\nEnsure the extension module is properly defined","category":"section"},{"location":"documentation-guide.html#Summary","page":"Documentation","title":"Summary","text":"The DocumenterReference extension provides a powerful, flexible system for automatically generating API documentation. By following the patterns shown in this guide, you can maintain comprehensive, up-to-date documentation with minimal manual effort.","category":"section"},{"location":"ctbase.html#Private-API","page":"CTBase","title":"Private API","text":"This page lists non-exported (internal) symbols of CTBase.\n\n","category":"section"},{"location":"ctbase.html#From-CTBase","page":"CTBase","title":"From CTBase","text":"","category":"section"},{"location":"ctbase.html#AbstractCoveragePostprocessingTag","page":"CTBase","title":"AbstractCoveragePostprocessingTag","text":"","category":"section"},{"location":"ctbase.html#AbstractDocumenterReferenceTag","page":"CTBase","title":"AbstractDocumenterReferenceTag","text":"","category":"section"},{"location":"ctbase.html#AbstractTestRunnerTag","page":"CTBase","title":"AbstractTestRunnerTag","text":"","category":"section"},{"location":"ctbase.html#CoveragePostprocessingTag","page":"CTBase","title":"CoveragePostprocessingTag","text":"","category":"section"},{"location":"ctbase.html#DocumenterReferenceTag","page":"CTBase","title":"DocumenterReferenceTag","text":"","category":"section"},{"location":"ctbase.html#TestRunnerTag","page":"CTBase","title":"TestRunnerTag","text":"","category":"section"},{"location":"ctbase.html#automatic_reference_documentation","page":"CTBase","title":"automatic_reference_documentation","text":"","category":"section"},{"location":"ctbase.html#ctNumber","page":"CTBase","title":"ctNumber","text":"","category":"section"},{"location":"ctbase.html#postprocess_coverage","page":"CTBase","title":"postprocess_coverage","text":"","category":"section"},{"location":"ctbase.html#run_tests","page":"CTBase","title":"run_tests","text":"","category":"section"},{"location":"ctbase.html#CTBase.AbstractCoveragePostprocessingTag","page":"CTBase","title":"CTBase.AbstractCoveragePostprocessingTag","text":"abstract type AbstractCoveragePostprocessingTag\n\nAbstract supertype for tags used to select a particular implementation of postprocess_coverage.\n\nConcrete subtypes identify a specific backend that provides the actual coverage post-processing logic.\n\nExample\n\njulia> using CTBase\n\njulia> CTBase.CoveragePostprocessingTag() isa CTBase.AbstractCoveragePostprocessingTag\ntrue\n\n\n\n\n\n","category":"type"},{"location":"ctbase.html#CTBase.AbstractDocumenterReferenceTag","page":"CTBase","title":"CTBase.AbstractDocumenterReferenceTag","text":"abstract type AbstractDocumenterReferenceTag\n\nAbstract supertype for tags used to select a particular implementation of automatic_reference_documentation.\n\nConcrete subtypes identify a specific backend that provides the actual documentation generation logic.\n\nExample\n\njulia> using CTBase\n\njulia> CTBase.DocumenterReferenceTag() isa CTBase.AbstractDocumenterReferenceTag\ntrue\n\n\n\n\n\n","category":"type"},{"location":"ctbase.html#CTBase.AbstractTestRunnerTag","page":"CTBase","title":"CTBase.AbstractTestRunnerTag","text":"abstract type AbstractTestRunnerTag\n\nAbstract supertype for tags used to select a particular implementation of run_tests.\n\nConcrete subtypes identify a specific backend that provides the actual test runner logic.\n\n\n\n\n\n","category":"type"},{"location":"ctbase.html#CTBase.CoveragePostprocessingTag","page":"CTBase","title":"CTBase.CoveragePostprocessingTag","text":"struct CoveragePostprocessingTag <: CTBase.AbstractCoveragePostprocessingTag\n\nConcrete tag type used to dispatch to the CoveragePostprocessing extension.\n\nInstances of this type are passed to postprocess_coverage to enable coverage post-processing when the extension is available.\n\n\n\n\n\n","category":"type"},{"location":"ctbase.html#CTBase.DocumenterReferenceTag","page":"CTBase","title":"CTBase.DocumenterReferenceTag","text":"struct DocumenterReferenceTag <: CTBase.AbstractDocumenterReferenceTag\n\nConcrete tag type used to dispatch to the DocumenterReference extension.\n\nInstances of this type are passed to automatic_reference_documentation to enable the integration with Documenter.jl when the DocumenterReference extension is available.\n\nExample\n\njulia> using CTBase\n\njulia> tag = CTBase.DocumenterReferenceTag()\nCTBase.DocumenterReferenceTag()\n\n\n\n\n\n","category":"type"},{"location":"ctbase.html#CTBase.TestRunnerTag","page":"CTBase","title":"CTBase.TestRunnerTag","text":"struct TestRunnerTag <: CTBase.AbstractTestRunnerTag\n\nConcrete tag type used to dispatch to the TestRunner extension.\n\nInstances of this type are passed to run_tests to enable the extension-based test runner when the extension is available.\n\n\n\n\n\n","category":"type"},{"location":"ctbase.html#CTBase.automatic_reference_documentation","page":"CTBase","title":"CTBase.automatic_reference_documentation","text":"automatic_reference_documentation(\n    ::CTBase.AbstractDocumenterReferenceTag;\n    kwargs...\n)\n\n\nGenerate API reference documentation pages for one or more modules.\n\nThis method is an extension point: the default implementation throws an ExtensionError unless a backend extension providing the actual implementation is loaded (e.g. the DocumenterReference extension).\n\nKeyword Arguments\n\nForwarded to the active backend implementation.\n\nThrows\n\nExtensionError: If no backend extension is loaded.\n\n\n\n\n\nautomatic_reference_documentation(; kwargs...)\n\n\nConvenience wrapper for automatic_reference_documentation using the default backend tag.\n\nKeyword Arguments\n\nForwarded to automatic_reference_documentation(DocumenterReferenceTag(); kwargs...).\n\nThrows\n\nExtensionError: If the required backend extension is not loaded.\n\n\n\n\n\nautomatic_reference_documentation(;\n    subdirectory::String,\n    primary_modules,\n    sort_by::Function = identity,\n    exclude::Vector{Symbol} = Symbol[],\n    public::Bool = true,\n    private::Bool = true,\n    title::String = \"API Reference\",\n    title_in_menu::String = \"\",\n    filename::String = \"\",\n    source_files::Vector{String} = String[],\n    include_without_source::Bool = false,\n    external_modules_to_document::Vector{Module} = Module[],\n)\n\nAutomatically creates the API reference documentation for one or more modules and returns a structure which can be used in the pages argument of Documenter.makedocs.\n\nArguments\n\nsubdirectory: the directory relative to the documentation root in which to write the API files.\nprimary_modules: a vector of modules or Module => source_files pairs to document. When source files are provided, only symbols defined in those files are documented.\nsort_by: a custom sort function applied to symbol lists.\nexclude: vector of symbol names to skip from the generated API.\npublic: flag to generate public API page (default: true).\nprivate: flag to generate private API page (default: true).\ntitle: title displayed at the top of the generated page.\ntitle_in_menu: title displayed in the navigation menu (default: same as title).\nfilename: base filename (without extension) for the markdown file.\nsource_files: global source file paths (fallback if no module-specific files). Deprecated: prefer using primary_modules=[Module => files] instead.\ninclude_without_source: if true, include symbols whose source file cannot be determined. Default: false.\nexternal_modules_to_document: additional modules to search for docstrings (e.g., [Plots] to include Plots.plot methods defined in your source files).\n\nMultiple instances\n\nEach time you call this function, a new object is added to the global variable DocumenterReference.CONFIG. Use reset_config!() to clear it between builds.\n\n\n\n\n\n","category":"function"},{"location":"ctbase.html#CTBase.ctNumber","page":"CTBase","title":"CTBase.ctNumber","text":"Type alias for a real number.\n\nThis constant is primarily meant as a short, semantic alias when writing APIs that accept real-valued quantities.\n\nExample\n\njulia> using CTBase\n\njulia> CTBase.ctNumber === Real\ntrue\n\n\n\n\n\n","category":"type"},{"location":"ctbase.html#CTBase.postprocess_coverage","page":"CTBase","title":"CTBase.postprocess_coverage","text":"postprocess_coverage(\n    ::CTBase.AbstractCoveragePostprocessingTag;\n    generate_report,\n    root_dir\n)\n\n\nPost-process coverage artifacts produced by Pkg.test(; coverage=true).\n\nThis is an extension point: the default implementation throws an ExtensionError unless a backend extension (e.g. CoveragePostprocessing) is loaded.\n\nKeyword Arguments\n\ngenerate_report::Bool=true: Whether to generate summary reports.\nroot_dir::String=pwd(): Project root directory used to locate coverage artifacts.\n\nThrows\n\nExtensionError: If the coverage post-processing extension is not loaded.\n\n\n\n\n\npostprocess_coverage(; kwargs...)\n\n\nConvenience wrapper for postprocess_coverage using the default backend tag.\n\nKeyword Arguments\n\nForwarded to postprocess_coverage(CoveragePostprocessingTag(); kwargs...).\n\nThrows\n\nExtensionError: If the coverage post-processing extension is not loaded.\n\n\n\n\n\nCTBase.postprocess_coverage(::CTBase.CoveragePostprocessingTag; generate_report::Bool=true, root_dir::String=pwd())\n\nPost-process coverage artifacts produced by Pkg.test(; coverage=true).\n\nThis implementation:\n\nCollects coverage source directories under root_dir (src/, test/, ext/ when present)\nResets the coverage/ directory\nRemoves stale .cov files (keeping the most complete PID suffix when multiple runs exist)\nOptionally generates reports (LCOV + markdown report)\nMoves .cov files into coverage/cov/ (recursively from source dirs)\n\nKeyword Arguments\n\ngenerate_report::Bool=true: If true, write coverage/lcov.info and coverage/cov_report.md.\nroot_dir::String=pwd(): Root directory of the project.\n\nReturns\n\nNothing\n\nNotes\n\nThis function creates/removes/moves files and directories under root_dir.\n\nUsage sketch (non-executed)\n\nusing CTBase\n\n# CTBase.postprocess_coverage(; generate_report=true, root_dir=pwd())\n\n\n\n\n\n","category":"function"},{"location":"ctbase.html#CTBase.run_tests","page":"CTBase","title":"CTBase.run_tests","text":"run_tests(\n    ::CTBase.AbstractTestRunnerTag;\n    kwargs...\n) -> Union{Nothing, Test.FallbackTestSet, Test.DefaultTestSet}\n\n\nRun the project test suite using an extension-provided test runner.\n\nThis is an extension point: the default implementation throws an ExtensionError unless a backend extension is loaded.\n\nKeyword Arguments\n\nForwarded to the active backend implementation.\n\nThrows\n\nExtensionError: If the test runner extension is not loaded.\n\n\n\n\n\nrun_tests(\n;\n    kwargs...\n) -> Union{Nothing, Test.FallbackTestSet, Test.DefaultTestSet}\n\n\nConvenience wrapper for run_tests using the default backend tag.\n\nKeyword Arguments\n\nForwarded to run_tests(TestRunnerTag(); kwargs...).\n\nThrows\n\nExtensionError: If the test runner extension is not loaded.\n\n\n\n\n\nrun_tests(::CTBase.TestRunnerTag; kwargs...)\n\nRun tests with configurable file/function name builders and optional available tests filter.\n\nKeyword Arguments\n\ntestset_name::String = \"Tests\" — name of the main testset\navailable_tests::Vector{Symbol} = Symbol[] — if non-empty, only these tests are allowed\nfilename_builder::Function = identity — Symbol → Symbol, builds the filename from the test name\nfuncname_builder::Function = identity — Symbol → Symbol|Nothing, builds the function name (or nothing to skip eval)\neval_mode::Bool = true — whether to eval the function after include\nverbose::Bool = true — verbose testset output\nshowtiming::Bool = true — show timing in testset output\n\nNotes\n\nTest selection is driven by Main.ARGS (coverage flags are ignored).\nSelection arguments are interpreted as glob patterns and matched against both the test name and the corresponding filename.\n\nUsage sketch (non-executed)\n\nusing CTBase\n\n# CTBase.run_tests(; testset_name=\"Tests\")\n\n\n\n\n\n","category":"function"},{"location":"test-coverage-guide.html#Developers-Guide","page":"Testing and Coverage","title":"Developers Guide","text":"This guide explains how to set up an advanced testing and coverage infrastructure for Julia packages. This setup is designed to be friendly both for human developers and AI agents, enabling granular test execution and feedback-driven development.","category":"section"},{"location":"test-coverage-guide.html#Architecture-Overview","page":"Testing and Coverage","title":"Architecture Overview","text":"A robust testing architecture typically involves:\n\nTest Runner: A runtests.jl file that allows running specific test groups via command-line arguments.\nCoverage Post-processing: A coverage.jl script that generates human-readable and machine-parseable coverage reports.\nTest Suite Structure: Modular test files, each containing a main entry point function.\nAgent Workflow: A standardized workflow definition (e.g., for LLM agents) to autonomously run tests and analyze coverage.","category":"section"},{"location":"test-coverage-guide.html#Recommended-Directory-Structure","page":"Testing and Coverage","title":"Recommended Directory Structure","text":"We recommend placing your tests in a suite subdirectory to keep the top-level test/ folder clean.\n\nMyPackage.jl/\n├── .agent/\n│   └── workflows/\n│       └── test-julia.md    # Agent workflow definition\n├── src/\n│   └── ...\n├── test/\n│   ├── coverage.jl          # Coverage post-processing script\n│   ├── runtests.jl          # Main test runner\n│   └── suite/               # Directory containing test files\n│       ├── test_utils.jl\n│       ├── test_core.jl\n│       └── ...\n└── ...","category":"section"},{"location":"test-coverage-guide.html#Setting-up-runtests.jl","page":"Testing and Coverage","title":"Setting up runtests.jl","text":"The runtests.jl file is the entry point for your test suite. By using CTBase.run_tests, you enable a powerful mechanism to filter and execute specific tests using command-line arguments. This is crucial for fast iteration cycles.","category":"section"},{"location":"test-coverage-guide.html#Example-test/runtests.jl","page":"Testing and Coverage","title":"Example test/runtests.jl","text":"# ==============================================================================\n# MyPackage Test Runner\n# ==============================================================================\n#\n# This test runner uses the CTBase TestRunner extension (triggered by `using Test`)\n# to execute tests with configurable file/function name builders and optional\n# test selection via command-line arguments.\n#\n# ## Running Tests\n#\n# ### Default (all available tests)\n#\n#   julia --project -e 'using Pkg; Pkg.test(\"MyPackage\")'\n#\n# ### Run a specific test group\n#\n#   julia --project -e 'using Pkg; Pkg.test(\"MyPackage\"; test_args=[\"utils\"])'\n#   julia --project -e 'using Pkg; Pkg.test(\"MyPackage\"; test_args=[\"core\", \"utils\"])'\n#\n# Note: \n# - Passing `-a` or `--all` is equivalent to running without arguments.\n# - Passing `--dry-run` will print the list of tests that would be run, but not execute them.\n#\n# ## Coverage Mode\n#\n# Run tests with code coverage instrumentation:\n#\n#   julia --project -e '\n#       using Pkg; \n#       Pkg.test(\"MyPackage\"; coverage=true); \n#       include(\"test/coverage.jl\")\n#   '\n#\n# This produces:\n#   - coverage/lcov.info      — LCOV format for CI integration\n#   - coverage/cov_report.md  — Human-readable summary with uncovered lines\n#   - coverage/cov/           — Archived .cov files\n#\n# ## Test Groups\n#\n# Each test group corresponds to a file `test/suite/test_<name>.jl` that defines\n# a function `test_<name>()`. The `available_tests` list below controls\n# which groups are valid; requests for unlisted groups will error.\n# ==============================================================================\n\n# Load dependencies\nusing Test\nusing CTBase # Provides run_tests\nusing MyPackage # Your package\n\n# Define where your tests are located\nconst TEST_DIR = @__DIR__\n\n# Run tests using the CTBase test runner\nCTBase.run_tests(;\n    args=String.(ARGS),                 # Pass command line arguments\n    testset_name=\"MyPackage Tests\",     # Name of the main testset\n    available_tests=[                   # List of available test groups/files\n        \"suite/*\"                       # Use glob pattern to include all tests in suite/\n    ],\n    # Function to map a test name in ARGS (like \"utils\") to a filename\n    filename_builder = name -> \"test_$(name).jl\",\n    # Function to map a test name in ARGS to the function to call inside that file\n    funcname_builder = name -> \"test_$(name)\",\n    test_dir=TEST_DIR,                  # Directory containing test files\n    verbose=true,                       # Show verbose output\n    showtiming=true,                    # Show timing information\n)\n\n# If running with coverage enabled, remind the user to run the post-processing script\nif Base.JLOptions().code_coverage != 0\n    println(\n        \"\"\"\n        ================================================================================\n        Coverage files generated. To process them, please run:\n\n            julia --project -e '\n                using Pkg; \n                Pkg.test(\"MyPackage\"; coverage=true); \n                include(\"test/coverage.jl\")'\n            '\n        ================================================================================\n        \"\"\"\n    )\nend","category":"section"},{"location":"test-coverage-guide.html#Writing-Test-Files","page":"Testing and Coverage","title":"Writing Test Files","text":"To support the modular execution model, each test file should define a function (typically matching the filename) that contains the tests. This avoids scope pollution and makes the tests easy to invoke programmatically.","category":"section"},{"location":"test-coverage-guide.html#Example-test/suite/test_utils.jl","page":"Testing and Coverage","title":"Example test/suite/test_utils.jl","text":"# The function name matches the `funcname_builder` logic in runtests.jl\nfunction test_utils()\n    @testset \"Utilities\" begin\n        @test MyPackage.add(1, 1) == 2\n        @test MyPackage.sub(2, 1) == 1\n    end\nend","category":"section"},{"location":"test-coverage-guide.html#Setting-up-Coverage","page":"Testing and Coverage","title":"Setting up Coverage","text":"To generate actionable coverage reports, we use a dedicated coverage.jl script. This script processes the raw .cov files generated by Julia and produces summaries that are easy for an agent to read.","category":"section"},{"location":"test-coverage-guide.html#Example-test/coverage.jl","page":"Testing and Coverage","title":"Example test/coverage.jl","text":"# Add the test directory to the load path so Julia can find dependencies from \n# test/Project.toml. This is necessary because this script is included from the \n# main project context, not from the test project context. Without this, Julia \n# won't find Coverage and other test-only dependencies.\npushfirst!(LOAD_PATH, @__DIR__)\n\nusing Pkg\nusing CTBase # Provides postprocess_coverage\nusing Coverage\n\n# This function:\n# 1. Aggregates coverage data.\n# 2. Generates an LCOV file (coverage/lcov.info).\n# 3. Generates a markdown summary (coverage/cov_report.md).\n# 4. Archives used .cov files to keep the directory clean.\nCTBase.postprocess_coverage(; \n    root_dir=dirname(@__DIR__) # Point to the package root\n)","category":"section"},{"location":"test-coverage-guide.html#Running-with-Coverage","page":"Testing and Coverage","title":"Running with Coverage","text":"To run tests and generate the report:\n\njulia --project -e '\n    using Pkg; \n    Pkg.test(\"MyPackage\"; coverage=true); \n    include(\"test/coverage.jl\")\n'\n\nThe resulting coverage/cov_report.md will contain a list of files with their coverage percentages and, crucially, a list of uncovered lines. This allows an agent to identify exactly which parts of the code need more tests.","category":"section"},{"location":"test-coverage-guide.html#Agent-Workflow-Integration","page":"Testing and Coverage","title":"Agent Workflow Integration","text":"To leverage LLM agents for testing, you can define a workflow that orchestrates these tools. The agent can:\n\nRun the full suite or specific tests.\nRead the coverage report.\nWrite new tests to improve coverage.\nRepeat.\n\nCreate a file at .agent/workflows/improve-coverage.md (or similar path) to describe this process.","category":"section"},{"location":"test-coverage-guide.html#Example-Workflow-Snippet","page":"Testing and Coverage","title":"Example Workflow Snippet","text":"---\ndescription: Test and improve code coverage by analyzing coverage reports and writing targeted tests in Julia\n---\n\n# Julia Test & Coverage Workflow\n\n## Context\n- **Run all tests**: `julia --project -e 'using Pkg; Pkg.test(\"MyPackage\")'`\n- **Run specific test**: `julia --project -e 'using Pkg; Pkg.test(\"MyPackage\"; test_args=[\"core\"])'`\n- **Generate Coverage**: `julia --project -e 'using Pkg; Pkg.test(\"MyPackage\"; coverage=true); include(\"test/coverage.jl\")'`\n\n## Workflow Steps\n\n1. **Analyze**: Check current coverage by running the coverage command.\n2. **Read Report**: Read `coverage/cov_report.md` to find files with low coverage.\n3. **Plan**: Select a file to improve.\n4. **Implement**:\n   * Read the corresponding test file (e.g., `test/suite/test_core.jl`).\n   * Add new test cases to the `test_core()` function.\n5. **Verify**:\n   * Run only the modified test group: `julia --project -e 'using Pkg; Pkg.test(\"MyPackage\"; test_args=[\"core\"])'`\n   * Ensure tests pass.\n6. **Loop**: Re-run coverage to confirm improvement.\n\nThis setup provides a closed-loop system where the agent has all the necessary tools to autonomously improve code quality.","category":"section"},{"location":"documenter_reference.html#Private-API","page":"DocumenterReference","title":"Private API","text":"This page lists non-exported (internal) symbols of DocumenterReference.\n\n","category":"section"},{"location":"documenter_reference.html#From-DocumenterReference","page":"DocumenterReference","title":"From DocumenterReference","text":"","category":"section"},{"location":"documenter_reference.html#APIBuilder","page":"DocumenterReference","title":"APIBuilder","text":"","category":"section"},{"location":"documenter_reference.html#CONFIG","page":"DocumenterReference","title":"CONFIG","text":"","category":"section"},{"location":"documenter_reference.html#DOCTYPE_NAMES","page":"DocumenterReference","title":"DOCTYPE_NAMES","text":"","category":"section"},{"location":"documenter_reference.html#DOCTYPE_ORDER","page":"DocumenterReference","title":"DOCTYPE_ORDER","text":"","category":"section"},{"location":"documenter_reference.html#DocType","page":"DocumenterReference","title":"DocType","text":"","category":"section"},{"location":"documenter_reference.html#PAGE_CONTENT_ACCUMULATOR","page":"DocumenterReference","title":"PAGE_CONTENT_ACCUMULATOR","text":"","category":"section"},{"location":"documenter_reference.html#_Config","page":"DocumenterReference","title":"_Config","text":"","category":"section"},{"location":"documenter_reference.html#_build_api_page","page":"DocumenterReference","title":"_build_api_page","text":"","category":"section"},{"location":"documenter_reference.html#_build_page_path","page":"DocumenterReference","title":"_build_page_path","text":"","category":"section"},{"location":"documenter_reference.html#_build_page_return_structure","page":"DocumenterReference","title":"_build_page_return_structure","text":"","category":"section"},{"location":"documenter_reference.html#_build_private_page_content","page":"DocumenterReference","title":"_build_private_page_content","text":"","category":"section"},{"location":"documenter_reference.html#_build_public_page_content","page":"DocumenterReference","title":"_build_public_page_content","text":"","category":"section"},{"location":"documenter_reference.html#_classify_symbol","page":"DocumenterReference","title":"_classify_symbol","text":"","category":"section"},{"location":"documenter_reference.html#_collect_external_module_docstrings","page":"DocumenterReference","title":"_collect_external_module_docstrings","text":"","category":"section"},{"location":"documenter_reference.html#_collect_methods_from_source_files","page":"DocumenterReference","title":"_collect_methods_from_source_files","text":"","category":"section"},{"location":"documenter_reference.html#_collect_module_docstrings","page":"DocumenterReference","title":"_collect_module_docstrings","text":"","category":"section"},{"location":"documenter_reference.html#_collect_private_docstrings","page":"DocumenterReference","title":"_collect_private_docstrings","text":"","category":"section"},{"location":"documenter_reference.html#_default_basename","page":"DocumenterReference","title":"_default_basename","text":"","category":"section"},{"location":"documenter_reference.html#_default_title","page":"DocumenterReference","title":"_default_title","text":"","category":"section"},{"location":"documenter_reference.html#_exported_symbols","page":"DocumenterReference","title":"_exported_symbols","text":"","category":"section"},{"location":"documenter_reference.html#_finalize_api_pages","page":"DocumenterReference","title":"_finalize_api_pages","text":"","category":"section"},{"location":"documenter_reference.html#_format_datatype_for_docs","page":"DocumenterReference","title":"_format_datatype_for_docs","text":"","category":"section"},{"location":"documenter_reference.html#_format_type_for_docs","page":"DocumenterReference","title":"_format_type_for_docs","text":"","category":"section"},{"location":"documenter_reference.html#_format_type_param","page":"DocumenterReference","title":"_format_type_param","text":"","category":"section"},{"location":"documenter_reference.html#_get_effective_source_files","page":"DocumenterReference","title":"_get_effective_source_files","text":"","category":"section"},{"location":"documenter_reference.html#_get_source_file","page":"DocumenterReference","title":"_get_source_file","text":"","category":"section"},{"location":"documenter_reference.html#_get_source_from_docstring","page":"DocumenterReference","title":"_get_source_from_docstring","text":"","category":"section"},{"location":"documenter_reference.html#_get_source_from_methods","page":"DocumenterReference","title":"_get_source_from_methods","text":"","category":"section"},{"location":"documenter_reference.html#_has_documentation","page":"DocumenterReference","title":"_has_documentation","text":"","category":"section"},{"location":"documenter_reference.html#_iterate_over_symbols","page":"DocumenterReference","title":"_iterate_over_symbols","text":"","category":"section"},{"location":"documenter_reference.html#_method_signature_string","page":"DocumenterReference","title":"_method_signature_string","text":"","category":"section"},{"location":"documenter_reference.html#_normalize_paths","page":"DocumenterReference","title":"_normalize_paths","text":"","category":"section"},{"location":"documenter_reference.html#_parse_primary_modules","page":"DocumenterReference","title":"_parse_primary_modules","text":"","category":"section"},{"location":"documenter_reference.html#_passes_source_filter","page":"DocumenterReference","title":"_passes_source_filter","text":"","category":"section"},{"location":"documenter_reference.html#_register_config","page":"DocumenterReference","title":"_register_config","text":"","category":"section"},{"location":"documenter_reference.html#_to_string","page":"DocumenterReference","title":"_to_string","text":"","category":"section"},{"location":"documenter_reference.html#reset_config!","page":"DocumenterReference","title":"reset_config!","text":"","category":"section"},{"location":"documenter_reference.html#CTBase.automatic_reference_documentation","page":"DocumenterReference","title":"CTBase.automatic_reference_documentation","text":"","category":"section"},{"location":"documenter_reference.html#DocumenterReference.APIBuilder","page":"DocumenterReference","title":"DocumenterReference.APIBuilder","text":"APIBuilder <: Documenter.Builder.DocumentPipeline\n\nCustom Documenter pipeline stage for automatic API reference generation.\n\nThis builder is inserted into the Documenter pipeline at order 0.0 (before most other stages) to generate API reference pages from the configurations stored in CONFIG.\n\n\n\n\n\n","category":"type"},{"location":"documenter_reference.html#DocumenterReference.CONFIG","page":"DocumenterReference","title":"DocumenterReference.CONFIG","text":"CONFIG::Vector{_Config}\n\nGlobal configuration storage for API reference generation.\n\nEach call to automatic_reference_documentation appends a new _Config entry to this vector. Use reset_config! to clear it between builds.\n\n\n\n\n\n","category":"constant"},{"location":"documenter_reference.html#DocumenterReference.DOCTYPE_NAMES","page":"DocumenterReference","title":"DocumenterReference.DOCTYPE_NAMES","text":"DOCTYPE_NAMES::Dict{DocType, String}\n\nMapping from DocType enum values to their human-readable string representations.\n\n\n\n\n\n","category":"constant"},{"location":"documenter_reference.html#DocumenterReference.DOCTYPE_ORDER","page":"DocumenterReference","title":"DocumenterReference.DOCTYPE_ORDER","text":"DOCTYPE_ORDER::Dict{DocType, Int}\n\nOrdering for DocType values used when sorting symbols for display. Lower values appear first.\n\n\n\n\n\n","category":"constant"},{"location":"documenter_reference.html#DocumenterReference.DocType","page":"DocumenterReference","title":"DocumenterReference.DocType","text":"DocType\n\nEnumeration of documentation element types recognized by the API reference generator.\n\nValues\n\nDOCTYPE_ABSTRACT_TYPE: An abstract type declaration\nDOCTYPE_CONSTANT: A constant binding (including non-function, non-type values)\nDOCTYPE_FUNCTION: A function or callable\nDOCTYPE_MACRO: A macro (name starts with @)\nDOCTYPE_MODULE: A submodule\nDOCTYPE_STRUCT: A concrete struct type\n\n\n\n\n\n","category":"type"},{"location":"documenter_reference.html#DocumenterReference.PAGE_CONTENT_ACCUMULATOR","page":"DocumenterReference","title":"DocumenterReference.PAGE_CONTENT_ACCUMULATOR","text":"PAGE_CONTENT_ACCUMULATOR::Dict{String, Vector{Tuple{Module, Vector{String}, Vector{String}}}}\n\nGlobal accumulator for multi-module combined pages. Maps output filename to a list of (module, publicdocstrings, privatedocstrings) tuples.\n\n\n\n\n\n","category":"constant"},{"location":"documenter_reference.html#DocumenterReference._Config","page":"DocumenterReference","title":"DocumenterReference._Config","text":"_Config\n\nInternal configuration for API reference generation.\n\nFields\n\ncurrent_module::Module: The module being documented.\nsubdirectory::String: Output directory for generated API pages.\nmodules::Dict{Module,Vector{String}}: Mapping of modules to their source files. When a module is specified as Module => files, the files are stored here.\nsort_by::Function: Custom sort function for symbols.\nexclude::Set{Symbol}: Symbol names to exclude from documentation.\npublic::Bool: Flag to generate public API page.\nprivate::Bool: Flag to generate private API page.\ntitle::String: Title displayed at the top of the generated page.\ntitle_in_menu::String: Title displayed in the navigation menu.\nsource_files::Vector{String}: Global source file paths (fallback if no module-specific files).\nfilename::String: Base filename (without extension) for the markdown file.\ninclude_without_source::Bool: If true, include symbols whose source file cannot be determined.\nexternal_modules_to_document::Vector{Module}: Additional modules to search for docstrings.\n\n\n\n\n\n","category":"type"},{"location":"documenter_reference.html#DocumenterReference._build_api_page","page":"DocumenterReference","title":"DocumenterReference._build_api_page","text":"_build_api_page(document::Documenter.Document, config::_Config)\n\nGenerate public and/or private API reference pages for a module. Accumulates content in PAGE_CONTENT_ACCUMULATOR for later finalization.\n\n\n\n\n\n","category":"function"},{"location":"documenter_reference.html#DocumenterReference._build_page_path","page":"DocumenterReference","title":"DocumenterReference._build_page_path","text":"_build_page_path(subdirectory::String, filename::String) -> String\n\nBuild the page path by joining subdirectory and filename. Handles special cases where subdirectory is \".\" or empty.\n\n\n\n\n\n","category":"function"},{"location":"documenter_reference.html#DocumenterReference._build_page_return_structure","page":"DocumenterReference","title":"DocumenterReference._build_page_return_structure","text":"_build_page_return_structure(title_in_menu, subdirectory, filename, public, private) -> Pair\n\nBuild the return structure for automatic_reference_documentation.\n\n\n\n\n\n","category":"function"},{"location":"documenter_reference.html#DocumenterReference._build_private_page_content","page":"DocumenterReference","title":"DocumenterReference._build_private_page_content","text":"_build_private_page_content(modules_str, module_contents) -> Tuple{String, Vector{String}}\n\nBuild the overview and docstrings for a private API page.\n\n\n\n\n\n","category":"function"},{"location":"documenter_reference.html#DocumenterReference._build_public_page_content","page":"DocumenterReference","title":"DocumenterReference._build_public_page_content","text":"_build_public_page_content(modules_str, module_contents) -> Tuple{String, Vector{String}}\n\nBuild the overview and docstrings for a public API page.\n\n\n\n\n\n","category":"function"},{"location":"documenter_reference.html#DocumenterReference._classify_symbol","page":"DocumenterReference","title":"DocumenterReference._classify_symbol","text":"_classify_symbol(obj, name_str::String) -> DocType\n\nClassify a symbol by its type (function, macro, struct, constant, module, abstract type).\n\n\n\n\n\n","category":"function"},{"location":"documenter_reference.html#DocumenterReference._collect_external_module_docstrings","page":"DocumenterReference","title":"DocumenterReference._collect_external_module_docstrings","text":"_collect_external_module_docstrings(config::_Config) -> Vector{String}\n\nCollect docstrings for methods from external modules defined in source files.\n\n\n\n\n\n","category":"function"},{"location":"documenter_reference.html#DocumenterReference._collect_methods_from_source_files","page":"DocumenterReference","title":"DocumenterReference._collect_methods_from_source_files","text":"_collect_methods_from_source_files(mod::Module, source_files::Vector{String}) -> Dict{Symbol, Vector{Method}}\n\nCollect all methods from a module that are defined in the given source files.\n\n\n\n\n\n","category":"function"},{"location":"documenter_reference.html#DocumenterReference._collect_module_docstrings","page":"DocumenterReference","title":"DocumenterReference._collect_module_docstrings","text":"_collect_module_docstrings(config::_Config, symbol_list) -> Vector{String}\n\nCollect docstring blocks for symbols from the current module.\n\n\n\n\n\n","category":"function"},{"location":"documenter_reference.html#DocumenterReference._collect_private_docstrings","page":"DocumenterReference","title":"DocumenterReference._collect_private_docstrings","text":"_collect_private_docstrings(config::_Config, symbol_list) -> Vector{String}\n\nCollect docstring blocks for private symbols, including external module methods.\n\n\n\n\n\n","category":"function"},{"location":"documenter_reference.html#DocumenterReference._default_basename","page":"DocumenterReference","title":"DocumenterReference._default_basename","text":"_default_basename(filename::String, public::Bool, private::Bool) -> String\n\nCompute the default base filename for the generated markdown file.\n\n\n\n\n\n","category":"function"},{"location":"documenter_reference.html#DocumenterReference._default_title","page":"DocumenterReference","title":"DocumenterReference._default_title","text":"_default_title(public::Bool, private::Bool) -> String\n\nCompute the default title based on public/private flags.\n\n\n\n\n\n","category":"function"},{"location":"documenter_reference.html#DocumenterReference._exported_symbols","page":"DocumenterReference","title":"DocumenterReference._exported_symbols","text":"_exported_symbols(mod::Module) -> NamedTuple\n\nClassify all symbols in a module into exported and private categories. Returns a NamedTuple with exported and private fields, each containing sorted lists of (Symbol, DocType) pairs.\n\n\n\n\n\n","category":"function"},{"location":"documenter_reference.html#DocumenterReference._finalize_api_pages","page":"DocumenterReference","title":"DocumenterReference._finalize_api_pages","text":"_finalize_api_pages(document::Documenter.Document)\n\nFinalize all accumulated API pages by combining content from multiple modules.\n\n\n\n\n\n","category":"function"},{"location":"documenter_reference.html#DocumenterReference._format_datatype_for_docs","page":"DocumenterReference","title":"DocumenterReference._format_datatype_for_docs","text":"_format_datatype_for_docs(T::DataType) -> String\n\nFormat a DataType for use in @docs blocks.\n\n\n\n\n\n","category":"function"},{"location":"documenter_reference.html#DocumenterReference._format_type_for_docs","page":"DocumenterReference","title":"DocumenterReference._format_type_for_docs","text":"_format_type_for_docs(T) -> String\n\nFormat a type for use in Documenter's @docs block. Always fully qualifies types to avoid UndefVarError when Documenter evaluates in Main.\n\n\n\n\n\n","category":"function"},{"location":"documenter_reference.html#DocumenterReference._format_type_param","page":"DocumenterReference","title":"DocumenterReference._format_type_param","text":"_format_type_param(p) -> String\n\nFormat a type parameter (can be a type or a value like an integer).\n\n\n\n\n\n","category":"function"},{"location":"documenter_reference.html#DocumenterReference._get_effective_source_files","page":"DocumenterReference","title":"DocumenterReference._get_effective_source_files","text":"_get_effective_source_files(config::_Config) -> Vector{String}\n\nDetermine the effective source files for filtering symbols. Priority: module-specific files > global source_files > empty (no filtering).\n\n\n\n\n\n","category":"function"},{"location":"documenter_reference.html#DocumenterReference._get_source_file","page":"DocumenterReference","title":"DocumenterReference._get_source_file","text":"_get_source_file(mod::Module, key::Symbol, type::DocType) -> Union{String, Nothing}\n\nDetermine the source file path where a symbol is defined. Returns nothing if the source file cannot be determined.\n\n\n\n\n\n","category":"function"},{"location":"documenter_reference.html#DocumenterReference._get_source_from_docstring","page":"DocumenterReference","title":"DocumenterReference._get_source_from_docstring","text":"_get_source_from_docstring(mod::Module, key::Symbol) -> Union{String, Nothing}\n\nTry to get source file path from docstring metadata.\n\n\n\n\n\n","category":"function"},{"location":"documenter_reference.html#DocumenterReference._get_source_from_methods","page":"DocumenterReference","title":"DocumenterReference._get_source_from_methods","text":"_get_source_from_methods(obj) -> Union{String, Nothing}\n\nTry to get source file path from method definitions.\n\n\n\n\n\n","category":"function"},{"location":"documenter_reference.html#DocumenterReference._has_documentation","page":"DocumenterReference","title":"DocumenterReference._has_documentation","text":"_has_documentation(mod::Module, key::Symbol, type::DocType, modules::Dict) -> Bool\n\nCheck if a symbol has documentation. Logs a warning if not.\n\n\n\n\n\n","category":"function"},{"location":"documenter_reference.html#DocumenterReference._iterate_over_symbols","page":"DocumenterReference","title":"DocumenterReference._iterate_over_symbols","text":"_iterate_over_symbols(f, config, symbol_list)\n\nIterate over symbols, applying a function to each documented symbol. Filters symbols based on exclusion list, documentation presence, and source files.\n\n\n\n\n\n","category":"function"},{"location":"documenter_reference.html#DocumenterReference._method_signature_string","page":"DocumenterReference","title":"DocumenterReference._method_signature_string","text":"_method_signature_string(m::Method, mod::Module, key::Symbol) -> String\n\nGenerate a Documenter-compatible signature string for a method. Returns a string like Module.func(::Type1, ::Type2) for use in @docs blocks.\n\n\n\n\n\n","category":"function"},{"location":"documenter_reference.html#DocumenterReference._normalize_paths","page":"DocumenterReference","title":"DocumenterReference._normalize_paths","text":"_normalize_paths(paths) -> Vector{String}\n\nNormalize a collection of paths to absolute paths.\n\n\n\n\n\n","category":"function"},{"location":"documenter_reference.html#DocumenterReference._parse_primary_modules","page":"DocumenterReference","title":"DocumenterReference._parse_primary_modules","text":"_parse_primary_modules(primary_modules::Vector) -> Dict{Module, Vector{String}}\n\nParse the primary_modules argument into a dictionary mapping modules to their source files. Handles both plain modules and Module => files pairs.\n\n\n\n\n\n","category":"function"},{"location":"documenter_reference.html#DocumenterReference._passes_source_filter","page":"DocumenterReference","title":"DocumenterReference._passes_source_filter","text":"_passes_source_filter(mod, key, type, source_files, include_without_source) -> Bool\n\nCheck if a symbol passes the source file filter.\n\n\n\n\n\n","category":"function"},{"location":"documenter_reference.html#DocumenterReference._register_config","page":"DocumenterReference","title":"DocumenterReference._register_config","text":"_register_config(current_module, subdirectory, modules, sort_by, exclude, public, private, \n                 title, title_in_menu, source_files, filename, include_without_source, \n                 external_modules_to_document)\n\nCreate and register a _Config in the global CONFIG vector.\n\n\n\n\n\n","category":"function"},{"location":"documenter_reference.html#DocumenterReference._to_string","page":"DocumenterReference","title":"DocumenterReference._to_string","text":"_to_string(x::DocType) -> String\n\nConvert a DocType enumeration value to its string representation.\n\n\n\n\n\n","category":"function"},{"location":"documenter_reference.html#DocumenterReference.reset_config!","page":"DocumenterReference","title":"DocumenterReference.reset_config!","text":"reset_config!()\n\nClear the global CONFIG vector and PAGE_CONTENT_ACCUMULATOR. Useful between documentation builds or for testing.\n\n\n\n\n\n","category":"function"},{"location":"documenter_reference.html#CTBase.automatic_reference_documentation-Tuple{CTBase.DocumenterReferenceTag}","page":"DocumenterReference","title":"CTBase.automatic_reference_documentation","text":"automatic_reference_documentation(;\n    subdirectory::String,\n    primary_modules,\n    sort_by::Function = identity,\n    exclude::Vector{Symbol} = Symbol[],\n    public::Bool = true,\n    private::Bool = true,\n    title::String = \"API Reference\",\n    title_in_menu::String = \"\",\n    filename::String = \"\",\n    source_files::Vector{String} = String[],\n    include_without_source::Bool = false,\n    external_modules_to_document::Vector{Module} = Module[],\n)\n\nAutomatically creates the API reference documentation for one or more modules and returns a structure which can be used in the pages argument of Documenter.makedocs.\n\nArguments\n\nsubdirectory: the directory relative to the documentation root in which to write the API files.\nprimary_modules: a vector of modules or Module => source_files pairs to document. When source files are provided, only symbols defined in those files are documented.\nsort_by: a custom sort function applied to symbol lists.\nexclude: vector of symbol names to skip from the generated API.\npublic: flag to generate public API page (default: true).\nprivate: flag to generate private API page (default: true).\ntitle: title displayed at the top of the generated page.\ntitle_in_menu: title displayed in the navigation menu (default: same as title).\nfilename: base filename (without extension) for the markdown file.\nsource_files: global source file paths (fallback if no module-specific files). Deprecated: prefer using primary_modules=[Module => files] instead.\ninclude_without_source: if true, include symbols whose source file cannot be determined. Default: false.\nexternal_modules_to_document: additional modules to search for docstrings (e.g., [Plots] to include Plots.plot methods defined in your source files).\n\nMultiple instances\n\nEach time you call this function, a new object is added to the global variable DocumenterReference.CONFIG. Use reset_config!() to clear it between builds.\n\n\n\n\n\n","category":"method"},{"location":"default.html#Private-API","page":"Default","title":"Private API","text":"This page lists non-exported (internal) symbols of CTBase.\n\n","category":"section"},{"location":"default.html#From-CTBase","page":"Default","title":"From CTBase","text":"","category":"section"},{"location":"default.html#__display","page":"Default","title":"__display","text":"","category":"section"},{"location":"default.html#CTBase.__display","page":"Default","title":"CTBase.__display","text":"__display() -> Bool\n\n\nReturn the default value of the display flag.\n\nThis internal utility is used to decide whether output should be shown during execution.\n\nReturns\n\nBool: The default value true, indicating that output is displayed.\n\nExample\n\njulia> using CTBase\n\njulia> CTBase.__display()\ntrue\n\n\n\n\n\n","category":"function"},{"location":"utils.html#Private-API","page":"Utils","title":"Private API","text":"This page lists non-exported (internal) symbols of CTBase.\n\n","category":"section"},{"location":"utils.html#From-CTBase","page":"Utils","title":"From CTBase","text":"","category":"section"},{"location":"utils.html#ctindice","page":"Utils","title":"ctindice","text":"","category":"section"},{"location":"utils.html#ctindices","page":"Utils","title":"ctindices","text":"","category":"section"},{"location":"utils.html#ctupperscript","page":"Utils","title":"ctupperscript","text":"","category":"section"},{"location":"utils.html#ctupperscripts","page":"Utils","title":"ctupperscripts","text":"","category":"section"},{"location":"utils.html#CTBase.ctindice","page":"Utils","title":"CTBase.ctindice","text":"ctindice(i::Int64) -> Char\n\n\nReturn the integer i ∈ [0, 9] as a Unicode subscript character.\n\nThrows an IncorrectArgument exception if i is outside this range.\n\nThe Unicode subscript digits start at codepoint U+2080 for '0' and continue sequentially.\n\nExample\n\njulia> using CTBase\n\njulia> CTBase.ctindice(3)\n'₃': Unicode U+2083 (category No: Number, other)\n\n\n\n\n\n","category":"function"},{"location":"utils.html#CTBase.ctindices","page":"Utils","title":"CTBase.ctindices","text":"ctindices(i::Int64) -> String\n\n\nReturn the integer i ≥ 0 as a string of Unicode subscript characters.\n\nThrows an IncorrectArgument if i is negative.\n\nExample\n\njulia> using CTBase\n\njulia> CTBase.ctindices(123)\n\"₁₂₃\"\n\n\n\n\n\n","category":"function"},{"location":"utils.html#CTBase.ctupperscript","page":"Utils","title":"CTBase.ctupperscript","text":"ctupperscript(i::Int64) -> Char\n\n\nReturn the integer i ∈ [0, 9] as a Unicode superscript (upper) character.\n\nThrows an IncorrectArgument exception if i is outside this range.\n\nNote: Unicode superscripts ¹ (U+00B9), ² (U+00B2), and ³ (U+00B3) are special cases. The other digits ⁰ (U+2070) and ⁴ to ⁹ (U+2074 to U+2079) are mostly contiguous.\n\nExample\n\njulia> using CTBase\n\njulia> CTBase.ctupperscript(2)\n'²': Unicode U+00B2 (category No: Number, other)\n\n\n\n\n\n","category":"function"},{"location":"utils.html#CTBase.ctupperscripts","page":"Utils","title":"CTBase.ctupperscripts","text":"ctupperscripts(i::Int64) -> String\n\n\nReturn the integer i ≥ 0 as a string of Unicode superscript characters.\n\nThrows an IncorrectArgument exception if i is negative.\n\nExample\n\njulia> using CTBase\n\njulia> CTBase.ctupperscripts(123)\n\"¹²³\"\n\n\n\n\n\n","category":"function"},{"location":"description.html#Private-API","page":"Description","title":"Private API","text":"This page lists non-exported (internal) symbols of CTBase.\n\n","category":"section"},{"location":"description.html#From-CTBase","page":"Description","title":"From CTBase","text":"","category":"section"},{"location":"description.html#DescVarArg","page":"Description","title":"DescVarArg","text":"","category":"section"},{"location":"description.html#Description","page":"Description","title":"Description","text":"","category":"section"},{"location":"description.html#add","page":"Description","title":"add","text":"","category":"section"},{"location":"description.html#complete","page":"Description","title":"complete","text":"","category":"section"},{"location":"description.html#remove","page":"Description","title":"remove","text":"","category":"section"},{"location":"description.html#CTBase.DescVarArg","page":"Description","title":"CTBase.DescVarArg","text":"DescVarArg is a type alias representing a variable number of Symbols.\n\njulia> using CTBase\n\njulia> CTBase.DescVarArg\nVararg{Symbol}\n\nSee also: CTBase.Description.\n\n\n\n\n\n","category":"constant"},{"location":"description.html#CTBase.Description","page":"Description","title":"CTBase.Description","text":"A description is a tuple of symbols. Description is a type alias for a tuple of symbols.\n\nSee also: DescVarArg.\n\nExample\n\nBase.show is overloaded for descriptions, so tuples of descriptions are printed one per line:\n\njulia> using CTBase\n\njulia> display(((:a, :b), (:b, :c)))\n(:a, :b)\n(:b, :c)\n\n\n\n\n\n","category":"type"},{"location":"description.html#CTBase.add","page":"Description","title":"CTBase.add","text":"add(\n    _::Tuple{},\n    y::Tuple{Vararg{Symbol}}\n) -> Tuple{Tuple{Vararg{Symbol}}}\n\n\nReturn a tuple containing only the description y.\n\nExample\n\njulia> using CTBase\n\njulia> descriptions = ()\njulia> descriptions = CTBase.add(descriptions, (:a,))\n(:a,)\njulia> print(descriptions)\n((:a,),)\njulia> descriptions[1]\n(:a,)\n\n\n\n\n\nadd(\n    x::Tuple{Vararg{Tuple{Vararg{Symbol}}}},\n    y::Tuple{Vararg{Symbol}}\n) -> Tuple{Tuple{Vararg{Symbol}}}\n\n\nAdd the description y to the tuple of descriptions x if x does not contain y and return the new tuple of descriptions. \n\nThrow an exception (IncorrectArgument) if the description y is already contained in x.\n\nExample\n\njulia> using CTBase\n\njulia> descriptions = ()\njulia> descriptions = CTBase.add(descriptions, (:a,))\n(:a,)\njulia> descriptions = CTBase.add(descriptions, (:b,))\n(:a,)\n(:b,)\njulia> descriptions = CTBase.add(descriptions, (:b,))\nERROR: IncorrectArgument: the description (:b,) is already in ((:a,), (:b,))\n\n\n\n\n\n","category":"function"},{"location":"description.html#CTBase.complete","page":"Description","title":"CTBase.complete","text":"complete(list::Symbol...; descriptions)\n\n\nReturn one description from a list of Symbols list and a set of descriptions D.  If multiple descriptions are possible, then the first one is selected.\n\nIf the list is not contained in any of the descriptions, then an exception is thrown.\n\nExample\n\njulia> using CTBase\n\njulia> D = ((:a, :b), (:a, :b, :c), (:b, :c), (:a, :c))\n(:a, :b)\n(:b, :c)\n(:a, :c)\njulia> CTBase.complete(:a; descriptions=D)\n(:a, :b)\njulia> CTBase.complete(:a, :c; descriptions=D)\n(:a, :b, :c)\njulia> CTBase.complete((:a, :c); descriptions=D)\n(:a, :b, :c)\njulia> CTBase.complete(:f; descriptions=D)\nERROR: AmbiguousDescription: the description (:f,) is ambiguous / incorrect\n\n\n\n\n\ncomplete(list::Tuple{Vararg{Symbol}}; descriptions)\n\n\nConvenience overload of complete for tuple inputs.\n\nThis method is equivalent to complete(list...; descriptions=descriptions).\n\nArguments\n\nlist::Tuple{Vararg{Symbol}}: A tuple of symbols representing a partial description.\n\nKeyword Arguments\n\ndescriptions::Tuple{Vararg{Description}}: Candidate descriptions used for completion.\n\nReturns\n\nDescription: A description from descriptions that contains all symbols in list.\n\nThrows\n\nAmbiguousDescription: If descriptions is empty, or if list is not contained in any candidate description.\n\n\n\n\n\n","category":"function"},{"location":"description.html#CTBase.remove","page":"Description","title":"CTBase.remove","text":"remove(\n    x::Tuple{Vararg{Symbol}},\n    y::Tuple{Vararg{Symbol}}\n) -> Tuple{Vararg{Symbol}}\n\n\nReturn the difference between the description x and the description y.\n\nExample\n\njulia> using CTBase\n\njulia> CTBase.remove((:a, :b), (:a,))\n(:b,)\n\n\n\n\n\n","category":"function"},{"location":"coverage_postprocessing.html#Private-API","page":"CoveragePostprocessing","title":"Private API","text":"This page lists non-exported (internal) symbols of CoveragePostprocessing.\n\n","category":"section"},{"location":"coverage_postprocessing.html#From-CoveragePostprocessing","page":"CoveragePostprocessing","title":"From CoveragePostprocessing","text":"","category":"section"},{"location":"coverage_postprocessing.html#_clean_stale_cov_files!","page":"CoveragePostprocessing","title":"_clean_stale_cov_files!","text":"","category":"section"},{"location":"coverage_postprocessing.html#_collect_and_move_cov_files!","page":"CoveragePostprocessing","title":"_collect_and_move_cov_files!","text":"","category":"section"},{"location":"coverage_postprocessing.html#_count_cov_files","page":"CoveragePostprocessing","title":"_count_cov_files","text":"","category":"section"},{"location":"coverage_postprocessing.html#_generate_coverage_reports!","page":"CoveragePostprocessing","title":"_generate_coverage_reports!","text":"","category":"section"},{"location":"coverage_postprocessing.html#_reset_coverage_dir","page":"CoveragePostprocessing","title":"_reset_coverage_dir","text":"","category":"section"},{"location":"coverage_postprocessing.html#CTBase.postprocess_coverage","page":"CoveragePostprocessing","title":"CTBase.postprocess_coverage","text":"","category":"section"},{"location":"coverage_postprocessing.html#CoveragePostprocessing._clean_stale_cov_files!","page":"CoveragePostprocessing","title":"CoveragePostprocessing._clean_stale_cov_files!","text":"_clean_stale_cov_files!(source_dirs)\n\nInternal helper that removes stale .cov files from source_dirs.\n\nIf multiple runs are detected (PID suffix in filenames), this function keeps the PID with the largest number of .cov files and removes the others.\n\n\n\n\n\n","category":"function"},{"location":"coverage_postprocessing.html#CoveragePostprocessing._collect_and_move_cov_files!","page":"CoveragePostprocessing","title":"CoveragePostprocessing._collect_and_move_cov_files!","text":"_collect_and_move_cov_files!(source_dirs, dest_dir) -> Vector{String}\n\nInternal helper that moves all .cov files from source_dirs into dest_dir.\n\nReturns a vector of destination paths for the moved files.\n\n\n\n\n\n","category":"function"},{"location":"coverage_postprocessing.html#CoveragePostprocessing._count_cov_files","page":"CoveragePostprocessing","title":"CoveragePostprocessing._count_cov_files","text":"_count_cov_files(source_dirs) -> Int\n\nInternal helper that counts the number of .cov files in the provided directories.\n\n\n\n\n\n","category":"function"},{"location":"coverage_postprocessing.html#CoveragePostprocessing._generate_coverage_reports!","page":"CoveragePostprocessing","title":"CoveragePostprocessing._generate_coverage_reports!","text":"_generate_coverage_reports!(source_dirs, coverage_dir, root_dir)\n\nInternal helper that generates coverage reports from .cov files.\n\nWrites:\n\ncoverage/lcov.info\ncoverage/cov_report.md\n\n\n\n\n\n","category":"function"},{"location":"coverage_postprocessing.html#CoveragePostprocessing._reset_coverage_dir","page":"CoveragePostprocessing","title":"CoveragePostprocessing._reset_coverage_dir","text":"_reset_coverage_dir(coverage_dir, cov_storage_dir)\n\nInternal helper that recreates the coverage/ directory structure.\n\nThis function removes coverage_dir (recursively) if it already exists, then creates cov_storage_dir.\n\n\n\n\n\n","category":"function"},{"location":"coverage_postprocessing.html#CTBase.postprocess_coverage-Tuple{CTBase.CoveragePostprocessingTag}","page":"CoveragePostprocessing","title":"CTBase.postprocess_coverage","text":"CTBase.postprocess_coverage(::CTBase.CoveragePostprocessingTag; generate_report::Bool=true, root_dir::String=pwd())\n\nPost-process coverage artifacts produced by Pkg.test(; coverage=true).\n\nThis implementation:\n\nCollects coverage source directories under root_dir (src/, test/, ext/ when present)\nResets the coverage/ directory\nRemoves stale .cov files (keeping the most complete PID suffix when multiple runs exist)\nOptionally generates reports (LCOV + markdown report)\nMoves .cov files into coverage/cov/ (recursively from source dirs)\n\nKeyword Arguments\n\ngenerate_report::Bool=true: If true, write coverage/lcov.info and coverage/cov_report.md.\nroot_dir::String=pwd(): Root directory of the project.\n\nReturns\n\nNothing\n\nNotes\n\nThis function creates/removes/moves files and directories under root_dir.\n\nUsage sketch (non-executed)\n\nusing CTBase\n\n# CTBase.postprocess_coverage(; generate_report=true, root_dir=pwd())\n\n\n\n\n\n","category":"method"},{"location":"exception.html#Private-API","page":"Exception","title":"Private API","text":"This page lists non-exported (internal) symbols of CTBase.\n\n","category":"section"},{"location":"exception.html#From-CTBase","page":"Exception","title":"From CTBase","text":"","category":"section"},{"location":"exception.html#AmbiguousDescription","page":"Exception","title":"AmbiguousDescription","text":"","category":"section"},{"location":"exception.html#CTException","page":"Exception","title":"CTException","text":"","category":"section"},{"location":"exception.html#ExtensionError","page":"Exception","title":"ExtensionError","text":"","category":"section"},{"location":"exception.html#IncorrectArgument","page":"Exception","title":"IncorrectArgument","text":"","category":"section"},{"location":"exception.html#NotImplemented","page":"Exception","title":"NotImplemented","text":"","category":"section"},{"location":"exception.html#ParsingError","page":"Exception","title":"ParsingError","text":"","category":"section"},{"location":"exception.html#UnauthorizedCall","page":"Exception","title":"UnauthorizedCall","text":"","category":"section"},{"location":"exception.html#Base.showerror","page":"Exception","title":"Base.showerror","text":"","category":"section"},{"location":"exception.html#Base.showerror-2","page":"Exception","title":"Base.showerror","text":"","category":"section"},{"location":"exception.html#Base.showerror-3","page":"Exception","title":"Base.showerror","text":"","category":"section"},{"location":"exception.html#Base.showerror-4","page":"Exception","title":"Base.showerror","text":"","category":"section"},{"location":"exception.html#Base.showerror-5","page":"Exception","title":"Base.showerror","text":"","category":"section"},{"location":"exception.html#Base.showerror-6","page":"Exception","title":"Base.showerror","text":"","category":"section"},{"location":"exception.html#CTBase.AmbiguousDescription","page":"Exception","title":"CTBase.AmbiguousDescription","text":"struct AmbiguousDescription <: CTBase.CTException\n\nException thrown when a description (a tuple of Symbols) cannot be matched to any known valid descriptions.\n\nThis exception is raised by CTBase.complete() when the user provides an incomplete or inconsistent description that doesn't match any of the available descriptions in the catalogue. Use this exception when the high-level choice of description itself is wrong or ambiguous and there is no sensible default.\n\nFields\n\nvar::Tuple{Vararg{Symbol}}: The ambiguous or incorrect description tuple that caused the error.\n\nExample\n\njulia> using CTBase\n\njulia> D = ((:a, :b), (:a, :b, :c), (:b, :c))\njulia> CTBase.complete(:f; descriptions=D)\nERROR: AmbiguousDescription: the description (:f,) is ambiguous / incorrect\n\nIn this example, the symbol :f does not appear in any of the known descriptions, so complete() cannot determine which description to return.\n\nSee Also\n\ncomplete: Matches a partial description to a complete one\nadd: Adds descriptions to a catalogue (throws IncorrectArgument for duplicates)\n\n\n\n\n\n","category":"type"},{"location":"exception.html#CTBase.CTException","page":"Exception","title":"CTBase.CTException","text":"abstract type CTException <: Exception\n\nAbstract supertype for all custom exceptions in this module.\n\nUse this as the common ancestor for all domain-specific errors to allow catching all exceptions of this family via catch e::CTException.\n\nNo fields.\n\nExample\n\njulia> using CTBase\n\njulia> try\n           throw(CTBase.IncorrectArgument(\"invalid input\"))\n       catch e::CTBase.CTException\n           println(\"Caught a domain-specific exception: \", e)\n       end\nCaught a domain-specific exception: IncorrectArgument: invalid input\n\n\n\n\n\n","category":"type"},{"location":"exception.html#CTBase.ExtensionError","page":"Exception","title":"CTBase.ExtensionError","text":"struct ExtensionError <: CTBase.CTException\n\nException thrown when an extension or optional dependency is not loaded but a function requiring it is called.\n\nThis exception is used to signal that a feature requires one or more optional dependencies (weak dependencies) to be loaded. When a user tries to use a feature without loading the required extensions, this exception provides a helpful message indicating exactly which packages need to be loaded.\n\nIt is also used internally by ExtensionError() when called without any weak dependencies, in which case it throws UnauthorizedCall instead.\n\nFields\n\nweakdeps::Tuple{Vararg{Symbol}}: The tuple of symbols representing the missing dependencies.\nvar::String: An optional message to display after the \"Please make: ...\" instruction.\n\nConstructor\n\nExtensionError(weakdeps::Symbol...; message::String=\"\")\n\nThrows UnauthorizedCall if no weak dependencies are provided:\n\nCTBase.ExtensionError()  # Throws UnauthorizedCall\n\nExamples\n\njulia> using CTBase\n\njulia> throw(CTBase.ExtensionError(:MyExtension))\nERROR: ExtensionError. Please make: julia> using MyExtension\n\nWith multiple dependencies and a custom message:\n\njulia> throw(CTBase.ExtensionError(:MyExtension, :AnotherDep; message=\"to use this feature\"))\nERROR: ExtensionError. Please make: julia> using MyExtension, AnotherDep to use this feature\n\nSee Also\n\nUnauthorizedCall: Thrown when ExtensionError() is called without arguments\n\n\n\n\n\n","category":"type"},{"location":"exception.html#CTBase.IncorrectArgument","page":"Exception","title":"CTBase.IncorrectArgument","text":"struct IncorrectArgument <: CTBase.CTException\n\nException thrown when an individual argument is invalid or violates a precondition.\n\nThis exception is raised when one input value is outside the allowed domain, such as:\n\nWrong range or bounds (e.g., negative when positive is required)\nDuplicate values when uniqueness is required\nEmpty collections when non-empty is required\nType mismatches or invalid combinations\n\nUse this exception to signal that the problem is with the input data itself, not with the state of the system or the calling context. This is distinct from UnauthorizedCall, which indicates a state-related issue.\n\nFields\n\nvar::String: A descriptive message explaining the nature of the incorrect argument.\n\nExamples\n\njulia> using CTBase\n\njulia> throw(CTBase.IncorrectArgument(\"the argument must be a non-empty tuple\"))\nERROR: IncorrectArgument: the argument must be a non-empty tuple\n\nAdding a duplicate description to a catalogue:\n\njulia> algorithms = CTBase.add((), (:a, :b))\njulia> CTBase.add(algorithms, (:a, :b))\nERROR: IncorrectArgument: the description (:a, :b) is already in ((:a, :b),)\n\nInvalid indices for Unicode helpers:\n\njulia> CTBase.ctindice(-1)\nERROR: IncorrectArgument: the subscript must be between 0 and 9\n\nSee Also\n\nUnauthorizedCall: For state-related or context-related errors\nAmbiguousDescription: For high-level description matching errors\n\n\n\n\n\n","category":"type"},{"location":"exception.html#CTBase.NotImplemented","page":"Exception","title":"CTBase.NotImplemented","text":"struct NotImplemented <: CTBase.CTException\n\nException thrown to mark interface points that must be implemented by concrete subtypes.\n\nThis exception is used to define abstract interfaces where a default method on an abstract type throws NotImplemented, and each concrete implementation must override it. This makes it easy to detect missing implementations during testing and development.\n\nUse NotImplemented when defining interfaces and you want an explicit, typed error rather than a generic error(\"TODO\").\n\nFields\n\nvar::String: A message indicating what functionality is not yet implemented.\n\nExample\n\njulia> using CTBase\n\njulia> throw(CTBase.NotImplemented(\"feature X is not implemented\"))\nERROR: NotImplemented: feature X is not implemented\n\nA typical pattern for defining an interface:\n\nabstract type MyAbstractAlgorithm end\n\nfunction run!(algo::MyAbstractAlgorithm, state)\n    throw(CTBase.NotImplemented(\"run! is not implemented for $(typeof(algo))\"))\nend\n\nConcrete algorithms then provide their own run! method instead of raising this exception.\n\nSee Also\n\nUnauthorizedCall: For state-related errors\nIncorrectArgument: For input validation errors\n\n\n\n\n\n","category":"type"},{"location":"exception.html#CTBase.ParsingError","page":"Exception","title":"CTBase.ParsingError","text":"struct ParsingError <: CTBase.CTException\n\nException thrown during parsing when a syntax error or invalid structure is detected.\n\nThis exception is intended for errors detected during parsing of input structures or domain-specific languages (DSLs). Use this when processing user input that follows a specific grammar or format, and the input violates the expected syntax.\n\nFields\n\nvar::String: A message describing the parsing error.\n\nExample\n\njulia> using CTBase\n\njulia> throw(CTBase.ParsingError(\"unexpected token 'end'\"))\nERROR: ParsingError: unexpected token 'end'\n\nSee Also\n\nIncorrectArgument: For general input validation errors\nAmbiguousDescription: For description matching errors\n\n\n\n\n\n","category":"type"},{"location":"exception.html#CTBase.UnauthorizedCall","page":"Exception","title":"CTBase.UnauthorizedCall","text":"struct UnauthorizedCall <: CTBase.CTException\n\nException thrown when a function call is not allowed in the current state of the object or system.\n\nThis exception signals that the arguments may be valid, but the call is forbidden because of when or how it is made. This is distinct from IncorrectArgument, which indicates a problem with the input values themselves.\n\nCommon use cases:\n\nA method that is meant to be called only once\nState already closed or finalized\nMissing permissions or access rights\nIllegal order of operations\nWrong phase of a computation\n\nFields\n\nvar::String: A message explaining why the call is unauthorized.\n\nExamples\n\njulia> using CTBase\n\njulia> throw(CTBase.UnauthorizedCall(\"user does not have permission\"))\nERROR: UnauthorizedCall: user does not have permission\n\nA typical pattern for state-dependent operations:\n\nfunction finalize!(s::SomeState)\n    if s.is_finalized\n        throw(CTBase.UnauthorizedCall(\"finalize! was already called for this state\"))\n    end\n    # ... perform finalisation and mark state as finalised ...\nend\n\nSee Also\n\nIncorrectArgument: For input validation errors\nNotImplemented: For unimplemented interface methods\n\n\n\n\n\n","category":"type"},{"location":"exception.html#Base.showerror-Tuple{IO, CTBase.AmbiguousDescription}","page":"Exception","title":"Base.showerror","text":"showerror(io::IO, e::CTBase.AmbiguousDescription)\n\n\nCustomizes the printed message of the exception.\n\nExample\n\njulia> using CTBase\n\njulia> throw(CTBase.AmbiguousDescription((:x, :y)))\nERROR: AmbiguousDescription: the description (:x, :y) is ambiguous / incorrect\n\n\n\n\n\n","category":"method"},{"location":"exception.html#Base.showerror-Tuple{IO, CTBase.ParsingError}","page":"Exception","title":"Base.showerror","text":"showerror(io::IO, e::CTBase.ParsingError)\n\n\nCustomizes the printed message of the exception.\n\n\n\n\n\n","category":"method"},{"location":"exception.html#Base.showerror-Tuple{IO, CTBase.IncorrectArgument}","page":"Exception","title":"Base.showerror","text":"showerror(io::IO, e::CTBase.IncorrectArgument)\n\n\nCustomizes the printed message of the exception.\n\n\n\n\n\n","category":"method"},{"location":"exception.html#Base.showerror-Tuple{IO, CTBase.UnauthorizedCall}","page":"Exception","title":"Base.showerror","text":"showerror(io::IO, e::CTBase.UnauthorizedCall)\n\n\nCustomizes the printed message of the exception.\n\n\n\n\n\n","category":"method"},{"location":"exception.html#Base.showerror-Tuple{IO, CTBase.NotImplemented}","page":"Exception","title":"Base.showerror","text":"showerror(io::IO, e::CTBase.NotImplemented)\n\n\nCustomizes the printed message of the exception.\n\n\n\n\n\n","category":"method"},{"location":"exception.html#Base.showerror-Tuple{IO, CTBase.ExtensionError}","page":"Exception","title":"Base.showerror","text":"showerror(io::IO, e::CTBase.ExtensionError)\n\n\nCustomizes the printed message of the exception, prompting the user to load the required extensions.\n\nExample\n\njulia> using CTBase\n\njulia> e = CTBase.ExtensionError(:MyExtension, :AnotherDep)\njulia> showerror(stdout, e)\nERROR: ExtensionError. Please make: julia> using MyExtension, AnotherDep\n\n\n\n\n\n","category":"method"},{"location":"test_runner.html#Private-API","page":"TestRunner","title":"Private API","text":"This page lists non-exported (internal) symbols of TestRunner.\n\n","category":"section"},{"location":"test_runner.html#From-TestRunner","page":"TestRunner","title":"From TestRunner","text":"","category":"section"},{"location":"test_runner.html#_glob_to_regex","page":"TestRunner","title":"_glob_to_regex","text":"","category":"section"},{"location":"test_runner.html#_parse_test_args","page":"TestRunner","title":"_parse_test_args","text":"","category":"section"},{"location":"test_runner.html#_run_single_test","page":"TestRunner","title":"_run_single_test","text":"","category":"section"},{"location":"test_runner.html#_select_tests","page":"TestRunner","title":"_select_tests","text":"","category":"section"},{"location":"test_runner.html#CTBase.run_tests","page":"TestRunner","title":"CTBase.run_tests","text":"","category":"section"},{"location":"test_runner.html#TestRunner._glob_to_regex","page":"TestRunner","title":"TestRunner._glob_to_regex","text":"_glob_to_regex(pattern::AbstractString) -> Regex\n\nConvert a glob pattern (using * and ?) into a regular expression.\n\nThe returned regex is anchored (matches the full string).\n\n\n\n\n\n","category":"function"},{"location":"test_runner.html#TestRunner._parse_test_args","page":"TestRunner","title":"TestRunner._parse_test_args","text":"_parse_test_args(args::Vector{String}) -> Tuple{Vector{Symbol}, Bool, Bool}\n\nParse command-line test arguments, filtering out coverage-related flags.\n\nReturns (selections, run_all, dry_run) where:\n\nselections: selection patterns provided by the user (as symbols)\nrun_all: whether -a / --all was present\ndry_run: whether -n / --dryrun was present\n\n\n\n\n\n","category":"function"},{"location":"test_runner.html#TestRunner._run_single_test","page":"TestRunner","title":"TestRunner._run_single_test","text":"_run_single_test(name::Symbol; kwargs...)\n\nRun a single selected test.\n\nThis helper:\n\nResolves a test filename via filename_builder\nIncludes the file into Main\nOptionally evaluates a function (via funcname_builder) when eval_mode=true\n\nThis function is not part of the public API.\n\n\n\n\n\n","category":"function"},{"location":"test_runner.html#TestRunner._select_tests","page":"TestRunner","title":"TestRunner._select_tests","text":"Determine which tests to run based on selections, available_tests filter, and file globbing.\n\nIdentify potential test files in test_dir (default: test/).\nFilter by available_tests if provided.\nFilter by selections (interpreted as globs) if present.\n\nNotes\n\nIf available_tests is empty, this function falls back to an auto-discovery heuristic using the filename stem as the candidate test name.\n\n\n\n\n\n","category":"function"},{"location":"test_runner.html#CTBase.run_tests-Tuple{CTBase.TestRunnerTag}","page":"TestRunner","title":"CTBase.run_tests","text":"run_tests(::CTBase.TestRunnerTag; kwargs...)\n\nRun tests with configurable file/function name builders and optional available tests filter.\n\nKeyword Arguments\n\ntestset_name::String = \"Tests\" — name of the main testset\navailable_tests::Vector{Symbol} = Symbol[] — if non-empty, only these tests are allowed\nfilename_builder::Function = identity — Symbol → Symbol, builds the filename from the test name\nfuncname_builder::Function = identity — Symbol → Symbol|Nothing, builds the function name (or nothing to skip eval)\neval_mode::Bool = true — whether to eval the function after include\nverbose::Bool = true — verbose testset output\nshowtiming::Bool = true — show timing in testset output\n\nNotes\n\nTest selection is driven by Main.ARGS (coverage flags are ignored).\nSelection arguments are interpreted as glob patterns and matched against both the test name and the corresponding filename.\n\nUsage sketch (non-executed)\n\nusing CTBase\n\n# CTBase.run_tests(; testset_name=\"Tests\")\n\n\n\n\n\n","category":"method"},{"location":"index.html#CTBase.jl","page":"Introduction","title":"CTBase.jl","text":"The CTBase.jl package is part of the control-toolbox ecosystem.\n\nnote: Note\nThe root package is OptimalControl.jl which aims to provide tools to model and solve optimal control problems with ordinary differential equations by direct and indirect methods, both on CPU and GPU.\n\ndetails: Note on Private Methods\nIn some examples in the documentation, private methods are shown without the module prefix. This is done for the sake of clarity and readability.julia> using CTBase\njulia> x = 1\njulia> private_fun(x) # throws an errorThis should instead be written as:julia> using CTBase\njulia> x = 1\njulia> CTBase.private_fun(x)If the method is re-exported by another package, module OptimalControl\n    import CTBase: private_fun\n    export private_fun\nendthen there is no need to prefix it with the original module name:julia> using OptimalControl\njulia> x = 1\njulia> private_fun(x)","category":"section"},{"location":"index.html#Descriptions:-encoding-algorithms","page":"Introduction","title":"Descriptions: encoding algorithms","text":"One of the central ideas in CTBase is the notion of a description. A description is simply a tuple of Symbols that encodes an algorithm or configuration in a declarative way.\n\nFormally, CTBase defines:\n\nconst DescVarArg = Vararg{Symbol}\nconst Description = Tuple{DescVarArg}\n\nFor example, the tuple\n\njulia> using CTBase\n\njulia> d = (:descent, :bfgs, :bisection)\n(:descent, :bfgs, :bisection)\n\njulia> typeof(d) <: CTBase.Description\ntrue\n\ncan be read as “a descent algorithm, with BFGS directions and a bisection line search”. Higher-level packages in the control-toolbox ecosystem use descriptions to catalogue algorithms in a uniform way.","category":"section"},{"location":"index.html#Building-a-library-of-descriptions","page":"Introduction","title":"Building a library of descriptions","text":"CTBase provides a few small functions to manage collections of descriptions:\n\nCTBase.add(x, y) adds the description y to the tuple of descriptions x, rejecting duplicates with an IncorrectArgument exception.\nCTBase.complete(list; descriptions=D) picks a complete description from a set D based on a partial list of symbols.\nCTBase.remove(x, y) returns the set difference of two descriptions.\n\nHere is a complete example of a small “algorithm library”:\n\njulia> algorithms = ()\n()\n\njulia> algorithms = CTBase.add(algorithms, (:descent, :bfgs, :bisection))\n((:descent, :bfgs, :bisection),)\n\njulia> algorithms = CTBase.add(algorithms, (:descent, :gradient, :fixedstep))\n((:descent, :bfgs, :bisection), (:descent, :gradient, :fixedstep))\n\njulia> display(algorithms)\n(:descent, :bfgs, :bisection)\n(:descent, :gradient, :fixedstep)\n\nGiven this library, we can complete a partial description:\n\njulia> CTBase.complete((:descent,); descriptions=algorithms)\n(:descent, :bfgs, :bisection)\n\njulia> CTBase.complete((:gradient, :fixedstep); descriptions=algorithms)\n(:descent, :gradient, :fixedstep)\n\nInternally, CTBase.complete scans the descriptions tuple from top to bottom. For each candidate description it computes:\n\nhow many symbols it shares with the partial list, and\nwhether the partial list is a subset of the full description.\n\nIf no description contains all the symbols from the partial list, AmbiguousDescription is thrown. Otherwise, among the descriptions that do contain the partial list, CTBase selects the one with the largest intersection; if several have the same score, the first one in the descriptions tuple wins. In other words, the order of descriptions encodes a priority from top to bottom.\n\nWith this mechanism in place, we can then analyse the remainder of a description by removing a prefix:\n\njulia> full = CTBase.complete((:descent,); descriptions=algorithms)\n(:descent, :bfgs, :bisection)\n\njulia> CTBase.remove(full, (:descent, :bfgs))\n(:bisection,)\n\nThis “description language” lets higher-level packages refer to algorithms in a structured, composable way, while CTBase takes care of the low-level operations (adding, completing, and comparing descriptions).","category":"section"},{"location":"index.html#Error-handling-and-CTBase-exceptions","page":"Introduction","title":"Error handling and CTBase exceptions","text":"CTBase defines a small hierarchy of domain-specific exceptions to make error handling explicit and consistent across the control-toolbox ecosystem.\n\nAll custom exceptions inherit from CTBase.CTException:\n\nabstract type CTBase.CTException <: Exception end\n\nYou should generally catch exceptions like this:\n\ntry\n    # call into CTBase or a package built on top of it\ncatch e\n    if e isa CTBase.CTException\n        # handle CTBase domain errors in a uniform way\n        @warn \"CTBase error\" exception=(e, catch_backtrace())\n    else\n        # non-CTBase error: rethrow so it is not hidden\n        rethrow()\n    end\nend\n\nThis pattern avoids accidentally swallowing unrelated internal errors while still giving you a single place to handle all CTBase-specific problems.","category":"section"},{"location":"index.html#ambiguous-description-index","page":"Introduction","title":"AmbiguousDescription","text":"CTBase.AmbiguousDescription <: CTBase.CTException\n\nThrown when a description (a tuple of Symbols) cannot be matched to any known valid description. This typically happens in CTBase.complete when the user provides an incomplete or inconsistent description.\n\njulia> using CTBase\n\njulia> D = ((:a, :b), (:a, :b, :c), (:b, :c))\njulia> CTBase.complete(:f; descriptions=D)\nERROR: AmbiguousDescription: the description (:f,) is ambiguous / incorrect\n\nUse this exception when the high-level choice of description itself is wrong or ambiguous and there is no sensible default.","category":"section"},{"location":"index.html#incorrect-argument-index","page":"Introduction","title":"IncorrectArgument","text":"CTBase.IncorrectArgument <: CTBase.CTException\n\nThrown when an individual argument is invalid or violates a precondition.\n\nExamples from CTBase:\n\nAdding a duplicate description:\njulia> algorithms = CTBase.add((), (:a, :b))\njulia> CTBase.add(algorithms, (:a, :b))\nERROR: IncorrectArgument: the description (:a, :b) is already in ((:a, :b),)\nUsing invalid indices for the Unicode helpers:\njulia> CTBase.ctindice(-1)\nERROR: IncorrectArgument: the subscript must be between 0 and 9\n\nUse this exception whenever one input value is outside the allowed domain (wrong range, duplicate, empty when it must not be, etc.).","category":"section"},{"location":"index.html#not-implemented-index","page":"Introduction","title":"NotImplemented","text":"CTBase.NotImplemented <: CTBase.CTException\n\nUsed to mark interface points that must be implemented by concrete subtypes. The typical pattern is to provide a method on an abstract type that throws NotImplemented, and then override it in each concrete implementation:\n\nabstract type MyAbstractAlgorithm end\n\nfunction run!(algo::MyAbstractAlgorithm, state)\n    throw(CTBase.NotImplemented(\"run! is not implemented for $(typeof(algo))\"))\nend\n\nConcrete algorithms then provide their own run! method instead of raising this exception. This makes it easy to detect missing implementations during testing.\n\nUse NotImplemented when defining interfaces and you want an explicit, typed error rather than a generic error(\"TODO\").","category":"section"},{"location":"index.html#unauthorized-call-index","page":"Introduction","title":"UnauthorizedCall","text":"CTBase.UnauthorizedCall <: CTBase.CTException\n\nSignals that a function call is not allowed in the current state of the object or system. This is different from IncorrectArgument: here the arguments may be valid, but the call is forbidden because of when or how it is made.\n\nA common pattern is a method that is meant to be called only once:\n\nfunction finalize!(s::SomeState)\n    if s.is_finalized\n        throw(CTBase.UnauthorizedCall(\"finalize! was already called for this state\"))\n    end\n    # ... perform finalisation and mark state as finalised ...\nend\n\nUse UnauthorizedCall when the calling context is invalid (wrong phase of a computation, method already called, state already closed, missing permissions, illegal order of calls, etc.).\n\nIt is also used internally by ExtensionError when it is called without any weak dependencies:\n\njulia> using CTBase\n\njulia> CTBase.ExtensionError()\nERROR: UnauthorizedCall: Please provide at least one weak dependence for the extension.","category":"section"},{"location":"index.html#parsing-error-index","page":"Introduction","title":"ParsingError","text":"CTBase.ParsingError <: CTBase.CTException\n\nIntended for errors detected during parsing of input structures or DSLs (domain-specific languages).\n\njulia> using CTBase\n\njulia> throw(CTBase.ParsingError(\"unexpected token 'end'\"))\nERROR: ParsingError: unexpected token 'end'","category":"section"},{"location":"index.html#Optional-extensions","page":"Introduction","title":"Optional extensions","text":"CTBase uses Julia's package extensions mechanism (via [weakdeps] + [extensions] in Project.toml) to provide optional functionality without forcing extra dependencies on downstream packages.\n\nThe pattern is:\n\nThe core package defines tag types and extension points (methods that throw CTBase.ExtensionError(...) by default).\nWhen you load an optional dependency, Julia automatically loads the corresponding extension module from ext/, which adds the real implementation.\n\nYou can check whether an extension is loaded with Base.get_extension:\n\nBase.get_extension(CTBase, :TestRunner)\nBase.get_extension(CTBase, :CoveragePostprocessing)\nBase.get_extension(CTBase, :DocumenterReference)\n\nFor practical guidance on using the TestRunner and CoveragePostprocessing extensions, see the Testing and Coverage Guide, which provides detailed examples and best practices for setting up testing and coverage workflows in your Julia packages. For information on automated API documentation generation using the DocumenterReference extension, see the Documentation Guide.","category":"section"}]
}

var documenterSearchIndex = {"docs":
[{"location":"api-solution.html#Solution","page":"Solution","title":"Solution","text":"","category":"section"},{"location":"api-solution.html","page":"Solution","title":"Solution","text":"CurrentModule =  CTBase","category":"page"},{"location":"api-solution.html","page":"Solution","title":"Solution","text":"Modules = [CTBase]\nOrder = [:module, :constant, :type, :function, :macro]\nPages = [\"solution.jl\"]\nPrivate = false","category":"page"},{"location":"api-callbacks.html#Callbacks","page":"Callbacks","title":"Callbacks","text":"","category":"section"},{"location":"api-callbacks.html","page":"Callbacks","title":"Callbacks","text":"CurrentModule =  CTBase","category":"page"},{"location":"api-callbacks.html","page":"Callbacks","title":"Callbacks","text":"Modules = [CTBase]\nOrder = [:module, :constant, :type, :function, :macro]\nPages = [\"callbacks.jl\"]\nPrivate = false","category":"page"},{"location":"api-developers.html#API-for-developers","page":"Developers","title":"API for developers","text":"","category":"section"},{"location":"api-developers.html","page":"Developers","title":"Developers","text":"CurrentModule =  CTBase","category":"page"},{"location":"api-developers.html","page":"Developers","title":"Developers","text":"Here is the doc of private functions and types.","category":"page"},{"location":"api-developers.html","page":"Developers","title":"Developers","text":"Modules = [CTBase]\nOrder = [:module, :constant, :type, :function, :macro]\nPublic = false","category":"page"},{"location":"api-developers.html#CTBase.DescVarArg","page":"Developers","title":"CTBase.DescVarArg","text":"A description is a tuple of symbols, that is a Tuple{Vararg{Symbol}}.\n\n\n\n\n\n","category":"constant"},{"location":"api-developers.html#CTBase.RangeConstraint","page":"Developers","title":"CTBase.RangeConstraint","text":"Type alias for an index or range.\n\n\n\n\n\n","category":"type"},{"location":"api-developers.html#CTBase.AbstractCTFunction","page":"Developers","title":"CTBase.AbstractCTFunction","text":"abstract type AbstractCTFunction <: Function\n\nAbstract type for functions.\n\n\n\n\n\n","category":"type"},{"location":"api-developers.html#CTBase.AbstractOptimalControlModel","page":"Developers","title":"CTBase.AbstractOptimalControlModel","text":"abstract type AbstractOptimalControlModel\n\n\n\n\n\n","category":"type"},{"location":"api-developers.html#CTBase.AbstractOptimalControlSolution","page":"Developers","title":"CTBase.AbstractOptimalControlSolution","text":"abstract type AbstractOptimalControlSolution\n\nAbstract type for optimal control solutions.\n\n\n\n\n\n","category":"type"},{"location":"api-developers.html#CTBase.AbstractPlotTreeElement","page":"Developers","title":"CTBase.AbstractPlotTreeElement","text":"abstract type AbstractPlotTreeElement\n\nAbstract node for plot.\n\n\n\n\n\n","category":"type"},{"location":"api-developers.html#CTBase.ParsingInfo","page":"Developers","title":"CTBase.ParsingInfo","text":"mutable struct ParsingInfo\n\nFields\n\n\n\n\n\n","category":"type"},{"location":"api-developers.html#CTBase.PlotLeaf","page":"Developers","title":"CTBase.PlotLeaf","text":"struct PlotLeaf <: CTBase.AbstractPlotTreeElement\n\nA leaf of a plot tree.\n\n\n\n\n\n","category":"type"},{"location":"api-developers.html#CTBase.PlotNode","page":"Developers","title":"CTBase.PlotNode","text":"struct PlotNode <: CTBase.AbstractPlotTreeElement\n\nA node of a plot tree.\n\n\n\n\n\n","category":"type"},{"location":"api-developers.html#CTBase.PrintCallbacks","page":"Developers","title":"CTBase.PrintCallbacks","text":"Tuple of print callbacks.\n\n\n\n\n\n","category":"type"},{"location":"api-developers.html#CTBase.StopCallbacks","page":"Developers","title":"CTBase.StopCallbacks","text":"Tuple of stop callbacks.\n\n\n\n\n\n","category":"type"},{"location":"api-developers.html#Base.:\\-Tuple{Tuple{Vararg{Symbol}}, Tuple{Vararg{Symbol}}}","page":"Developers","title":"Base.:\\","text":"\\(\n    x::Tuple{Vararg{Symbol}},\n    y::Tuple{Vararg{Symbol}}\n) -> Tuple{Vararg{Symbol}}\n\n\nReturn the difference between the description x and the description y.\n\nExample\n\njulia> (:a, :b) \\ (:a,)\n(:b,)\n\n\n\n\n\n","category":"method"},{"location":"api-developers.html#Base.show-Tuple{IO, MIME{Symbol(\"text/plain\")}, OptimalControlModel}","page":"Developers","title":"Base.show","text":"show(\n    io::IO,\n    _::MIME{Symbol(\"text/plain\")},\n    ocp::OptimalControlModel\n)\n\n\nPrint the optimal control problem.\n\n\n\n\n\n","category":"method"},{"location":"api-developers.html#Base.show-Tuple{IO, MIME{Symbol(\"text/plain\")}, OptimalControlSolution}","page":"Developers","title":"Base.show","text":"show(\n    io::IO,\n    _::MIME{Symbol(\"text/plain\")},\n    sol::OptimalControlSolution\n)\n\n\nPrints the solution.\n\n\n\n\n\n","category":"method"},{"location":"api-developers.html#Base.show-Tuple{IO, MIME{Symbol(\"text/plain\")}, Tuple{Vararg{Tuple{Vararg{Symbol}}}}}","page":"Developers","title":"Base.show","text":"show(\n    io::IO,\n    _::MIME{Symbol(\"text/plain\")},\n    descriptions::Tuple{Vararg{Tuple{Vararg{Symbol}}}}\n)\n\n\nPrint a tuple of descriptions.\n\n\n\n\n\n","category":"method"},{"location":"api-developers.html#Base.showerror-Tuple{IO, AmbiguousDescription}","page":"Developers","title":"Base.showerror","text":"showerror(io::IO, e::AmbiguousDescription)\n\n\nPrint the exception.\n\n\n\n\n\n","category":"method"},{"location":"api-developers.html#Base.showerror-Tuple{IO, IncorrectArgument}","page":"Developers","title":"Base.showerror","text":"showerror(io::IO, e::IncorrectArgument)\n\n\nPrint the exception.\n\n\n\n\n\n","category":"method"},{"location":"api-developers.html#Base.showerror-Tuple{IO, IncorrectMethod}","page":"Developers","title":"Base.showerror","text":"showerror(io::IO, e::IncorrectMethod)\n\n\nPrint the exception.\n\n\n\n\n\n","category":"method"},{"location":"api-developers.html#Base.showerror-Tuple{IO, IncorrectOutput}","page":"Developers","title":"Base.showerror","text":"showerror(io::IO, e::IncorrectOutput)\n\n\nPrint the exception.\n\n\n\n\n\n","category":"method"},{"location":"api-developers.html#Base.showerror-Tuple{IO, NotImplemented}","page":"Developers","title":"Base.showerror","text":"showerror(io::IO, e::NotImplemented)\n\n\nPrint the exception.\n\n\n\n\n\n","category":"method"},{"location":"api-developers.html#Base.showerror-Tuple{IO, ParsingError}","page":"Developers","title":"Base.showerror","text":"showerror(io::IO, e::ParsingError)\n\n\nPrint the exception.\n\n\n\n\n\n","category":"method"},{"location":"api-developers.html#Base.showerror-Tuple{IO, UnauthorizedCall}","page":"Developers","title":"Base.showerror","text":"showerror(io::IO, e::UnauthorizedCall)\n\n\nPrint the exception.\n\n\n\n\n\n","category":"method"},{"location":"api-developers.html#CTBase.__callbacks-Tuple{}","page":"Developers","title":"CTBase.__callbacks","text":"__callbacks() -> Tuple{}\n\n\nUsed to set the default value of the callbacks argument. The default value is (), which means that no additional callback is given.\n\n\n\n\n\n","category":"method"},{"location":"api-developers.html#CTBase.__constraint_label-Tuple{}","page":"Developers","title":"CTBase.__constraint_label","text":"__constraint_label() -> Symbol\n\n\nUsed to set the default value of the label of a constraint. A unique value is given to each constraint using the gensym function and prefixing by :unamed.\n\n\n\n\n\n","category":"method"},{"location":"api-developers.html#CTBase.__control_components_names-Tuple{Integer, String}","page":"Developers","title":"CTBase.__control_components_names","text":"__control_components_names(m::Integer, name::String) -> Any\n\n\nUsed to set the default value of the names of the controls. The default value is [\"u\"] for a one dimensional control, and [\"u₁\", \"u₂\", ...] for a multi dimensional control.\n\n\n\n\n\n","category":"method"},{"location":"api-developers.html#CTBase.__control_name-Tuple{}","page":"Developers","title":"CTBase.__control_name","text":"__control_name() -> String\n\n\nUsed to set the default value of the names of the control. The default value is \"u\".\n\n\n\n\n\n","category":"method"},{"location":"api-developers.html#CTBase.__criterion_type-Tuple{}","page":"Developers","title":"CTBase.__criterion_type","text":"__criterion_type() -> Symbol\n\n\nUsed to set the default value of the type of criterion. Either :min or :max. The default value is :min. The other possible criterion type is :max.\n\n\n\n\n\n","category":"method"},{"location":"api-developers.html#CTBase.__display-Tuple{}","page":"Developers","title":"CTBase.__display","text":"__display() -> Bool\n\n\nUsed to set the default value of the display argument. The default value is true, which means that the output is printed during resolution.\n\n\n\n\n\n","category":"method"},{"location":"api-developers.html#CTBase.__fun_time_dependence-Tuple{}","page":"Developers","title":"CTBase.__fun_time_dependence","text":"__fun_time_dependence() -> Type{Autonomous}\n\n\nUsed to set the default value of the time dependence of the functions.\n\nThe default value is Autonomous, which means that the functions are considered time independent. The other possible time dependence is NonAutonomous, which means that the functions are considered time dependent.\n\n\n\n\n\n","category":"method"},{"location":"api-developers.html#CTBase.__fun_variable_dependence-Tuple{}","page":"Developers","title":"CTBase.__fun_variable_dependence","text":"__fun_variable_dependence() -> Type{Fixed}\n\n\nUsed to set the default value of the variable dependence of the functions.\n\nThe default value is Fixed, which means that the functions are considered variable independent. The other possible variable dependence is NonFixed, which means that the functions are considered variable dependent.\n\n\n\n\n\n","category":"method"},{"location":"api-developers.html#CTBase.__get_data_plot-Tuple{OptimalControlSolution, Union{Symbol, Tuple{Symbol, Integer}}}","page":"Developers","title":"CTBase.__get_data_plot","text":"__get_data_plot(\n    sol::OptimalControlSolution,\n    xx::Union{Symbol, Tuple{Symbol, Integer}}\n) -> Any\n\n\nGet the data for plotting.\n\n\n\n\n\n","category":"method"},{"location":"api-developers.html#CTBase.__init_interpolation-Tuple{}","page":"Developers","title":"CTBase.__init_interpolation","text":"__init_interpolation() -> CTBase.var\"#13#14\"\n\n\nUsed to set the default interpolation function used for initialisation. The default value is Interpolations.linear_interpolation, which means that the initial guess is linearly interpolated.\n\n\n\n\n\n","category":"method"},{"location":"api-developers.html#CTBase.__initial_plot-Tuple{OptimalControlSolution}","page":"Developers","title":"CTBase.__initial_plot","text":"__initial_plot(\n    sol::OptimalControlSolution;\n    layout,\n    control,\n    kwargs...\n) -> Any\n\n\nInitial plot.\n\n\n\n\n\n","category":"method"},{"location":"api-developers.html#CTBase.__matrix_dimension_stock-Tuple{}","page":"Developers","title":"CTBase.__matrix_dimension_stock","text":"__matrix_dimension_stock() -> Int64\n\n\nUsed to set the default value of the stockage of elements in a matrix. The default value is 1.\n\n\n\n\n\n","category":"method"},{"location":"api-developers.html#CTBase.__mu_strategy_ipopt-Tuple{}","page":"Developers","title":"CTBase.__mu_strategy_ipopt","text":"__mu_strategy_ipopt() -> String\n\n\nUsed to set the default value of the μ strategy of ipopt for the direct method. The default value is adaptive.\n\n\n\n\n\n","category":"method"},{"location":"api-developers.html#CTBase.__ocp_time_dependence-Tuple{}","page":"Developers","title":"CTBase.__ocp_time_dependence","text":"__ocp_time_dependence() -> Type{Autonomous}\n\n\nUsed to set the default value of the time dependence of the Optimal Control Problem. The default value is Autonomous, which means that the Optimal Control Problem is considered time independent. The other possible time dependence is NonAutonomous, which means that all the functions used to define the  Optimal Control Problem are considered time dependent.\n\n\n\n\n\n","category":"method"},{"location":"api-developers.html#CTBase.__ocp_variable_dependence-Tuple{}","page":"Developers","title":"CTBase.__ocp_variable_dependence","text":"__ocp_variable_dependence() -> Type{Fixed}\n\n\nUsed to set the default value of the variable dependence of the Optimal Control Problem. The default value is Fixed, which means that the Optimal Control Problem is considered variable independent. The other possible variable dependence is NonFixed, which means that all the functions used to define the Optimal Control Problem are considered variable dependent.\n\n\n\n\n\n","category":"method"},{"location":"api-developers.html#CTBase.__plot_time!-Tuple{Union{Plots.Plot, Plots.Subplot}, OptimalControlSolution, Integer, Symbol}","page":"Developers","title":"CTBase.__plot_time!","text":"__plot_time!(\n    p::Union{Plots.Plot, Plots.Subplot},\n    sol::OptimalControlSolution,\n    d::Integer,\n    s::Symbol;\n    t_label,\n    labels,\n    title,\n    kwargs...\n)\n\n\nUpdate the plot p with a vectorial function of time f(t) ∈ Rᵈ where f is given by the symbol s. The argument s can be :state, :control or :costate.\n\n\n\n\n\n","category":"method"},{"location":"api-developers.html#CTBase.__plot_time!-Tuple{Union{Plots.Plot, Plots.Subplot}, OptimalControlSolution, Symbol, Integer}","page":"Developers","title":"CTBase.__plot_time!","text":"__plot_time!(\n    p::Union{Plots.Plot, Plots.Subplot},\n    sol::OptimalControlSolution,\n    s::Symbol,\n    i::Integer;\n    t_label,\n    label,\n    kwargs...\n)\n\n\nUpdate the plot p with the i-th component of a vectorial function of time f(t) ∈ Rᵈ where f is given by the symbol s. The argument s can be :state, :control or :costate.\n\n\n\n\n\n","category":"method"},{"location":"api-developers.html#CTBase.__plot_time-Tuple{OptimalControlSolution, Integer, Symbol}","page":"Developers","title":"CTBase.__plot_time","text":"__plot_time(\n    sol::OptimalControlSolution,\n    d::Integer,\n    s::Symbol;\n    t_label,\n    labels,\n    title,\n    kwargs...\n)\n\n\nPlot a vectorial function of time f(t) ∈ Rᵈ where f is given by the symbol s. The argument s can be :state, :control or :costate.\n\n\n\n\n\n","category":"method"},{"location":"api-developers.html#CTBase.__plot_time-Tuple{OptimalControlSolution, Symbol, Integer}","page":"Developers","title":"CTBase.__plot_time","text":"__plot_time(\n    sol::OptimalControlSolution,\n    s::Symbol,\n    i::Integer;\n    t_label,\n    label,\n    kwargs...\n)\n\n\nPlot the i-th component of a vectorial function of time f(t) ∈ Rᵈ where f is given by the symbol s. The argument s can be :state, :control or :costate.\n\n\n\n\n\n","category":"method"},{"location":"api-developers.html#CTBase.__plot_tree","page":"Developers","title":"CTBase.__plot_tree","text":"__plot_tree(node::CTBase.PlotNode) -> Any\n__plot_tree(\n    node::CTBase.PlotNode,\n    depth::Integer;\n    kwargs...\n) -> Any\n\n\nPlot a node.\n\n\n\n\n\n","category":"function"},{"location":"api-developers.html#CTBase.__plot_tree-Tuple{CTBase.PlotLeaf, Integer}","page":"Developers","title":"CTBase.__plot_tree","text":"__plot_tree(\n    leaf::CTBase.PlotLeaf,\n    depth::Integer;\n    kwargs...\n) -> Plots.Plot\n\n\nPlot a leaf.\n\n\n\n\n\n","category":"method"},{"location":"api-developers.html#CTBase.__print_level_ipopt-Tuple{}","page":"Developers","title":"CTBase.__print_level_ipopt","text":"__print_level_ipopt() -> Int64\n\n\nUsed to set the default value of the print level of ipopt for the direct method. The default value is 5.\n\n\n\n\n\n","category":"method"},{"location":"api-developers.html#CTBase.__state_components_names-Tuple{Integer, String}","page":"Developers","title":"CTBase.__state_components_names","text":"__state_components_names(n::Integer, name::String) -> Any\n\n\nUsed to set the default value of the names of the states. The default value is [\"x\"] for a one dimensional state, and [\"x₁\", \"x₂\", ...] for a multi dimensional state.\n\n\n\n\n\n","category":"method"},{"location":"api-developers.html#CTBase.__state_name-Tuple{}","page":"Developers","title":"CTBase.__state_name","text":"__state_name() -> String\n\n\nUsed to set the default value of the name of the state. The default value is \"x\".\n\n\n\n\n\n","category":"method"},{"location":"api-developers.html#CTBase.__time_name-Tuple{}","page":"Developers","title":"CTBase.__time_name","text":"__time_name() -> String\n\n\nUsed to set the default value of the name of the time. The default value is t.\n\n\n\n\n\n","category":"method"},{"location":"api-developers.html#CTBase.__variable_components_names-Tuple{Integer, String}","page":"Developers","title":"CTBase.__variable_components_names","text":"__variable_components_names(q::Integer, name::String) -> Any\n\n\nUsed to set the default value of the names of the variables. The default value is [\"v\"] for a one dimensional variable, and [\"v₁\", \"v₂\", ...] for a multi dimensional variable.\n\n\n\n\n\n","category":"method"},{"location":"api-developers.html#CTBase.__variable_name-Tuple{}","page":"Developers","title":"CTBase.__variable_name","text":"__variable_name() -> String\n\n\nUsed to set the default value of the names of the variables. The default value is \"v\".\n\n\n\n\n\n","category":"method"},{"location":"api-developers.html#CTBase.__width-Tuple{Real}","page":"Developers","title":"CTBase.__width","text":"__width(r::Real) -> Expr\n\n\nGenerate a{r*h} where r is a real number and h is the height of the plot.\n\n\n\n\n\n","category":"method"},{"location":"api-developers.html#CTBase.ctindice-Tuple{Integer}","page":"Developers","title":"CTBase.ctindice","text":"ctindice(i::Integer) -> Char\n\n\nReturn i ∈ [0, 9] as a subscript.\n\n\n\n\n\n","category":"method"},{"location":"api-developers.html#CTBase.ctupperscript-Tuple{Integer}","page":"Developers","title":"CTBase.ctupperscript","text":"ctupperscript(i::Integer) -> Char\n\n\nReturn i ∈ [0, 9] as an upperscript.\n\n\n\n\n\n","category":"method"},{"location":"api-developers.html#CTBase.expand-Tuple{Matrix{<:Real}}","page":"Developers","title":"CTBase.expand","text":"expand(x::Matrix{<:Real}) -> Vector{<:Real}\n\n\nReturn expand(matrix2vec(x, 1))\n\n\n\n\n\n","category":"method"},{"location":"api-developers.html#CTBase.expand-Tuple{Vector{<:Real}}","page":"Developers","title":"CTBase.expand","text":"expand(x::Vector{<:Real}) -> Vector{<:Real}\n\n\nReturn x.\n\n\n\n\n\n","category":"method"},{"location":"api-developers.html#CTBase.expand-Tuple{Vector{<:Vector{<:Real}}}","page":"Developers","title":"CTBase.expand","text":"expand(x::Vector{<:Vector{<:Real}}) -> Vector{<:Real}\n\n\nEquivalent to vec2vec(x)\n\n\n\n\n\n","category":"method"},{"location":"api-developers.html#CTBase.expr_it-Tuple{Any, Any, Any}","page":"Developers","title":"CTBase.expr_it","text":"expr_it(e, _Expr, f) -> Any\n\n\nExpr iterator: apply _Expr to nodes and f to leaves of the AST.\n\nExample\n\njulia> id(e) = expr_it(e, Expr, x -> x)\n\n\n\n\n\n","category":"method"},{"location":"api-developers.html#CTBase.has-Tuple{Any, Any, Any}","page":"Developers","title":"CTBase.has","text":"has(e, x, t) -> Union{Missing, Bool}\n\n\nReturn true if e contains an (...x...)(t) call.\n\nExample\n\njulia> e = :( ∫( x[1](t)^2 + 2*u(t) ) → min )\n:(∫((x[1])(t) ^ 2 + 2 * u(t)) → min)\n\njulia> has(e, :x, :t)\ntrue\n\njulia> has(e, :u, :t)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"api-developers.html#CTBase.has-Tuple{Any, Any}","page":"Developers","title":"CTBase.has","text":"has(e, e1) -> Union{Missing, Bool}\n\n\nReturn true if e contains e1.\n\nExample\n\njulia> e = :( ∫( x[1](t)^2 + 2*u(t) ) → min )\n:(∫((x[1])(t) ^ 2 + 2 * u(t)) → min)\n\njulia> has(e, 2)\ntrue\n\njulia> has(e, :x)\ntrue\n\njulia> has(e, :min)\ntrue\n\njulia> has(e, :( x[1](t)^2 ))\ntrue\n\njulia> !has(e, :( x[1](t)^3 ))\ntrue\n\njulia> !has(e, 3)\ntrue\n\njulia> !has(e, :max)\ntrue\n\njulia> has(:x, :x)\ntrue\n\njulia> !has(:x, 2)\ntrue\n\njulia> !has(:x, :y)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"api-developers.html#CTBase.matrix2vec","page":"Developers","title":"CTBase.matrix2vec","text":"matrix2vec(x::Matrix{<:Real}) -> Vector{<:Vector{<:Real}}\nmatrix2vec(\n    x::Matrix{<:Real},\n    dim::Integer\n) -> Vector{<:Vector{<:Real}}\n\n\nTransforms x to a Vector{<:Vector{<:ctNumber}}.\n\nNote. dim ∈ {1, 2} is the dimension along which the matrix is transformed.\n\n\n\n\n\n","category":"function"},{"location":"api-developers.html#CTBase.parse!-Tuple{Any, Any, Any}","page":"Developers","title":"CTBase.parse!","text":"parse!(p, ocp, e; log) -> Union{Expr, LineNumberNode}\n\n\nFoo\n\nExample\n\nFoo\n\n\n\n\n\n","category":"method"},{"location":"api-developers.html#CTBase.subs-Tuple{Any, Union{Real, Symbol}, Any}","page":"Developers","title":"CTBase.subs","text":"subs(e, e1::Union{Real, Symbol}, e2) -> Any\n\n\nSubstitute expression e1 by expression e2 in expression e.\n\nExamples\n\njulia> e = :( ∫( r(t)^2 + 2u₁(t)) → min )\n:(∫(r(t) ^ 2 + 2 * u₁(t)) → min)\n\njulia> subs(e, :r, :( x[1] ))\n:(∫((x[1])(t) ^ 2 + 2 * u₁(t)) → min)\n\njulia> e = :( ∫( u₁(t)^2 + 2u₂(t)) → min )\n:(∫(u₁(t) ^ 2 + 2 * u₂(t)) → min)\n\njulia> for i ∈ 1:2\n       e = subs(e, Symbol(:u, Char(8320+i)), :( u[$i] ))\n       end; e\n:(∫((u[1])(t) ^ 2 + 2 * (u[2])(t)) → min)\n\njulia> t = :t; t0 = 0; tf = :tf; x = :x; u = :u;\n\njulia> e = :( x[1](0) * 2x(tf) - x[2](tf) * 2x(0) )\n:((x[1])(0) * (2 * x(tf)) - (x[2])(tf) * (2 * x(0)))\n\njulia> x0 = Symbol(x, 0); subs(e, :( $x[1]($(t0)) ), :( $x0[1] ))\n:(x0[1] * (2 * x(tf)) - (x[2])(tf) * (2 * x(0)))\n\n\n\n\n\n","category":"method"},{"location":"api-developers.html#CTBase.vec2vec-Tuple{Vector{<:Real}, Integer}","page":"Developers","title":"CTBase.vec2vec","text":"vec2vec(\n    x::Vector{<:Real},\n    n::Integer\n) -> Vector{<:Vector{<:Real}}\n\n\nTransforms x to a Vector{<:Vector{<:ctNumber}}.\n\n\n\n\n\n","category":"method"},{"location":"api-developers.html#CTBase.vec2vec-Tuple{Vector{<:Vector{<:Real}}}","page":"Developers","title":"CTBase.vec2vec","text":"vec2vec(x::Vector{<:Vector{<:Real}}) -> Vector{<:Real}\n\n\nTransforms x to a Vector{<:ctNumber}.\n\n\n\n\n\n","category":"method"},{"location":"api-developers.html#RecipesBase.apply_recipe-Tuple{AbstractDict{Symbol, Any}, OptimalControlSolution, Union{Symbol, Tuple{Symbol, Integer}}, Union{Symbol, Tuple{Symbol, Integer}}}","page":"Developers","title":"RecipesBase.apply_recipe","text":"apply_recipe(\n    plotattributes::AbstractDict{Symbol, Any},\n    sol::OptimalControlSolution,\n    xx::Union{Symbol, Tuple{Symbol, Integer}},\n    yy::Union{Symbol, Tuple{Symbol, Integer}}\n) -> Vector{RecipesBase.RecipeData}\n\n\nReturn x and y for the plot of the optimal control solution sol  corresponding respectively to the argument xx and the argument yy.\n\nNotes.\n\nThe argument xx can be :time, :state, :control or :costate.\nIf xx is :time, then, a label is added to the plot.\nThe argument yy can be :state, :control or :costate.\n\n\n\n\n\n","category":"method"},{"location":"api-ctbase.html#CTBase.jl","page":"CTBase.jl","title":"CTBase.jl","text":"","category":"section"},{"location":"api-ctbase.html","page":"CTBase.jl","title":"CTBase.jl","text":"CurrentModule =  CTBase","category":"page"},{"location":"api-ctbase.html","page":"CTBase.jl","title":"CTBase.jl","text":"Modules = [CTBase, Base]\nOrder = [:module, :constant, :type, :function, :macro]\nPages = [\"CTBase.jl\"]\nPrivate = false","category":"page"},{"location":"api-ctbase.html#CTBase.CTBase","page":"CTBase.jl","title":"CTBase.CTBase","text":"CTBase module.\n\nLists all the imported modules and packages:\n\nBase\nCore\nDataStructures\nDocStringExtensions\nLinearAlgebra\nMLStyle\nParameters\nPlots\nPrettyTables\nPrintf\nReexport\nReplMaker\nUnicode\n\nList of all the exported names:\n\nAd\nAmbiguousDescription\nAutonomous\nBoundaryConstraint\nCTCallback\nCTCallbacks\nCTException\nControl\nControlConstraint\nControlLaw\nControls\nCostate\nCostates\nDescription\nDimension\nDo\nDynamics\nFeedbackControl\nFixed\nGuardBy\nHamiltonian\nHamiltonianVectorField\nIncorrectArgument\nIncorrectMethod\nIncorrectOutput\nIndex\nInternalException\nLagrange\nMLStyle\nMany\nMayer\nMixedConstraint\nModel\nModules\nMultiplier\nNonAutonomous\nNonFixed\nNotImplemented\nOptimalControlModel\nOptimalControlSolution\nParsingError\nPatternCompilationError\nPatternUnsolvedException\nPoisson\nPrintCallback\nQ\nState\nStateConstraint\nStates\nStopCallback\nSyntaxError\nTime\nTimeDependence\nTimes\nTimesDisc\nUnauthorizedCall\nUnknownExtension\nVariable\nVariableConstraint\nVariableDependence\nVectorField\nWhere\n@active\nactive_def\nadd\n@as_record\n@case\nconstraint\nconstraint!\nconstraint_type\nconstraints_labels\ncontrol!\nctNumber\nctVector\nctgradient\nctindices\nctinterpolate\nctjacobian\nctupperscripts\n@data\n@def\ndynamics!\nenum_matcher\ngen_lambda\ngen_match\ngen_switch\ngen_when\ngetFullDescription\nget_priority_print_callbacks\nget_priority_stop_callbacks\nis_enum\nis_max\nis_min\nis_time_dependent\nis_time_independent\nis_variable_dependent\nis_variable_independent\nmakeDescription\n@match\nmlstyle_add_deprecation_msg!\nmlstyle_report_deprecation_msg!\nnlp_constraints\nobjective!\n@otherwise\npattern_uncall\npattern_unmacrocall\npattern_unref\nplot\nplot!\nrecord_def\nremove_constraint!\nreplace_call\nstate!\n@switch\ntime!\n@trymatch\n@tryswitch\n@use\nuse\nused\nvariable!\n@when\n@λ\n\n\n\n\n\n","category":"module"},{"location":"api-ctbase.html#CTBase.Control","page":"CTBase.jl","title":"CTBase.Control","text":"Type alias for a control.\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase.html#CTBase.Costate","page":"CTBase.jl","title":"CTBase.Costate","text":"Type alias for an costate.\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase.html#CTBase.State","page":"CTBase.jl","title":"CTBase.State","text":"Type alias for a state.\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase.html#CTBase.TimesDisc","page":"CTBase.jl","title":"CTBase.TimesDisc","text":"Type alias for a grid of times.\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase.html#CTBase.Variable","page":"CTBase.jl","title":"CTBase.Variable","text":"Type alias for a variable.\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase.html#CTBase.ctVector","page":"CTBase.jl","title":"CTBase.ctVector","text":"Type alias for a vector of real numbers.\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase.html#CTBase.Controls","page":"CTBase.jl","title":"CTBase.Controls","text":"Type alias for a vector of controls.\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase.html#CTBase.Costates","page":"CTBase.jl","title":"CTBase.Costates","text":"Type alias for a vector of costates.\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase.html#CTBase.Dimension","page":"CTBase.jl","title":"CTBase.Dimension","text":"Type alias for a dimension.\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase.html#CTBase.States","page":"CTBase.jl","title":"CTBase.States","text":"Type alias for a vector of states.\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase.html#CTBase.Time","page":"CTBase.jl","title":"CTBase.Time","text":"Type alias for a time.\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase.html#CTBase.Times","page":"CTBase.jl","title":"CTBase.Times","text":"Type alias for a vector of times.\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase.html#CTBase.ctNumber","page":"CTBase.jl","title":"CTBase.ctNumber","text":"Type alias for a real number.\n\n\n\n\n\n","category":"type"},{"location":"api-parser.html#Parser","page":"Parser","title":"Parser","text":"","category":"section"},{"location":"api-parser.html","page":"Parser","title":"Parser","text":"CurrentModule =  CTBase","category":"page"},{"location":"api-parser.html","page":"Parser","title":"Parser","text":"Modules = [CTBase]\nOrder = [:module, :constant, :type, :function, :macro]\nPages = [\"ctparser_utils.jl\", \"ctparser.jl\"]\nPrivate = false","category":"page"},{"location":"api-parser.html#CTBase.constraint_type-NTuple{7, Any}","page":"Parser","title":"CTBase.constraint_type","text":"constraint_type(\n    e,\n    t,\n    t0,\n    tf,\n    x,\n    u,\n    v\n) -> Union{Symbol, Tuple{Symbol, Any}}\n\n\nReturn the type constraint among :initial, :final, :boundary, :control_range, :control_fun, :state_range, :state_fun, :mixed, :variable_range, :variable_fun (:other otherwise), together with the appropriate value (range, updated expression...)\n\nExample\n\njulia> t = :t; t0 = 0; tf = :tf; x = :x; u = :u; v = :v\n\njulia> constraint_type(:( ẏ(t) ), t, t0, tf, x, u, v)\n:other\n\njulia> constraint_type(:( ẋ(s) ), t, t0, tf, x, u, v)\n:other\n\njulia> constraint_type(:( x(0)' ), t, t0, tf, x, u, v)\n(:boundary, :(var\"x#0\"'))\n\njulia> constraint_type(:( x(t)' ), t, t0, tf, x, u, v)\n(:state_fun, :(var\"x#t\"'))\n\njulia> constraint_type(:( x(0) ), t, t0, tf, x, u, v)\n(:initial, nothing)\n\njulia> constraint_type(:( x[1:2:5](0) ), t, t0, tf, x, u, v)\n(:initial, 1:2:5)\n\njulia> constraint_type(:( x[1:2](0) ), t, t0, tf, x, u, v)\n(:initial, 1:2)\n\njulia> constraint_type(:( x[1](0) ), t, t0, tf, x, u, v)\n(:initial, Index(1))\n\njulia> constraint_type(:( 2x[1](0)^2 ), t, t0, tf, x, u, v)\n(:boundary, :(2 * var\"x#0\"[1] ^ 2))\n\njulia> constraint_type(:( x(tf) ), t, t0, tf, x, u, v)\n(:final, nothing)\nj\njulia> constraint_type(:( x[1:2:5](tf) ), t, t0, tf, x, u, v)\n(:final, 1:2:5)\n\njulia> constraint_type(:( x[1:2](tf) ), t, t0, tf, x, u, v)\n(:final, 1:2)\n\njulia> constraint_type(:( x[1](tf) ), t, t0, tf, x, u, v)\n(:final, Index(1))\n\njulia> constraint_type(:( 2x[1](tf)^2 ), t, t0, tf, x, u, v)\n(:boundary, :(2 * var\"x#f\"[1] ^ 2))\n\njulia> constraint_type(:( x[1](tf) - x[2](0) ), t, t0, tf, x, u, v)\n(:boundary, :(var\"x#f\"[1] - var\"x#0\"[2]))\n\njulia> constraint_type(:( u[1:2:5](t) ), t, t0, tf, x, u, v)\n(:control_range, 1:2:5)\n\njulia> constraint_type(:( u[1:2](t) ), t, t0, tf, x, u, v)\n(:control_range, 1:2)\n\njulia> constraint_type(:( u[1](t) ), t, t0, tf, x, u, v)\n(:control_range, Index(1))\n\njulia> constraint_type(:( u(t) ), t, t0, tf, x, u, v)\n(:control_range, nothing)\n\njulia> constraint_type(:( 2u[1](t)^2 ), t, t0, tf, x, u, v)\n(:control_fun, :(2 * var\"u#t\"[1] ^ 2))\n\njulia> constraint_type(:( x[1:2:5](t) ), t, t0, tf, x, u, v)\n(:state_range, 1:2:5)\n\njulia> constraint_type(:( x[1:2](t) ), t, t0, tf, x, u, v)\n(:state_range, 1:2)\n\njulia> constraint_type(:( x[1](t) ), t, t0, tf, x, u, v)\n(:state_range, Index(1))\n\njulia> constraint_type(:( x(t) ), t, t0, tf, x, u, v)\n(:state_range, nothing)\n\njulia> constraint_type(:( 2x[1](t)^2 ), t, t0, tf, x, u, v)\n(:state_fun, :(2 * var\"x#t\"[1] ^ 2))\n\njulia> constraint_type(:( 2u[1](t)^2 * x(t) ), t, t0, tf, x, u, v)\n(:mixed, :((2 * var\"u#t\"[1] ^ 2) * var\"x#t\"))\n\njulia> constraint_type(:( 2u[1](0)^2 * x(t) ), t, t0, tf, x, u, v)\n:other\n\njulia> constraint_type(:( 2u[1](0)^2 * x(t) ), t, t0, tf, x, u, v)\n:other\n\njulia> constraint_type(:( 2u[1](t)^2 * x(t) + v ), t, t0, tf, x, u, v)\n(:mixed, :((2 * var\"u#t\"[1] ^ 2) * var\"x#t\" + v))\n\njulia> constraint_type(:( v[1:2:10] ), t, t0, tf, x, u, v)\n(:variable_range, 1:2:9)\n\njulia> constraint_type(:( v[1:10] ), t, t0, tf, x, u, v)\n(:variable_range, 1:10)\n\njulia> constraint_type(:( v[2] ), t, t0, tf, x, u, v)\n(:variable_range, Index(2))\n\njulia> constraint_type(:( v ), t, t0, tf, x, u, v)\n(:variable_range, nothing)\n\njulia> constraint_type(:( v^2  + 1 ), t, t0, tf, x, u, v)\n(:variable_fun, :(v ^ 2 + 1))\n\njulia> constraint_type(:( v[2]^2 + 1 ), t, t0, tf, x, u, v)\n(:variable_fun, :(v[2] ^ 2 + 1))\n\n\n\n\n\n","category":"method"},{"location":"api-parser.html#CTBase.replace_call-Tuple{Any, Symbol, Any, Any}","page":"Parser","title":"CTBase.replace_call","text":"replace_call(e, x::Symbol, t, y) -> Any\n\n\nReplace calls in e of the form (...x...)(t) by (...y...)(t).\n\nExample\n\n\njulia> t = :t; t0 = 0; tf = :tf; x = :x; u = :u;\n\njulia> e = :( x[1](0) * 2x(tf) - x[2](tf) * 2x(0) )\n:((x[1])(0) * (2 * x(tf)) - (x[2])(tf) * (2 * x(0)))\n\njulia> x0 = Symbol(x, 0); e = replace_call(e, x, t0, x0)\n:(x0[1] * (2 * x(tf)) - (x[2])(tf) * (2x0))\n\njulia> xf = Symbol(x, \"f\"); replace_call(ans, x, tf, xf)\n:(x0[1] * (2xf) - xf[2] * (2x0))\n\njulia> e = :( A*x(t) + B*u(t) ); replace_call(replace_call(e, x, t, x), u, t, u)\n:(A * x + B * u)\n\njulia> e = :( F0(x(t)) + u(t)*F1(x(t)) ); replace_call(replace_call(e, x, t, x), u, t, u)\n:(F0(x) + u * F1(x))\n\njulia> e = :( 0.5u(t)^2  ); replace_call(e, u, t, u)\n:(0.5 * u ^ 2)\n\n\n\n\n\n","category":"method"},{"location":"api-parser.html#CTBase.replace_call-Tuple{Any, Vector{Symbol}, Any, Any}","page":"Parser","title":"CTBase.replace_call","text":"replace_call(e, x::Vector{Symbol}, t, y) -> Any\n\n\nReplace calls in e of the form (...x1...x2...)(t) by (...y1...y2...)(t) for all symbols x1, x2... in the vector x.\n\nExample\n\n\njulia> t = :t; t0 = 0; tf = :tf; x = :x; u = :u;\n\njulia> e = :( (x^2 + u[1])(t) ); replace_call(e, [ x, u ], t , [ :xx, :uu ])\n:(xx ^ 2 + uu[1])\n\njulia> e = :( ((x^2)(t) + u[1])(t) ); replace_call(e, [ x, u ], t , [ :xx, :uu ])\n:(xx ^ 2 + uu[1])\n\njulia> e = :( ((x^2)(t0) + u[1])(t) ); replace_call(e, [ x, u ], t , [ :xx, :uu ])\n:((xx ^ 2)(t0) + uu[1])\n\n\n\n\n\n","category":"method"},{"location":"api-print.html#Print","page":"Print","title":"Print","text":"","category":"section"},{"location":"api-print.html","page":"Print","title":"Print","text":"CurrentModule =  CTBase","category":"page"},{"location":"api-print.html","page":"Print","title":"Print","text":"Modules = [CTBase]\nOrder = [:module, :constant, :type, :function, :macro]\nPages = [\"print.jl\"]\nPrivate = false","category":"page"},{"location":"api-print.html","page":"Print","title":"Print","text":"An optimal control problem can be described as minimising the cost functional","category":"page"},{"location":"api-print.html","page":"Print","title":"Print","text":"g(t_0 x(t_0) t_f x(t_f)) + int_t_0^t_f f^0(t x(t) u(t))mathrmdt","category":"page"},{"location":"api-print.html","page":"Print","title":"Print","text":"where the state x and the control u are functions subject, for t in t_0 t_f, to the differential constraint","category":"page"},{"location":"api-print.html","page":"Print","title":"Print","text":"   dotx(t) = f(t x(t) u(t))","category":"page"},{"location":"api-print.html","page":"Print","title":"Print","text":"and other constraints such as","category":"page"},{"location":"api-print.html","page":"Print","title":"Print","text":"beginarrayllcll\nxi_l  le xi(t u(t))        le xi_u \neta_l le eta(t x(t))       le eta_u \npsi_l le psi(t x(t) u(t)) le psi_u \nphi_l le phi(t_0 x(t_0) t_f x(t_f)) le phi_u\nendarray","category":"page"},{"location":"api-print.html","page":"Print","title":"Print","text":"Let us define the following optimal control problem.","category":"page"},{"location":"api-print.html","page":"Print","title":"Print","text":"using CTBase\n\nocp = Model()\n\nstate!(ocp, 2, [\"r\", \"v\"]) # dimension of the state with the names of the components\ncontrol!(ocp, 1)           # dimension of the control\ntime!(ocp, [0, 1], \"s\")    # initial and final time, with the name of the variable time\n\nconstraint!(ocp, :initial, [-1, 0])\nconstraint!(ocp, :final  , [ 0, 0])\nA = [ 0 1\n      0 0 ]\nB = [ 0\n      1 ]\ndynamics!(ocp, (x, u) -> A*x + B*u)\n\nobjective!(ocp, :lagrange, (x, u) -> 0.5u^2)\nnothing # hide","category":"page"},{"location":"api-print.html","page":"Print","title":"Print","text":"Then, we can print the form of this optimal control problem:","category":"page"},{"location":"api-print.html","page":"Print","title":"Print","text":"ocp","category":"page"},{"location":"api-plot.html#Plot","page":"Plot","title":"Plot","text":"","category":"section"},{"location":"api-plot.html","page":"Plot","title":"Plot","text":"CurrentModule =  CTBase","category":"page"},{"location":"api-plot.html","page":"Plot","title":"Plot","text":"Modules = [CTBase]\nOrder = [:module, :constant, :type, :function, :macro]\nPages = [\"plot.jl\"]\nPrivate = false","category":"page"},{"location":"api-plot.html#RecipesBase.plot!-Tuple{Plots.Plot, OptimalControlSolution}","page":"Plot","title":"RecipesBase.plot!","text":"plot!(\n    p::Plots.Plot,\n    sol::OptimalControlSolution;\n    layout,\n    control,\n    state_style,\n    control_style,\n    costate_style,\n    kwargs...\n) -> Plots.Plot\n\n\nPlot the optimal control solution sol using the layout layout.\n\nNotes.\n\nThe argument layout can be :group or :split (default).\nThe keyword arguments state_style, control_style and costate_style are passed to the plot function of the Plots package. The state_style is passed to the plot of the state, the control_style is passed to the plot of the control and the costate_style is passed to the plot of the costate.\n\n\n\n\n\n","category":"method"},{"location":"api-plot.html#RecipesBase.plot-Tuple{OptimalControlSolution}","page":"Plot","title":"RecipesBase.plot","text":"plot(\n    sol::OptimalControlSolution;\n    layout,\n    state_style,\n    control_style,\n    costate_style,\n    kwargs...\n) -> Any\n\n\nPlot the optimal control solution sol using the layout layout.\n\nNotes.\n\nThe argument layout can be :group or :split (default).\nThe keyword arguments state_style, control_style and costate_style are passed to the plot function of the Plots package. The state_style is passed to the plot of the state, the control_style is passed to the plot of the control and the costate_style is passed to the plot of the costate.\n\n\n\n\n\n","category":"method"},{"location":"api-plot.html","page":"Plot","title":"Plot","text":"using CTBase\n\n# create a solution\nn=2\nm=1\nt0=0.0\ntf=1.0\nx0=[-1.0, 0.0]\nxf=[0.0, 0.0]\na = x0[1]\nb = x0[2]\nC = [-(tf-t0)^3/6.0 (tf-t0)^2/2.0\n     -(tf-t0)^2/2.0 (tf-t0)]\nD = [-a-b*(tf-t0), -b]+xf\np0 = C\\D\nα = p0[1]\nβ = p0[2]\nx(t) = [a+b*(t-t0)+β*(t-t0)^2/2.0-α*(t-t0)^3/6.0, b+β*(t-t0)-α*(t-t0)^2/2.0]\np(t) = [α, -α*(t-t0)+β]\nu(t) = [p(t)[2]]\nobjective = 0.5*(α^2*(tf-t0)^3/3+β^2*(tf-t0)-α*β*(tf-t0)^2)\n#\nN=201\ntimes = range(t0, tf, N)\n#\n\nsol = OptimalControlSolution()\nsol.state_dimension = n\nsol.control_dimension = m\nsol.times = times\nsol.time_name=\"t\"\nsol.state = x\nsol.state_components_names = [ \"x\" * ctindices(i) for i ∈ range(1, n)]\nsol.costate = p\nsol.control = u\nsol.control_components_names = [ \"u\" ]\nsol.objective = objective\nsol.iterations = 0\nsol.stopping = :dummy\nsol.message = \"ceci est un test\"\nsol.success = true","category":"page"},{"location":"api-plot.html","page":"Plot","title":"Plot","text":"Let us consider we have defined an optimal control problem","category":"page"},{"location":"api-plot.html","page":"Plot","title":"Plot","text":"ocp = Model()\n...","category":"page"},{"location":"api-plot.html","page":"Plot","title":"Plot","text":"and solve it","category":"page"},{"location":"api-plot.html","page":"Plot","title":"Plot","text":"sol = solve(ocp)","category":"page"},{"location":"api-plot.html","page":"Plot","title":"Plot","text":"We can plot the solution with the default layout :split.","category":"page"},{"location":"api-plot.html","page":"Plot","title":"Plot","text":"plot(sol, layout=:split, size=(800, 600))","category":"page"},{"location":"api-plot.html","page":"Plot","title":"Plot","text":"Or with the layout :group.","category":"page"},{"location":"api-plot.html","page":"Plot","title":"Plot","text":"plot(sol, layout=:group, size=(800, 300))","category":"page"},{"location":"api-plot.html","page":"Plot","title":"Plot","text":"You can specify some styles:","category":"page"},{"location":"api-plot.html","page":"Plot","title":"Plot","text":"plot(sol, \n    state_style=(color=:blue,), \n    costate_style=(color=:black, linestyle=:dash),\n    control_style=(color=:red, linewidth=2),\n    size=(800, 600))","category":"page"},{"location":"api-description.html#Description","page":"Description","title":"Description","text":"","category":"section"},{"location":"api-description.html","page":"Description","title":"Description","text":"CurrentModule =  CTBase","category":"page"},{"location":"api-description.html","page":"Description","title":"Description","text":"Modules = [CTBase]\nOrder = [:module, :constant, :type, :function, :macro]\nPages = [\"description.jl\"]\nPrivate = false","category":"page"},{"location":"api-description.html#CTBase.Description","page":"Description","title":"CTBase.Description","text":"A description is a tuple of symbols, that is a Tuple{Vararg{Symbol}}.\n\n\n\n\n\n","category":"type"},{"location":"api-description.html#CTBase.add-Tuple{Tuple{Vararg{Tuple{Vararg{Symbol}}}}, Tuple{Vararg{Symbol}}}","page":"Description","title":"CTBase.add","text":"add(\n    x::Tuple{Vararg{Tuple{Vararg{Symbol}}}},\n    y::Tuple{Vararg{Symbol}}\n) -> Tuple{Tuple{Vararg{Symbol}}}\n\n\nConcatenate the description y at the tuple of descriptions x if it is not already in the tuple x.\n\nExample\n\njulia> descriptions = ()\njulia> descriptions = add(descriptions, (:a,))\n((:a,),)\njulia> descriptions = add(descriptions, (:b,))\n((:a,), (:b,))\n\n\n\n\n\n","category":"method"},{"location":"api-description.html#CTBase.add-Tuple{Tuple{}, Tuple{Vararg{Symbol}}}","page":"Description","title":"CTBase.add","text":"add(\n    x::Tuple{},\n    y::Tuple{Vararg{Symbol}}\n) -> Tuple{Tuple{Vararg{Symbol}}}\n\n\nReturn a tuple containing only the description y.\n\nExample\n\njulia> descriptions = ()\njulia> descriptions = add(descriptions, (:a,))\n((:a,),)\njulia> descriptions[1]\n(:a,)\n\n\n\n\n\n","category":"method"},{"location":"api-description.html#CTBase.getFullDescription-Tuple{Tuple{Vararg{Symbol}}, Tuple{Vararg{Tuple{Vararg{Symbol}}}}}","page":"Description","title":"CTBase.getFullDescription","text":"getFullDescription(\n    desc::Tuple{Vararg{Symbol}},\n    desc_list::Tuple{Vararg{Tuple{Vararg{Symbol}}}}\n) -> Tuple{Vararg{Symbol}}\n\n\nReturn a complete description from an incomplete description desc and  a list of complete descriptions desc_list. If several complete descriptions are possible,  then the first one is returned.\n\nExample\n\njulia> desc_list = ((:a, :b), (:b, :c), (:a, :c))\n((:a, :b), (:b, :c), (:a, :c))\njulia> getFullDescription((:a,), desc_list)\n(:a, :b)\n\n\n\n\n\n","category":"method"},{"location":"api-functions.html#Functions","page":"Functions","title":"Functions","text":"","category":"section"},{"location":"api-functions.html","page":"Functions","title":"Functions","text":"CurrentModule =  CTBase","category":"page"},{"location":"api-functions.html","page":"Functions","title":"Functions","text":"Modules = [CTBase]\nOrder = [:module, :constant, :type, :function, :macro]\nPages = [\"functions.jl\"]\nPrivate = false","category":"page"},{"location":"api-exceptions.html#Exceptions","page":"Exceptions","title":"Exceptions","text":"","category":"section"},{"location":"api-exceptions.html","page":"Exceptions","title":"Exceptions","text":"CurrentModule =  CTBase","category":"page"},{"location":"api-exceptions.html","page":"Exceptions","title":"Exceptions","text":"Modules = [CTBase]\nOrder = [:module, :constant, :type, :function, :macro]\nPages = [\"exceptions.jl\"]\nPrivate = false","category":"page"},{"location":"api-model.html#Model","page":"Model","title":"Model","text":"","category":"section"},{"location":"api-model.html","page":"Model","title":"Model","text":"CurrentModule =  CTBase","category":"page"},{"location":"api-model.html","page":"Model","title":"Model","text":"Modules = [CTBase]\nOrder = [:module, :constant, :type, :function, :macro]\nPages = [\"model.jl\"]\nPrivate = false","category":"page"},{"location":"api-model.html#CTBase.Model-Tuple{Vararg{DataType}}","page":"Model","title":"CTBase.Model","text":"Model(\n    dependences::DataType...\n) -> OptimalControlModel{Autonomous, Fixed}\n\n\nReturn a new OptimalControlModel instance, that is a model of an optimal control problem.\n\nThe model is defined by the following argument:\n\ndependences: either Autonomous or NonAutonomous. Default is Autonomous. And either NonFixed or Fixed. Default is Fixed.\n\nExamples\n\njulia> ocp = Model()\njulia> ocp = Model(NonAutonomous)\njulia> ocp = Model(Fixed,NonFixed)\n\nnote: Note\nIf the time dependence of the model is defined as nonautonomous, then, the dynamics function, the lagrange cost and the path constraints must be defined as functions of time and state, and possibly control. If the model is defined as autonomous, then, the dynamics function, the lagrange cost and the path constraints must be defined as functions of state, and possibly control.\n\n\n\n\n\n","category":"method"},{"location":"api-model.html#CTBase.Model-Tuple{}","page":"Model","title":"CTBase.Model","text":"Model(\n;\n    autonomous,\n    variable\n) -> OptimalControlModel{Autonomous, Fixed}\n\n\nReturn a new OptimalControlModel instance, that is a model of an optimal control problem.\n\nThe model is defined by the following optional keyword argument:\n\nautonomous: either true or false. Default is true.\nvariable: either true or false. Default is false.\n\nExamples\n\njulia> ocp = Model()\njulia> ocp = Model(autonomous=false)\njulia> ocp = Model(autonomous=false, variable=true)\n\nnote: Note\nIf the time dependence of the model is defined as nonautonomous, then, the dynamics function, the lagrange cost and the path constraints must be defined as functions of time and state, and possibly control. If the model is defined as autonomous, then, the dynamics function, the lagrange cost and the path constraints must be defined as functions of state, and possibly control.\n\n\n\n\n\n","category":"method"},{"location":"api-model.html#CTBase.constraint!","page":"Model","title":"CTBase.constraint!","text":"constraint!(\n    ocp::OptimalControlModel,\n    type::Symbol,\n    f::Function,\n    val::Union{Real, AbstractVector{<:Real}}\n)\nconstraint!(\n    ocp::OptimalControlModel,\n    type::Symbol,\n    f::Function,\n    val::Union{Real, AbstractVector{<:Real}},\n    label::Symbol\n)\n\n\nAdd a :boundary, :control, :state, :mixed or :variable value functional constraint.\n\nnote: Note\nThe state, control and variable dimensions must be set before. Use state!, control! and variable!.\nThe times must be set before. Use time!.\nWhen an element is of dimension 1, consider it as a scalar.\n\nExamples\n\n# variable independent ocp\njulia> constraint!(ocp, :boundary, (x0, xf) -> x0[3]+xf[2], 0)\n\n# variable dependent ocp\njulia> constraint!(ocp, :boundary, (x0, xf, v) -> x0[3]+xf[2]*v[1], 0)\n\n# time independent and variable independent ocp\njulia> constraint!(ocp, :control, u -> 2u, 1)\njulia> constraint!(ocp, :state, x -> x-1, [ 0, 0, 0 ])\njulia> constraint!(ocp, :mixed, (x, u) -> x[1]-u, 0)\n\n# time dependent and variable independent ocp\njulia> constraint!(ocp, :control, (t, u) -> 2u, 1)\njulia> constraint!(ocp, :state, (t, x) -> x-t, [ 0, 0, 0 ])\njulia> constraint!(ocp, :mixed, (t, x, u) -> x[1]-u, 0)\n\n# time independent and variable dependent ocp\njulia> constraint!(ocp, :control, (u, v) -> 2u*v[1], 1)\njulia> constraint!(ocp, :state, (x, v) -> x-v[2], [ 0, 0, 0 ])\njulia> constraint!(ocp, :mixed, (x, u) -> x[1]-u+v[1], 0)\n\n# time dependent and variable dependent ocp\njulia> constraint!(ocp, :control, (t, u, v) -> 2u-t*v[2], 1)\njulia> constraint!(ocp, :state, (t, x, v) -> x-t+v[1], [ 0, 0, 0 ])\njulia> constraint!(ocp, :mixed, (t, x, u, v) -> x[1]-u*v[1], 0)\n\n\n\n\n\n","category":"function"},{"location":"api-model.html#CTBase.constraint!-2","page":"Model","title":"CTBase.constraint!","text":"constraint!(\n    ocp::OptimalControlModel,\n    type::Symbol,\n    lb::Union{Real, AbstractVector{<:Real}},\n    ub::Union{Real, AbstractVector{<:Real}}\n)\nconstraint!(\n    ocp::OptimalControlModel,\n    type::Symbol,\n    lb::Union{Real, AbstractVector{<:Real}},\n    ub::Union{Real, AbstractVector{<:Real}},\n    label::Symbol\n)\n\n\nAdd an :initial, :final, :control, :state or :variable box constraint (whole range).\n\nnote: Note\nThe state, control and variable dimensions must be set before. Use state!, control! and variable!.\nThe times must be set before. Use time!.\nWhen an element is of dimension 1, consider it as a scalar.\n\nExamples\n\njulia> constraint!(ocp, :initial, [ 0, 0, 0 ], [ 1, 2, 1 ])\njulia> constraint!(ocp, :final, [ 0, 0, 0 ], [ 1, 2, 1 ])\njulia> constraint!(ocp, :control, [ 0, 0 ], [ 2, 3 ])\njulia> constraint!(ocp, :state, [ 0, 0, 0 ], [ 1, 2, 1 ])\njulia> constraint!(ocp, :variable, 0, 1) # the variable here is of dimension 1\n\n\n\n\n\n","category":"function"},{"location":"api-model.html#CTBase.constraint!-3","page":"Model","title":"CTBase.constraint!","text":"constraint!(\n    ocp::OptimalControlModel,\n    type::Symbol,\n    rg::Union{Index, OrdinalRange{<:Integer}},\n    val::Union{Real, AbstractVector{<:Real}}\n)\nconstraint!(\n    ocp::OptimalControlModel,\n    type::Symbol,\n    rg::Union{Index, OrdinalRange{<:Integer}},\n    val::Union{Real, AbstractVector{<:Real}},\n    label::Symbol\n)\n\n\nAdd an :initial or :final value constraint on a range of the state, or a value constraint on a range of the :variable.\n\nnote: Note\nThe range of the constraint must be contained in 1:n if the constraint is on the state, or 1:q if the constraint is on the variable.\nThe state, control and variable dimensions must be set before. Use state!, control! and variable!.\nThe times must be set before. Use time!.\n\nExamples\n\njulia> constraint!(ocp, :initial, 1:2:5, [ 0, 0, 0 ])\njulia> constraint!(ocp, :initial, 2:3, [ 0, 0 ])\njulia> constraint!(ocp, :final, Index(2), 0)\njulia> constraint!(ocp, :variable, 2:3, [ 0, 3 ])\n\n\n\n\n\n","category":"function"},{"location":"api-model.html#CTBase.constraint!-4","page":"Model","title":"CTBase.constraint!","text":"constraint!(\n    ocp::OptimalControlModel,\n    type::Symbol,\n    val::Union{Real, AbstractVector{<:Real}}\n)\nconstraint!(\n    ocp::OptimalControlModel,\n    type::Symbol,\n    val::Union{Real, AbstractVector{<:Real}},\n    label::Symbol\n)\n\n\nAdd an :initial or :final value constraint on the state, or a :variable value.\n\nnote: Note\nThe state, control and variable dimensions must be set before. Use state!, control! and variable!.\nThe times must be set before. Use time!.\nWhen an element is of dimension 1, consider it as a scalar.\n\nExamples\n\njulia> constraint!(ocp, :initial, [ 0, 0 ])\njulia> constraint!(ocp, :final, 2) # if the state is of dimension 1\njulia> constraint!(ocp, :variable, [ 3, 0, 1 ])\n\n\n\n\n\n","category":"function"},{"location":"api-model.html#CTBase.constraint!-Tuple{OptimalControlModel, Symbol}","page":"Model","title":"CTBase.constraint!","text":"constraint!(\n    ocp::OptimalControlModel,\n    type::Symbol;\n    rg,\n    f,\n    val,\n    lb,\n    ub,\n    label\n)\n\n\nAdd an :initial, :final, :control, :state or :variable box constraint on a range.\n\nnote: Note\nThe range of the constraint must be contained in 1:n if the constraint is on the state, or 1:m if the constraint is on the control, or 1:q if the constraint is on the variable.\nThe state, control and variable dimensions must be set before. Use state!, control! and variable!.\nThe times must be set before. Use time!.\n\nExamples\n\njulia> constraint!(ocp, :initial, rg=2:3, lb=[ 0, 0 ], ub=[ 1, 2 ])\njulia> constraint!(ocp, :final, val=Index(1), lb=0, ub=2)\njulia> constraint!(ocp, :control, val=Index(1), lb=0, ub=2)\njulia> constraint!(ocp, :state, rg=2:3, lb=[ 0, 0 ], ub=[ 1, 2 ])\njulia> constraint!(ocp, :initial, rg=1:2:5, lb=[ 0, 0, 0 ], ub=[ 1, 2, 1 ])\njulia> constraint!(ocp, :variable, rg=1:2, lb=[ 0, 0 ], ub=[ 1, 2 ])\n\n\n\n\n\n","category":"method"},{"location":"api-model.html#CTBase.constraint!-Union{Tuple{V}, Tuple{OptimalControlModel{<:TimeDependence, V}, Symbol, Union{Index, OrdinalRange{<:Integer}}, Union{Real, AbstractVector{<:Real}}, Union{Real, AbstractVector{<:Real}}}, Tuple{OptimalControlModel{<:TimeDependence, V}, Symbol, Union{Index, OrdinalRange{<:Integer}}, Union{Real, AbstractVector{<:Real}}, Union{Real, AbstractVector{<:Real}}, Symbol}} where V<:VariableDependence","page":"Model","title":"CTBase.constraint!","text":"constraint!(\n    ocp::OptimalControlModel{<:TimeDependence, V<:VariableDependence},\n    type::Symbol,\n    rg::Union{Index, OrdinalRange{<:Integer}},\n    lb::Union{Real, AbstractVector{<:Real}},\n    ub::Union{Real, AbstractVector{<:Real}}\n)\nconstraint!(\n    ocp::OptimalControlModel{<:TimeDependence, V<:VariableDependence},\n    type::Symbol,\n    rg::Union{Index, OrdinalRange{<:Integer}},\n    lb::Union{Real, AbstractVector{<:Real}},\n    ub::Union{Real, AbstractVector{<:Real}},\n    label::Symbol\n)\n\n\nAdd an :initial, :final, :control, :state or :variable box constraint on a range.\n\nnote: Note\nThe range of the constraint must be contained in 1:n if the constraint is on the state, or 1:m if the constraint is on the control, or 1:q if the constraint is on the variable.\nThe state, control and variable dimensions must be set before. Use state!, control! and variable!.\nThe times must be set before. Use time!.\n\nExamples\n\njulia> constraint!(ocp, :initial, 2:3, [ 0, 0 ], [ 1, 2 ])\njulia> constraint!(ocp, :final, Index(1), 0, 2)\njulia> constraint!(ocp, :control, Index(1), 0, 2)\njulia> constraint!(ocp, :state, 2:3, [ 0, 0 ], [ 1, 2 ])\njulia> constraint!(ocp, :initial, 1:2:5, [ 0, 0, 0 ], [ 1, 2, 1 ])\njulia> constraint!(ocp, :variable, 1:2, [ 0, 0 ], [ 1, 2 ])\n\n\n\n\n\n","category":"method"},{"location":"api-model.html#CTBase.constraint!-Union{Tuple{V}, Tuple{T}, Tuple{OptimalControlModel{T, V}, Symbol, Function, Union{Real, AbstractVector{<:Real}}, Union{Real, AbstractVector{<:Real}}}, Tuple{OptimalControlModel{T, V}, Symbol, Function, Union{Real, AbstractVector{<:Real}}, Union{Real, AbstractVector{<:Real}}, Symbol}} where {T, V}","page":"Model","title":"CTBase.constraint!","text":"constraint!(\n    ocp::OptimalControlModel{T, V},\n    type::Symbol,\n    f::Function,\n    lb::Union{Real, AbstractVector{<:Real}},\n    ub::Union{Real, AbstractVector{<:Real}}\n)\nconstraint!(\n    ocp::OptimalControlModel{T, V},\n    type::Symbol,\n    f::Function,\n    lb::Union{Real, AbstractVector{<:Real}},\n    ub::Union{Real, AbstractVector{<:Real}},\n    label::Symbol\n)\n\n\nAdd a :boundary, :control, :state, :mixed or :variable box functional constraint.\n\nnote: Note\nThe state, control and variable dimensions must be set before. Use state!, control! and variable!.\nThe times must be set before. Use time!.\nWhen an element is of dimension 1, consider it as a scalar.\n\nExamples\n\n# variable independent ocp\njulia> constraint!(ocp, :boundary, (x0, xf) -> x0[3]+xf[2], 0, 1)\n\n# variable dependent ocp\njulia> constraint!(ocp, :boundary, (x0, xf, v) -> x0[3]+xf[2]*v[1], 0, 1)\n\n# time independent and variable independent ocp\njulia> constraint!(ocp, :control, u -> 2u, 0, 1)\njulia> constraint!(ocp, :state, x -> x-1, [ 0, 0, 0 ], [ 1, 2, 1 ])\njulia> constraint!(ocp, :mixed, (x, u) -> x[1]-u, 0, 1)\n\n# time dependent and variable independent ocp\njulia> constraint!(ocp, :control, (t, u) -> 2u, 0, 1)\njulia> constraint!(ocp, :state, (t, x) -> x-t, [ 0, 0, 0 ], [ 1, 2, 1 ])\njulia> constraint!(ocp, :mixed, (t, x, u) -> x[1]-u, 0, 1)\n\n# time independent and variable dependent ocp\njulia> constraint!(ocp, :control, (u, v) -> 2u*v[1], 0, 1)\njulia> constraint!(ocp, :state, (x, v) -> x-v[1], [ 0, 0, 0 ], [ 1, 2, 1 ])\njulia> constraint!(ocp, :mixed, (x, u, v) -> x[1]-v[2]*u, 0, 1)\n\n# time dependent and variable dependent ocp\njulia> constraint!(ocp, :control, (t, u, v) -> 2u+v[2], 0, 1)\njulia> constraint!(ocp, :state, (t, x, v) -> x-t*v[1], [ 0, 0, 0 ], [ 1, 2, 1 ])\njulia> constraint!(ocp, :mixed, (t, x, u, v) -> x[1]*v[2]-u, 0, 1)\n\n\n\n\n\n","category":"method"},{"location":"api-model.html#CTBase.constraint-Union{Tuple{V}, Tuple{T}, Tuple{OptimalControlModel{T, V}, Symbol}} where {T<:TimeDependence, V<:VariableDependence}","page":"Model","title":"CTBase.constraint","text":"constraint(\n    ocp::OptimalControlModel{T<:TimeDependence, V<:VariableDependence},\n    label::Symbol\n) -> Any\n\n\nRetrieve a labeled constraint. The result is a function associated with the constraint computation (not taking into account provided value / bounds).\n\nExample\n\njulia> constraint!(ocp, :initial, 0, :c0)\njulia> c = constraint(ocp, :c0)\njulia> c(1)\n1\n\n\n\n\n\n","category":"method"},{"location":"api-model.html#CTBase.constraints_labels-Tuple{OptimalControlModel}","page":"Model","title":"CTBase.constraints_labels","text":"constraints_labels(\n    ocp::OptimalControlModel\n) -> Base.KeySet{Symbol, Dict{Symbol, Tuple}}\n\n\nReturn the labels of the constraints as a Base.keys.\n\nExample\n\njulia> constraints_labels(ocp)\n\n\n\n\n\n","category":"method"},{"location":"api-model.html#CTBase.control!","page":"Model","title":"CTBase.control!","text":"control!(ocp::OptimalControlModel, m::Integer)\ncontrol!(ocp::OptimalControlModel, m::Integer, name::String)\ncontrol!(\n    ocp::OptimalControlModel,\n    m::Integer,\n    name::String,\n    components_names::Vector{String}\n)\n\n\nDefine the control dimension and possibly the names of each coordinate.\n\nExamples\n\njulia> control!(ocp, 1)\njulia> ocp.control_dimension\n1\njulia> ocp.control_components_names\n[\"u\"]\n\njulia> control!(ocp, 1, \"v\")\njulia> ocp.control_dimension\n1\njulia> ocp.control_components_names\n[\"v\"]\n\njulia> control!(ocp, 2)\njulia> ocp.control_dimension\n2\njulia> ocp.control_components_names\n[\"u₁\", \"u₂\"]\n\njulia> control!(ocp, 2, :v)\njulia> ocp.control_dimension\n2\njulia> ocp.control_components_names\n[\"v₁\", \"v₂\"]\n\njulia> control!(ocp, 2, \"v\")\njulia> ocp.control_dimension\n2\njulia> ocp.control_components_names\n[\"v₁\", \"v₂\"]\n\n\n\n\n\n","category":"function"},{"location":"api-model.html#CTBase.dynamics!-Union{Tuple{V}, Tuple{T}, Tuple{OptimalControlModel{T, V}, Function}} where {T<:TimeDependence, V<:VariableDependence}","page":"Model","title":"CTBase.dynamics!","text":"dynamics!(\n    ocp::OptimalControlModel{T<:TimeDependence, V<:VariableDependence},\n    f::Function\n)\n\n\nSet the dynamics.\n\nnote: Note\nThe state, control and variable dimensions must be set before. Use state!, control! and variable!.\nThe times must be set before. Use time!.\nWhen an element is of dimension 1, consider it as a scalar.\n\nExample\n\njulia> dynamics!(ocp, f)\n\n\n\n\n\n","category":"method"},{"location":"api-model.html#CTBase.is_max-Tuple{OptimalControlModel}","page":"Model","title":"CTBase.is_max","text":"is_max(ocp::OptimalControlModel) -> Bool\n\n\nReturn true if the criterion type of ocp is :max.\n\n\n\n\n\n","category":"method"},{"location":"api-model.html#CTBase.is_min-Tuple{OptimalControlModel}","page":"Model","title":"CTBase.is_min","text":"is_min(ocp::OptimalControlModel) -> Bool\n\n\nReturn true if the criterion type of ocp is :min.\n\n\n\n\n\n","category":"method"},{"location":"api-model.html#CTBase.is_time_dependent-Tuple{OptimalControlModel{NonAutonomous}}","page":"Model","title":"CTBase.is_time_dependent","text":"is_time_dependent(\n    ocp::OptimalControlModel{NonAutonomous}\n) -> Bool\n\n\nReturn true if the model has been defined as time dependent.\n\n\n\n\n\n","category":"method"},{"location":"api-model.html#CTBase.is_time_independent-Tuple{OptimalControlModel}","page":"Model","title":"CTBase.is_time_independent","text":"is_time_independent(ocp::OptimalControlModel) -> Bool\n\n\nReturn true if the model has been defined as time independent.\n\n\n\n\n\n","category":"method"},{"location":"api-model.html#CTBase.is_variable_dependent-Tuple{OptimalControlModel{<:TimeDependence, NonFixed}}","page":"Model","title":"CTBase.is_variable_dependent","text":"is_variable_dependent(\n    ocp::OptimalControlModel{<:TimeDependence, NonFixed}\n) -> Bool\n\n\nReturn true if the model has been defined as variable dependent.\n\n\n\n\n\n","category":"method"},{"location":"api-model.html#CTBase.is_variable_independent-Tuple{OptimalControlModel}","page":"Model","title":"CTBase.is_variable_independent","text":"is_variable_independent(ocp::OptimalControlModel) -> Bool\n\n\nReturn true if the model has been defined as variable independent.\n\n\n\n\n\n","category":"method"},{"location":"api-model.html#CTBase.nlp_constraints-Tuple{OptimalControlModel}","page":"Model","title":"CTBase.nlp_constraints","text":"nlp_constraints(\n    ocp::OptimalControlModel\n) -> Tuple{Tuple{Vector{Real}, CTBase.var\"#ξ#99\", Vector{Real}}, Tuple{Vector{Real}, CTBase.var\"#η#100\", Vector{Real}}, Tuple{Vector{Real}, CTBase.var\"#ψ#101\", Vector{Real}}, Tuple{Vector{Real}, CTBase.var\"#ϕ#102\", Vector{Real}}, Tuple{Vector{Real}, CTBase.var\"#θ#103\", Vector{Real}}, Tuple{Vector{Real}, Vector{Int64}, Vector{Real}}, Tuple{Vector{Real}, Vector{Int64}, Vector{Real}}, Tuple{Vector{Real}, Vector{Int64}, Vector{Real}}}\n\n\nReturn a 6-tuple of tuples:\n\n(ξl, ξ, ξu) are control constraints\n(ηl, η, ηu) are state constraints\n(ψl, ψ, ψu) are mixed constraints\n(ϕl, ϕ, ϕu) are boundary constraints\n(θl, θ, θu) are variable constraints\n(ul, uind, uu) are control linear constraints of a subset of indices\n(xl, xind, xu) are state linear constraints of a subset of indices\n(vl, vind, vu) are variable linear constraints of a subset of indices\n\nnote: Note\nThe dimensions of the state and control must be set before calling nlp_constraints.\n\nExample\n\njulia> (ξl, ξ, ξu), (ηl, η, ηu), (ψl, ψ, ψu), (ϕl, ϕ, ϕu), (θl, θ, θu),\n    (ul, uind, uu), (xl, xind, xu), (vl, vind, vu) = nlp_constraints(ocp)\n\n\n\n\n\n","category":"method"},{"location":"api-model.html#CTBase.objective!-Union{Tuple{V}, Tuple{T}, Tuple{OptimalControlModel{T, V}, Symbol, Function, Function}, Tuple{OptimalControlModel{T, V}, Symbol, Function, Function, Symbol}} where {T<:TimeDependence, V<:VariableDependence}","page":"Model","title":"CTBase.objective!","text":"objective!(\n    ocp::OptimalControlModel{T<:TimeDependence, V<:VariableDependence},\n    type::Symbol,\n    g::Function,\n    f⁰::Function\n)\nobjective!(\n    ocp::OptimalControlModel{T<:TimeDependence, V<:VariableDependence},\n    type::Symbol,\n    g::Function,\n    f⁰::Function,\n    criterion::Symbol\n)\n\n\nSet the criterion to the function g and f⁰. Type can be :bolza. Criterion is :min or :max.\n\nnote: Note\nThe state, control and variable dimensions must be set before. Use state!, control! and variable!.\nThe times must be set before. Use time!.\nWhen an element is of dimension 1, consider it as a scalar.\n\nExample\n\njulia> objective!(ocp, :bolza, (x0, xf) -> x0[1] + xf[2], (x, u) -> x[1]^2 + u^2) # the control is of dimension 1\n\n\n\n\n\n","category":"method"},{"location":"api-model.html#CTBase.objective!-Union{Tuple{V}, Tuple{T}, Tuple{OptimalControlModel{T, V}, Symbol, Function}, Tuple{OptimalControlModel{T, V}, Symbol, Function, Symbol}} where {T<:TimeDependence, V<:VariableDependence}","page":"Model","title":"CTBase.objective!","text":"objective!(\n    ocp::OptimalControlModel{T<:TimeDependence, V<:VariableDependence},\n    type::Symbol,\n    f::Function\n)\nobjective!(\n    ocp::OptimalControlModel{T<:TimeDependence, V<:VariableDependence},\n    type::Symbol,\n    f::Function,\n    criterion::Symbol\n)\n\n\nSet the criterion to the function f. Type can be :mayer or :lagrange. Criterion is :min or :max.\n\nnote: Note\nThe state, control and variable dimensions must be set before. Use state!, control! and variable!.\nThe times must be set before. Use time!.\nWhen an element is of dimension 1, consider it as a scalar.\n\nExamples\n\njulia> objective!(ocp, :mayer, (x0, xf) -> x0[1] + xf[2])\njulia> objective!(ocp, :lagrange, (x, u) -> x[1]^2 + u^2) # the control is of dimension 1\n\nwarning: Warning\nIf you set twice the objective, only the last one will be taken into account.\n\n\n\n\n\n","category":"method"},{"location":"api-model.html#CTBase.remove_constraint!-Tuple{OptimalControlModel, Symbol}","page":"Model","title":"CTBase.remove_constraint!","text":"remove_constraint!(\n    ocp::OptimalControlModel,\n    label::Symbol\n) -> Dict{Symbol, Tuple}\n\n\nRemove a labeled constraint.\n\nExample\n\njulia> remove_constraint!(ocp, :con)\n\n\n\n\n\n","category":"method"},{"location":"api-model.html#CTBase.state!","page":"Model","title":"CTBase.state!","text":"state!(ocp::OptimalControlModel, n::Integer)\nstate!(ocp::OptimalControlModel, n::Integer, name::String)\nstate!(\n    ocp::OptimalControlModel,\n    n::Integer,\n    name::String,\n    components_names::Vector{String}\n)\n\n\nDefine the state dimension and possibly the names of each component.\n\nExamples\n\njulia> state!(ocp, 1)\njulia> ocp.state_dimension\n1\njulia> ocp.state_components_names\n[\"x\"]\n\njulia> state!(ocp, 1, \"y\")\njulia> ocp.state_dimension\n1\njulia> ocp.state_components_names\n[\"y\"]\n\njulia> state!(ocp, 2)\njulia> ocp.state_dimension\n2\njulia> ocp.state_components_names\n[\"x₁\", \"x₂\"]\n\njulia> state!(ocp, 2, :y)\njulia> ocp.state_dimension\n2\njulia> ocp.state_components_names\n[\"y₁\", \"y₂\"]\n\njulia> state!(ocp, 2, \"y\")\njulia> ocp.state_dimension\n2\njulia> ocp.state_components_names\n[\"y₁\", \"y₂\"]\n\n\n\n\n\n","category":"function"},{"location":"api-model.html#CTBase.time!","page":"Model","title":"CTBase.time!","text":"time!(\n    ocp::OptimalControlModel{<:TimeDependence, NonFixed},\n    t0::Real,\n    indf::Index\n)\ntime!(\n    ocp::OptimalControlModel{<:TimeDependence, NonFixed},\n    t0::Real,\n    indf::Index,\n    name::String\n)\n\n\nFix initial time, final time is free and given by the variable at the provided index.\n\nnote: Note\nYou can use time! once to set either the initial or the final time, or both.\n\nExamples\n\njulia> time!(ocp, 0, Index(2), \"t\")\n\n\n\n\n\n","category":"function"},{"location":"api-model.html#CTBase.time!-2","page":"Model","title":"CTBase.time!","text":"time!(\n    ocp::OptimalControlModel,\n    times::AbstractVector{<:Real}\n) -> Any\ntime!(\n    ocp::OptimalControlModel,\n    times::AbstractVector{<:Real},\n    name::String\n) -> Any\n\n\nFix initial and final times to times[1] and times[2], respectively.\n\nExamples\n\njulia> time!(ocp, [ 0, 1 ])\njulia> ocp.initial_time\n0\njulia> ocp.final_time\n1\njulia> ocp.time_name\n\"t\"\n\njulia> time!(ocp, [ 0, 1 ], \"s\")\njulia> ocp.initial_time\n0\njulia> ocp.final_time\n1\njulia> ocp.time_name\n\"s\"\n\njulia> time!(ocp, [ 0, 1 ], :s)\njulia> ocp.initial_time\n0\njulia> ocp.final_time\n1\njulia> ocp.time_name\n\"s\"\n\n\n\n\n\n","category":"function"},{"location":"api-model.html#CTBase.time!-3","page":"Model","title":"CTBase.time!","text":"time!(\n    ocp::OptimalControlModel{<:TimeDependence, NonFixed},\n    ind0::Index,\n    tf::Real\n)\ntime!(\n    ocp::OptimalControlModel{<:TimeDependence, NonFixed},\n    ind0::Index,\n    tf::Real,\n    name::String\n)\n\n\nFix final time, initial time is free and given by the variable at the provided index.\n\nExamples\n\njulia> time!(ocp, Index(2), 1, \"t\")\n\n\n\n\n\n","category":"function"},{"location":"api-model.html#CTBase.time!-4","page":"Model","title":"CTBase.time!","text":"time!(\n    ocp::OptimalControlModel{<:TimeDependence, NonFixed},\n    ind0::Index,\n    indf::Index\n)\ntime!(\n    ocp::OptimalControlModel{<:TimeDependence, NonFixed},\n    ind0::Index,\n    indf::Index,\n    name::String\n)\n\n\nInitial and final times are free and given by the variable at the provided indices.\n\nExamples\n\njulia> time!(ocp, Index(2), Index(3), \"t\")\n\n\n\n\n\n","category":"function"},{"location":"api-model.html#CTBase.time!-5","page":"Model","title":"CTBase.time!","text":"time!(ocp::OptimalControlModel, t0::Real, tf::Real)\ntime!(\n    ocp::OptimalControlModel,\n    t0::Real,\n    tf::Real,\n    name::String\n)\n\n\nFix initial and final times to times[1] and times[2], respectively.\n\nExamples\n\njulia> time!(ocp, 0, 1)\njulia> ocp.initial_time\n0\njulia> ocp.final_time\n1\njulia> ocp.time_name\n\"t\"\n\njulia> time!(ocp, 0, 1, \"s\")\njulia> ocp.initial_time\n0\njulia> ocp.final_time\n1\njulia> ocp.time_name\n\"s\"\n\njulia> time!(ocp, 0, 1, :s)\njulia> ocp.initial_time\n0\njulia> ocp.final_time\n1\njulia> ocp.time_name\n\"s\"\n\n\n\n\n\n","category":"function"},{"location":"api-model.html#CTBase.variable!","page":"Model","title":"CTBase.variable!","text":"variable!(ocp::OptimalControlModel, q::Integer)\nvariable!(\n    ocp::OptimalControlModel,\n    q::Integer,\n    name::String\n)\nvariable!(\n    ocp::OptimalControlModel,\n    q::Integer,\n    name::String,\n    components_names::Vector{String}\n)\n\n\nDefine the variable dimension and possibly the names of each component.\n\nExamples\n\njulia> variable!(ocp, 1, \"v\")\njulia> variable!(ocp, 2, [ \"v₁\", \"v₂\" ])\n\n\n\n\n\n","category":"function"},{"location":"api-default.html#Default","page":"Default","title":"Default","text":"","category":"section"},{"location":"api-default.html","page":"Default","title":"Default","text":"CurrentModule =  CTBase","category":"page"},{"location":"api-default.html","page":"Default","title":"Default","text":"Modules = [CTBase]\nOrder = [:module, :constant, :type, :function, :macro]\nPages = [\"default.jl\"]\nPrivate = false","category":"page"},{"location":"api-utils.html#Utils","page":"Utils","title":"Utils","text":"","category":"section"},{"location":"api-utils.html","page":"Utils","title":"Utils","text":"CurrentModule =  CTBase","category":"page"},{"location":"api-utils.html","page":"Utils","title":"Utils","text":"Modules = [CTBase]\nOrder = [:module, :constant, :type, :function, :macro]\nPages = [\"utils.jl\"]\nPrivate = false","category":"page"},{"location":"api-utils.html#CTBase.Ad-Tuple{Any, Any}","page":"Utils","title":"CTBase.Ad","text":"Ad(X, f) -> CTBase.var\"#15#16\"\n\n\nLie derivative of f along X.\n\n\n\n\n\n","category":"method"},{"location":"api-utils.html#CTBase.Poisson-Tuple{Any, Any}","page":"Utils","title":"CTBase.Poisson","text":"Poisson(f, g) -> CTBase.var\"#fg#19\"\n\n\nReturn the Poisson bracket of f and g.\n\n\n\n\n\n","category":"method"},{"location":"api-utils.html#CTBase.ctgradient-Tuple{Function, Any}","page":"Utils","title":"CTBase.ctgradient","text":"ctgradient(f::Function, x) -> Any\n\n\nReturn the gradient of f at x.\n\n\n\n\n\n","category":"method"},{"location":"api-utils.html#CTBase.ctindices-Tuple{Integer}","page":"Utils","title":"CTBase.ctindices","text":"ctindices(i::Integer) -> String\n\n\nReturn i > 0 as a subscript.\n\n\n\n\n\n","category":"method"},{"location":"api-utils.html#CTBase.ctinterpolate-Tuple{Any, Any}","page":"Utils","title":"CTBase.ctinterpolate","text":"ctinterpolate(x, f) -> Any\n\n\nReturn the interpolation of f at x.\n\n\n\n\n\n","category":"method"},{"location":"api-utils.html#CTBase.ctjacobian-Tuple{Function, Any}","page":"Utils","title":"CTBase.ctjacobian","text":"ctjacobian(f::Function, x) -> Any\n\n\nReturn the Jacobian of f at x.\n\n\n\n\n\n","category":"method"},{"location":"api-utils.html#CTBase.ctupperscripts-Tuple{Integer}","page":"Utils","title":"CTBase.ctupperscripts","text":"ctupperscripts(i::Integer) -> String\n\n\nReturn i > 0 as an upperscript.\n\n\n\n\n\n","category":"method"},{"location":"index.html#Introduction-to-the-CTBase.jl-package","page":"Introduction","title":"Introduction to the CTBase.jl package","text":"","category":"section"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"The CTBase.jl package is part of the control-toolbox ecosystem.","category":"page"},{"location":"index.html#Installation","page":"Introduction","title":"Installation","text":"","category":"section"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"To install a package from the control-toolbox ecosystem, please visit the installation page.","category":"page"}]
}
